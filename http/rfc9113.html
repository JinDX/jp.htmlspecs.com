<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="ja-JP">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>RFC 9113 - HTTP/2</title>
    <script>
        function getMeta(rfcno, container) {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", "https://www.rfc-editor.org/rfc/rfc" + rfcno + ".json", true);
            xhr.onload = function (e) {
                if (xhr.readyState === 4) {
                    if (xhr.status === 200) {
                        var data = JSON.parse(xhr.response);

                        var cont = document.getElementById(container);
                        // empty the container
                        while (cont.firstChild) {
                            cont.removeChild(myNode.firstChild);
                        }

                        var c = data.status;
                        if (c) {
                            var bld = newElementWithText("b", c);
                            cont.appendChild(bld);
                        } else {
                            cont.appendChild(newElementWithText("i", "(document status unknown)"));
                        }

                        c = data.updated_by;
                        if (c && c.length > 0 && c[0] !== null && c[0].length > 0) {
                            cont.appendChild(newElement("br"));
                            cont.appendChild(newText("Updated by: "));
                            appendRfcLinks(cont, c);
                        }

                        c = data.obsoleted_by;
                        if (c && c.length > 0 && c[0] !== null && c[0].length > 0) {
                            cont.appendChild(newElement("br"));
                            cont.appendChild(newText("Obsoleted by: "));
                            appendRfcLinks(cont, c);
                        }

                        c = data.errata_url;
                        if (c) {
                            cont.appendChild(newElement("br"));
                            var link = newElementWithText("a", "errata");
                            link.setAttribute("href", c);
                            var errata = newElementWithText("i", "This document has ");
                            errata.appendChild(link);
                            errata.appendChild(newText("."));
                            cont.appendChild(errata);
                        }

                        cont.style.display = "block";
                    } else {
                        console.error(xhr.statusText);
                    }
                }
            };
            xhr.onerror = function (e) {
                console.error(xhr.status + " " + xhr.statusText);
            };
            xhr.send(null);
        }
        function appendRfcLinks(parent, updates) {
            var template = "https://www.rfc-editor.org/rfc/rfc{rfc}.html";
            for (var i = 0; i < updates.length; i++) {
                var rfc = updates[i].trim().toLowerCase();
                if (rfc.substring(0, 3) == "rfc") {
                    var no = parseInt(rfc.substring(3), 10);

                    var link = newElement("a");
                    link.setAttribute("href", template.replace("{rfc}", no));
                    link.appendChild(newText(no));
                    parent.appendChild(link);
                } else {
                    parent.appendChild(newText(rfc));
                }
                if (i != updates.length - 1) {
                    parent.appendChild(newText(", "));
                }
            }
        }

        // DOM helpers
        function newElement(name) {
            return document.createElement(name);
        }
        function newElementWithText(name, txt) {
            var e = document.createElement(name);
            e.appendChild(newText(txt));
            return e;
        }
        function newText(text) {
            return document.createTextNode(text);
        }
    </script>
    <script>
        function anchorRewrite() {
            map = {};
            if (window.location.hash.length >= 1) {
                var fragid = window.location.hash.substr(1);
                if (fragid) {
                    if (!document.getElementById(fragid)) {
                        var prefix = "rfc.";
                        var mapped = map[fragid];
                        if (mapped) {
                            window.location.hash = mapped;
                        } else if (fragid.indexOf("section-") == 0) {
                            window.location.hash = prefix + "section." + fragid.substring(8).replace("-", ".p.");
                        } else if (fragid.indexOf("appendix-") == 0) {
                            window.location.hash = prefix + "section." + fragid.substring(9).replace("-", ".p.");
                        } else if (fragid.indexOf("s-") == 0) {
                            var postfix = fragid.substring(2);
                            if (postfix.startsWith("abstract")) {
                                window.location.hash = prefix + postfix;
                            } else if (postfix.startsWith("note-")) {
                                window.location.hash = prefix + "note." + postfix.substring(5).replace("-", ".p.");
                            } else {
                                window.location.hash = prefix + "section." + postfix.replace("-", ".p.");
                            }
                        } else if (fragid.indexOf("p-") == 0) {
                            var r = fragid.substring(2);
                            var p = r.indexOf("-");
                            if (p >= 0) {
                                window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
                            }
                        }
                    }
                }
            }
        }
        window.addEventListener('hashchange', anchorRewrite);
        window.addEventListener('DOMContentLoaded', anchorRewrite);
    </script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:type" content="article">
    <meta property="og:title" content="RFC9113">
    <meta property="og:description" content="HTTP/2">
    <meta property="og:url" content="https://httpwg.org/specs/rfc9113.html">
    <meta property="og:site_name" content="IETF HTTP Working Group Specifications">
    <meta property="og:image" content="https://httpwg.org/assets/favicon/apple-icon-180x180.png">
    <link rel="stylesheet" type="text/css"
        href="https://httpwg.org/assets/node_modules/bootstrap/dist/css/bootstrap.min.css">
    <style type="text/css">
        body {
            padding-top: 80px;
            padding-bottom: 80px;
            position: relative;
        }

        .table.header th,
        .table.header td {
            border-top: none;
            padding: 0;
        }

        #sidebar {
            margin-top: -10px;
            height: 90%;
            overflow-y: auto;
            font-size: 90%;
        }

        #rfc\.meta {
            width: 40%;
            float: right
        }

        .toc ul {
            list-style: none;
        }

        .filename {
            color: rgb(119, 119, 119);
            font-size: 23px;
            font-weight: normal;
            height: auto;
            line-height: 23px;
        }

        dl {
            margin-left: 1em;
        }

        dl.dl-horizontal {
            margin-left: 0;
        }

        dl>dt {
            float: left;
            margin-right: 1em;
        }

        dl.nohang>dt {
            float: none;
        }

        dl>dd {
            margin-bottom: .5em;
        }

        dl.compact>dd {
            margin-bottom: 0em;
        }

        dl>dd>dl {
            margin-top: 0.5em;
            margin-bottom: 0em;
        }

        ul.empty {
            list-style-type: none;
        }

        ul.empty li {
            margin-top: .5em;
        }

        td.reference {
            padding-right: 1em;
            vertical-align: top;
        }

        .feedback {
            position: fixed;
            bottom: 5px;
            right: 5px;
        }

        .fbbutton {
            margin-left: 5px;
        }

        h1 a,
        h2 a,
        h3 a,
        h4 a,
        h5 a,
        h6 a {
            color: rgb(51, 51, 51);
        }

        span.tt {
            font: 11pt consolas, monospace;
            font-size-adjust: none;
        }
    </style>
    <link rel="stylesheet" type="text/css" href="https://httpwg.org/assets/site.css">
    <link rel="Contents" href="#rfc.toc">
    <link rel="Author" href="#rfc.authors">
    <link rel="License" href="#rfc.copyrightnotice">
    <link rel="Chapter" title="1 Introduction" href="#rfc.section.1">
    <link rel="Chapter" title="2 HTTP/2 Protocol Overview" href="#rfc.section.2">
    <link rel="Chapter" title="3 Starting HTTP/2" href="#rfc.section.3">
    <link rel="Chapter" title="4 HTTP Frames" href="#rfc.section.4">
    <link rel="Chapter" title="5 Streams and Multiplexing" href="#rfc.section.5">
    <link rel="Chapter" title="6 Frame Definitions" href="#rfc.section.6">
    <link rel="Chapter" title="7 Error Codes" href="#rfc.section.7">
    <link rel="Chapter" title="8 Expressing HTTP Semantics in HTTP/2" href="#rfc.section.8">
    <link rel="Chapter" title="9 HTTP/2 Connections" href="#rfc.section.9">
    <link rel="Chapter" title="10 Security Considerations" href="#rfc.section.10">
    <link rel="Chapter" title="11 IANA Considerations" href="#rfc.section.11">
    <link rel="Chapter" title="12 References" href="#rfc.section.12">
    <link rel="Appendix" title="A Prohibited TLS 1.2 Cipher Suites" href="#rfc.section.A">
    <link rel="Appendix" title="B Changes from RFC 7540" href="#rfc.section.B">
    <link rel="Appendix" title="Acknowledgments" href="#rfc.section.unnumbered-4">
    <link rel="Appendix" title="Contributors" href="#rfc.section.unnumbered-5">
    <link href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-http2bis-latest" rel="prev">
    <link href="https://dx.doi.org/10.17487/rfc9113" rel="alternate">
    <link href="urn:issn:2070-1721" rel="alternate">
    <link rel="Alternate" title="Plain Text Version" href="http://www.ietf.org/rfc/rfc9113.txt">
    <link rel="Help" title="RFC-Editor's Status Page" href="https://www.rfc-editor.org/info/rfc9113">
    <meta name="viewport" content="initial-scale=1">
    <meta name="generator"
        content="https://github.com/mnot/RFCBootstrap XSLT vendor: Saxonica http://www.saxonica.com/">
    <meta name="keywords" content="HTTP, SPDY, Web">
    <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
    <meta name="dcterms.creator" content="Thomson, M.">
    <meta name="dcterms.creator" content="Benfield, C.">
    <meta name="dcterms.identifier" content="urn:ietf:rfc:9113">
    <meta name="dcterms.issued" content="2022-06">
    <meta name="dct.replaces" content="urn:ietf:rfc:7540">
    <meta name="dct.replaces" content="urn:ietf:rfc:8740">
    <meta name="dcterms.abstract"
        content="This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2). HTTP/2 enables a more efficient use of network resources and a reduced latency by introducing field compression and allowing multiple concurrent exchanges on the same connection.This document obsoletes RFCs 7540 and 8740.">
    <meta name="dcterms.isPartOf" content="urn:issn:2070-1721">
    <meta name="description"
        content="This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2). HTTP/2 enables a more efficient use of network resources and a reduced latency by introducing field compression and allowing multiple concurrent exchanges on the same connection.This document obsoletes RFCs 7540 and 8740.">
</head>

<body onload="getMeta(9113,'rfc.meta');">
    <nav class="navbar navbar-dark bg-dark d-print-none navbar-expand-lg fixed-top ps-3 pe-3" role="navigation">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapse"
                aria-controls="navbarToggler" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>

            <a class="navbar-brand" href="https://httpwg.org/"><img src="https://httpwg.org/assets/http.svg"
                    height="23"></a>
        </div>

        <div class="collapse navbar-collapse" id="navbar-collapse">

            <div class="navbar-nav me-auto">

                <a class="nav-item ms-1 text-white" href="https://httpwg.org/specs/">📄 Documentation</a>

                <div class="dropdown ms-4">
                    <a href="#" class="nav-item dropdown-toggle text-white" data-bs-toggle="dropdown">Work in
                        Progress</a>
                    <ul class="dropdown-menu">
                        <li class="dropdown-item"><a href="https://httpwg.org/http-extensions/">HTTP Extensions</a></li>
                        <li class="dropdown-item"><a
                                href="https://github.com/httpwg/admin/issues?q=is%3Aissue+is%3Aopen+label%3Aadoption">Future
                                Work</a></li>
                    </ul>
                </div>

                <div class="dropdown ms-4">
                    <a href="#" class="nav-item dropdown-toggle text-white" data-bs-toggle="dropdown">Participate</a>
                    <ul class="dropdown-menu">
                        <li class="dropdown-item"><a href="https://httpwg.org/about/">About the HTTP Working Group</a>
                        </li>
                        <li class="divider"></li>
                        <li class="dropdown-item"><a href="https://httpwg.org/CONTRIBUTING.html">Contribution Policy</a>
                        </li>
                        <li class="dropdown-item"><a href="http://datatracker.ietf.org/wg/httpbis/charter/">WG
                                Charter</a></li>
                        <li class="dropdown-item"><a href="http://lists.w3.org/Archives/Public/ietf-http-wg/">Group
                                Mailing List 📨</a></li>
                        <li class="dropdown-item"><a href="https://httpwg.org/wg-materials/">Meeting Materials</a></li>
                        <li class="dropdown-item"><a href="https://httpwg.org/admin/editors/">Document Editor
                                Resources</a></li>
                    </ul>
                </div>
            </div>

        </div>
    </nav>
    <div class="container" id="top">
        <div class="row">
            <div class="col-lg-4 order-last d-none d-lg-block" id="sidebar" role="navigation">
                <div class="navbar">
                    <div class="navbar-brand"><a href="#top"><strong>RFC </strong>9113</a></div><br clear="all">
                    <div class="">
                        <div class="toc ">
                            <ul>
                                <li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#intro">はじめに</a>
                                </li>
                                <li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#Overview">HTTP/2
                                        プロトコルの概要</a>
                                    <ul>
                                        <li><a href="#rfc.section.2.1">2.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#rfc.section.2.1">文書の構成</a></li>
                                        <li><a href="#rfc.section.2.2">2.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#rfc.section.2.2">慣例と用語</a></li>
                                    </ul>
                                </li>
                                <li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#starting">HTTP/2 の開始</a>
                                    <ul>
                                        <li><a href="#rfc.section.3.1">3.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#versioning">HTTP/2 バージョン識別</a></li>
                                        <li><a href="#rfc.section.3.2">3.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#discover-https">「<span class="tt">https</span>」URI のための HTTP/2
                                                の開始</a></li>
                                        <li><a href="#rfc.section.3.3">3.3.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#known-http">事前知識による HTTP/2 の開始</a></li>
                                        <li><a href="#rfc.section.3.4">3.4.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#preface">HTTP/2 接続序文</a></li>
                                    </ul>
                                </li>
                                <li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#FramingLayer">HTTP
                                        フレーム</a>
                                    <ul>
                                        <li><a href="#rfc.section.4.1">4.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#FrameHeader">フレーム形式</a></li>
                                        <li><a href="#rfc.section.4.2">4.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#FrameSize">フレームサイズ</a></li>
                                        <li><a href="#rfc.section.4.3">4.3.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#FieldBlock">フィールドセクションの圧縮と解凍</a>
                                            <ul>
                                                <li><a href="#rfc.section.4.3.1">4.3.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#dynamic-table">圧縮状態</a></li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#StreamsLayer">ストリームと多重化</a>
                                    <ul>
                                        <li><a href="#rfc.section.5.1">5.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#StreamStates">ストリームの状態</a>
                                            <ul>
                                                <li><a href="#rfc.section.5.1.1">5.1.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#StreamIdentifiers">ストリーム識別子</a></li>
                                                <li><a href="#rfc.section.5.1.2">5.1.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#rfc.section.5.1.2">ストリームの同時実行</a></li>
                                            </ul>
                                        </li>
                                        <li><a href="#rfc.section.5.2">5.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#FlowControl">フロー制御</a>
                                            <ul>
                                                <li><a href="#rfc.section.5.2.1">5.2.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#fc-principles">フロー制御の原則</a></li>
                                                <li><a href="#rfc.section.5.2.2">5.2.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#DisableFlowControl">フロー制御の適切な使用</a>
                                                </li>
                                                <li><a href="#rfc.section.5.2.3">5.2.3.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#FlowControlPerformance">フロー制御の性能</a></li>
                                            </ul>
                                        </li>
                                        <li><a href="#rfc.section.5.3">5.3.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#StreamPriority">優先度付け</a>
                                            <ul>
                                                <li><a href="#rfc.section.5.3.1">5.3.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#PriorityHistory">RFC 7540 における優先度の背景</a>
                                                </li>
                                                <li><a href="#rfc.section.5.3.2">5.3.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#PriorityHere">本書における優先度シグナリング</a>
                                                </li>
                                            </ul>
                                        </li>
                                        <li><a href="#rfc.section.5.4">5.4.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#ErrorHandler">エラー処理</a>
                                            <ul>
                                                <li><a href="#rfc.section.5.4.1">5.4.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#ConnectionErrorHandler">接続エラー処理</a>
                                                </li>
                                                <li><a href="#rfc.section.5.4.2">5.4.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#StreamErrorHandler">ストリームエラー処理</a></li>
                                                <li><a href="#rfc.section.5.4.3">5.4.3.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#rfc.section.5.4.3">接続の終了</a></li>
                                            </ul>
                                        </li>
                                        <li><a href="#rfc.section.5.5">5.5.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#extensibility">HTTP/2 の拡張</a></li>
                                    </ul>
                                </li>
                                <li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#FrameTypes">フレーム定義</a>
                                    <ul>
                                        <li><a href="#rfc.section.6.1">6.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#DATA">DATA</a></li>
                                        <li><a href="#rfc.section.6.2">6.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#HEADERS">HEADERS</a></li>
                                        <li><a href="#rfc.section.6.3">6.3.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#PRIORITY">PRIORITY</a></li>
                                        <li><a href="#rfc.section.6.4">6.4.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#RST_STREAM">RST_STREAM</a></li>
                                        <li><a href="#rfc.section.6.5">6.5.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#SETTINGS">SETTINGS</a>
                                            <ul>
                                                <li><a href="#rfc.section.6.5.1">6.5.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#SettingFormat">SETTINGS の形式</a></li>
                                                <li><a href="#rfc.section.6.5.2">6.5.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#SettingValues">SETTINGS の定義</a></li>
                                                <li><a href="#rfc.section.6.5.3">6.5.3.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#SettingsSync">設定の同期</a></li>
                                            </ul>
                                        </li>
                                        <li><a href="#rfc.section.6.6">6.6.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#PUSH_PROMISE">PUSH_PROMISE</a></li>
                                        <li><a href="#rfc.section.6.7">6.7.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#PING">PING</a></li>
                                        <li><a href="#rfc.section.6.8">6.8.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#GOAWAY">GOAWAY</a></li>
                                        <li><a href="#rfc.section.6.9">6.9.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#WINDOW_UPDATE">WINDOW_UPDATE</a>
                                            <ul>
                                                <li><a href="#rfc.section.6.9.1">6.9.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#rfc.section.6.9.1">フロー制御ウィンドウ</a></li>
                                                <li><a href="#rfc.section.6.9.2">6.9.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#InitialWindowSize">初期フロー制御ウィンドウサイズ</a>
                                                </li>
                                                <li><a href="#rfc.section.6.9.3">6.9.3.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#rfc.section.6.9.3">ストリームウィンドウサイズの縮小</a>
                                                </li>
                                            </ul>
                                        </li>
                                        <li><a href="#rfc.section.6.10">6.10.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#CONTINUATION">CONTINUATION</a></li>
                                    </ul>
                                </li>
                                <li><a href="#rfc.section.7">7.</a>&nbsp;&nbsp;&nbsp;<a href="#ErrorCodes">エラーコード</a>
                                </li>
                                <li><a href="#rfc.section.8">8.</a>&nbsp;&nbsp;&nbsp;<a href="#HttpLayer">HTTP/2 における
                                        HTTP セマンティクスの表現</a>
                                    <ul>
                                        <li><a href="#rfc.section.8.1">8.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#HttpFraming">HTTP メッセージのフレーミング</a>
                                            <ul>
                                                <li><a href="#rfc.section.8.1.1">8.1.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#malformed">不正なメッセージ</a></li>
                                            </ul>
                                        </li>
                                        <li><a href="#rfc.section.8.2">8.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#HttpHeaders">HTTP フィールド</a>
                                            <ul>
                                                <li><a href="#rfc.section.8.2.1">8.2.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#rfc.section.8.2.1">フィールドの妥当性</a></li>
                                                <li><a href="#rfc.section.8.2.2">8.2.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#ConnectionSpecific">接続固有のヘッダーフィールド</a>
                                                </li>
                                                <li><a href="#rfc.section.8.2.3">8.2.3.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#CompressCookie">Cookie ヘッダーフィールドの圧縮</a>
                                                </li>
                                            </ul>
                                        </li>
                                        <li><a href="#rfc.section.8.3">8.3.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#PseudoHeaderFields">HTTP 制御データ</a>
                                            <ul>
                                                <li><a href="#rfc.section.8.3.1">8.3.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#HttpRequest">リクエスト擬似ヘッダーフィールド</a></li>
                                                <li><a href="#rfc.section.8.3.2">8.3.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#HttpResponse">レスポンス擬似ヘッダーフィールド</a></li>
                                            </ul>
                                        </li>
                                        <li><a href="#rfc.section.8.4">8.4.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#PushResources">サーバープッシュ</a>
                                            <ul>
                                                <li><a href="#rfc.section.8.4.1">8.4.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#PushRequests">プッシュリクエスト</a></li>
                                                <li><a href="#rfc.section.8.4.2">8.4.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#PushResponses">プッシュレスポンス</a></li>
                                            </ul>
                                        </li>
                                        <li><a href="#rfc.section.8.5">8.5.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#CONNECT">CONNECT メソッド</a></li>
                                        <li><a href="#rfc.section.8.6">8.6.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#informational-responses">Upgrade ヘッダーフィールド</a></li>
                                        <li><a href="#rfc.section.8.7">8.7.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#Reliability">リクエストの信頼性</a></li>
                                        <li><a href="#rfc.section.8.8">8.8.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#HttpExamples">例</a>
                                            <ul>
                                                <li><a href="#rfc.section.8.8.1">8.8.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#rfc.section.8.8.1">単純なリクエスト</a></li>
                                                <li><a href="#rfc.section.8.8.2">8.8.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#rfc.section.8.8.2">単純なレスポンス</a></li>
                                                <li><a href="#rfc.section.8.8.3">8.8.3.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#rfc.section.8.8.3">複雑なリクエスト</a></li>
                                                <li><a href="#rfc.section.8.8.4">8.8.4.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#rfc.section.8.8.4">本文付きレスポンス</a></li>
                                                <li><a href="#rfc.section.8.8.5">8.8.5.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#rfc.section.8.8.5">情報レスポンス</a></li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li><a href="#rfc.section.9">9.</a>&nbsp;&nbsp;&nbsp;<a href="#HttpExtra">HTTP/2 接続</a>
                                    <ul>
                                        <li><a href="#rfc.section.9.1">9.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#rfc.section.9.1">接続管理</a>
                                            <ul>
                                                <li><a href="#rfc.section.9.1.1">9.1.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#reuse">接続の再利用</a></li>
                                            </ul>
                                        </li>
                                        <li><a href="#rfc.section.9.2">9.2.</a>&nbsp;&nbsp;&nbsp;<a href="#TLSUsage">TLS
                                                機能の使用</a>
                                            <ul>
                                                <li><a href="#rfc.section.9.2.1">9.2.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#tls12features">TLS 1.2 の機能</a></li>
                                                <li><a href="#rfc.section.9.2.2">9.2.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#tls12ciphers">TLS 1.2 の暗号スイート</a></li>
                                                <li><a href="#rfc.section.9.2.3">9.2.3.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#tls13features">TLS 1.3 の機能</a></li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li><a href="#rfc.section.10">10.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#security">セキュリティに関する考慮事項</a>
                                    <ul>
                                        <li><a href="#rfc.section.10.1">10.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#authority">サーバーの権限</a></li>
                                        <li><a href="#rfc.section.10.2">10.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#rfc.section.10.2">クロスプロトコル攻撃</a></li>
                                        <li><a href="#rfc.section.10.3">10.3.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#rfc.section.10.3">仲介者カプセル化攻撃</a></li>
                                        <li><a href="#rfc.section.10.4">10.4.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#rfc.section.10.4">プッシュされたレスポンスのキャッシュ可能性</a></li>
                                        <li><a href="#rfc.section.10.5">10.5.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#dos">サービス拒否（DoS）に関する考慮事項</a>
                                            <ul>
                                                <li><a href="#rfc.section.10.5.1">10.5.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#MaxFieldBlock">フィールドブロックサイズの制限</a></li>
                                                <li><a href="#rfc.section.10.5.2">10.5.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                        href="#connectDos">CONNECT の問題</a></li>
                                            </ul>
                                        </li>
                                        <li><a href="#rfc.section.10.6">10.6.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#rfc.section.10.6">圧縮の使用</a></li>
                                        <li><a href="#rfc.section.10.7">10.7.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#padding">パディングの使用</a></li>
                                        <li><a href="#rfc.section.10.8">10.8.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#rfc.section.10.8">プライバシーに関する考慮事項</a></li>
                                        <li><a href="#rfc.section.10.9">10.9.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#rfc.section.10.9">リモートタイミング攻撃</a></li>
                                    </ul>
                                </li>
                                <li><a href="#rfc.section.11">11.</a>&nbsp;&nbsp;&nbsp;<a href="#iana">IANA に関する考慮事項</a>
                                    <ul>
                                        <li><a href="#rfc.section.11.1">11.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#HTTP2-Settings">HTTP2-Settings ヘッダーフィールド登録</a></li>
                                        <li><a href="#rfc.section.11.2">11.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#iana-h2c">h2c アップグレードトークン</a></li>
                                    </ul>
                                </li>
                                <li><a href="#rfc.section.12">12.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#rfc.references">参考文献</a>
                                    <ul>
                                        <li><a href="#rfc.section.12.1">12.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#rfc.references.2">規範的参考文献</a></li>
                                        <li><a href="#rfc.section.12.2">12.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#rfc.references.3">情報参考文献</a></li>
                                    </ul>
                                </li>
                                <li><a href="#rfc.section.A">Appendix A.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#BadCipherSuites">付録 A. 禁止された TLS 1.2 暗号スイート</a></li>
                                <li><a href="#rfc.section.B">Appendix B.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#revision-updates">付録 B. RFC 7540 からの変更</a></li>
                                <li><a href="#rfc.section.unnumbered-4">Acknowledgments</a></li>
                                <li><a href="#rfc.section.unnumbered-5">Contributors</a></li>
                                <li><a href="#rfc.authors">Authors' Addresses</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-lg-8 order-first main" role="main">
                <header>
                    <table class="table table-condensed header" id="rfc.headerblock">
                        <tbody>
                            <tr>
                                <td class="text-left">インターネット・エンジニアリング・タスクフォース（IETF）</td>
                                <td class="text-right">M. Thomson（編集者）</td>
                            </tr>
                            <tr>
                                <td class="text-left">Request for Comments: 9113</td>
                                <td class="text-right">Mozilla</td>
                            </tr>
                            <tr>
                                <td class="text-left">Obsoletes: <a href="#RFC7540">7540</a>, <a
                                        href="#RFC8740">8740</a></td>
                                <td class="text-right">C. Benfield（編集者）</td>
                            </tr>
                            <tr>
                                <td class="text-left">Category: Standards Track</td>
                                <td class="text-right">Apple Inc.</td>
                            </tr>
                            <tr>
                                <td class="text-left">ISSN: 2070-1721</td>
                                <td class="text-right">2022年6月</td>
                            </tr>
                        </tbody>
                    </table>
                    <div id="rfc.title">
                        <h1>HTTP/2</h1>
                    </div>
                </header>
                <hr>
                <h2 id="rfc.abstract"><a href="#rfc.abstract">要約</a></h2>
                <div class="lead">
                    <div id="rfc.abstract.p.1">
                        <p>この仕様は、ハイパーテキスト転送プロトコル（HTTP）のセマンティクスを最適化して表現したもの、HTTP バージョン 2（HTTP/2）について説明します。HTTP/2
                            はフィールド圧縮を導入し、同一接続上で複数の同時交換を可能にすることで、ネットワークリソースのより効率的な利用と遅延の低減を実現します。</p>
                    </div>
                    <div id="rfc.abstract.p.2">
                        <p>この文書は RFC 7540 および 8740 を廃止します。</p>
                    </div>
                </div>
                <aside id="rfc.meta" class="alert alert-info"></aside>
                <section id="rfc.status">
                    <h2><a href="#rfc.status">このメモのステータス</a></h2>
                    <div id="rfc.boilerplate.1.p.1">
                        <p>これはインターネット標準トラック文書です。</p>
                    </div>
                    <div id="rfc.boilerplate.1.p.2">
                        <p>この文書はインターネット・エンジニアリング・タスクフォース（IETF）の成果物です。IETF
                            コミュニティのコンセンサスを表しています。公開レビューを受け、インターネット・エンジニアリング・ステアリング・グループ（IESG）によって公開が承認されています。インターネット標準に関するさらなる情報は
                            <a href="https://www.rfc-editor.org/rfc/rfc7841.html#section-2">RFC 7841 のセクション 2</a>
                            をご覧ください。
                        </p>
                    </div>
                    <div id="rfc.boilerplate.1.p.3">
                        <p>この文書の現在のステータス、訂正情報（errata）、およびフィードバックの送付方法に関する情報は <a
                                href="https://www.rfc-editor.org/info/rfc9113">https://www.rfc-editor.org/info/rfc9113</a>
                            で入手できます。</p>
                    </div>
                </section>
                <section id="rfc.copyrightnotice">
                    <h2><a href="#rfc.copyrightnotice">著作権表示</a></h2>
                    <div id="rfc.boilerplate.2.p.1">
                        <p>Copyright (c) 2022 IETF Trust and the persons identified as the document authors. All rights
                            reserved.</p>
                    </div>
                    <div id="rfc.boilerplate.2.p.2">
                        <p>この文書は BCP 78 および IETF Trust の IETF 文書に関する法的規定（<a
                                href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a>）
                            の対象です。発行日に有効なこれらの文書をよくご確認ください。これらは本書に関するあなたの権利と制限を説明しています。本書から抽出されたコードコンポーネントには、Trust
                            法的規定のセクション 4.e に記載されている改訂 BSD ライセンスの文言を含める必要があり、改訂 BSD ライセンスに記載されているとおり保証なしで提供されます。</p>
                    </div>
                </section>
                <div class="toc d-lg-none">
                    <ul>
                        <li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#intro">はじめに</a></li>
                        <li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#Overview">HTTP/2 プロトコルの概要</a>
                            <ul>
                                <li><a href="#rfc.section.2.1">2.1.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#rfc.section.2.1">文書の構成</a></li>
                                <li><a href="#rfc.section.2.2">2.2.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#rfc.section.2.2">慣例と用語</a></li>
                            </ul>
                        </li>
                        <li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#starting">HTTP/2 の開始</a>
                            <ul>
                                <li><a href="#rfc.section.3.1">3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#versioning">HTTP/2
                                        バージョン識別</a></li>
                                <li><a href="#rfc.section.3.2">3.2.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#discover-https">「<span class="tt">https</span>」URI のための HTTP/2 の開始</a>
                                </li>
                                <li><a href="#rfc.section.3.3">3.3.</a>&nbsp;&nbsp;&nbsp;<a href="#known-http">事前知識による
                                        HTTP/2 の開始</a></li>
                                <li><a href="#rfc.section.3.4">3.4.</a>&nbsp;&nbsp;&nbsp;<a href="#preface">HTTP/2
                                        接続序文</a></li>
                            </ul>
                        </li>
                        <li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#FramingLayer">HTTP フレーム</a>
                            <ul>
                                <li><a href="#rfc.section.4.1">4.1.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#FrameHeader">フレーム形式</a></li>
                                <li><a href="#rfc.section.4.2">4.2.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#FrameSize">フレームサイズ</a></li>
                                <li><a href="#rfc.section.4.3">4.3.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#FieldBlock">フィールドセクションの圧縮と解凍</a>
                                    <ul>
                                        <li><a href="#rfc.section.4.3.1">4.3.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#dynamic-table">圧縮状態</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#StreamsLayer">ストリームと
                                多重化</a>
                            <ul>
                                <li><a href="#rfc.section.5.1">5.1.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#StreamStates">ストリームの状態</a>
                                    <ul>
                                        <li><a href="#rfc.section.5.1.1">5.1.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#StreamIdentifiers">ストリーム識別子</a></li>
                                        <li><a href="#rfc.section.5.1.2">5.1.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#rfc.section.5.1.2">ストリームの同時実行</a></li>
                                    </ul>
                                </li>
                                <li><a href="#rfc.section.5.2">5.2.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#FlowControl">フロー制御</a>
                                    <ul>
                                        <li><a href="#rfc.section.5.2.1">5.2.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#fc-principles">フロー制御の原則</a></li>
                                        <li><a href="#rfc.section.5.2.2">5.2.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#DisableFlowControl">フロー制御の適切な使用</a>
                                        </li>
                                        <li><a href="#rfc.section.5.2.3">5.2.3.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#FlowControlPerformance">フロー制御の性能</a></li>
                                    </ul>
                                </li>
                                <li><a href="#rfc.section.5.3">5.3.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#StreamPriority">優先度付け</a>
                                    <ul>
                                        <li><a href="#rfc.section.5.3.1">5.3.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#PriorityHistory">RFC 7540 における優先度の背景</a>
                                        </li>
                                        <li><a href="#rfc.section.5.3.2">5.3.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#PriorityHere">本書における優先度シグナリング</a>
                                        </li>
                                    </ul>
                                </li>
                                <li><a href="#rfc.section.5.4">5.4.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#ErrorHandler">エラー処理</a>
                                    <ul>
                                        <li><a href="#rfc.section.5.4.1">5.4.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#ConnectionErrorHandler">接続エラー処理</a></li>
                                        <li><a href="#rfc.section.5.4.2">5.4.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#StreamErrorHandler">ストリームエラー処理</a></li>
                                        <li><a href="#rfc.section.5.4.3">5.4.3.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#rfc.section.5.4.3">接続の終了</a></li>
                                    </ul>
                                </li>
                                <li><a href="#rfc.section.5.5">5.5.</a>&nbsp;&nbsp;&nbsp;<a href="#extensibility">HTTP/2
                                        の拡張</a></li>
                            </ul>
                        </li>
                        <li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#FrameTypes">フレーム
                                定義</a>
                            <ul>
                                <li><a href="#rfc.section.6.1">6.1.</a>&nbsp;&nbsp;&nbsp;<a href="#DATA">DATA</a></li>
                                <li><a href="#rfc.section.6.2">6.2.</a>&nbsp;&nbsp;&nbsp;<a href="#HEADERS">HEADERS</a>
                                </li>
                                <li><a href="#rfc.section.6.3">6.3.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#PRIORITY">PRIORITY</a></li>
                                <li><a href="#rfc.section.6.4">6.4.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#RST_STREAM">RST_STREAM</a></li>
                                <li><a href="#rfc.section.6.5">6.5.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#SETTINGS">SETTINGS</a>
                                    <ul>
                                        <li><a href="#rfc.section.6.5.1">6.5.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#SettingFormat">SETTINGS の形式</a></li>
                                        <li><a href="#rfc.section.6.5.2">6.5.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#SettingValues">SETTINGS の定義</a></li>
                                        <li><a href="#rfc.section.6.5.3">6.5.3.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#SettingsSync">設定の同期</a></li>
                                    </ul>
                                </li>
                                <li><a href="#rfc.section.6.6">6.6.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#PUSH_PROMISE">PUSH_PROMISE</a></li>
                                <li><a href="#rfc.section.6.7">6.7.</a>&nbsp;&nbsp;&nbsp;<a href="#PING">PING</a></li>
                                <li><a href="#rfc.section.6.8">6.8.</a>&nbsp;&nbsp;&nbsp;<a href="#GOAWAY">GOAWAY</a>
                                </li>
                                <li><a href="#rfc.section.6.9">6.9.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#WINDOW_UPDATE">WINDOW_UPDATE</a>
                                    <ul>
                                        <li><a href="#rfc.section.6.9.1">6.9.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#rfc.section.6.9.1">フロー制御ウィンドウ</a></li>
                                        <li><a href="#rfc.section.6.9.2">6.9.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#InitialWindowSize">初期フロー制御ウィンドウサイズ</a></li>
                                        <li><a href="#rfc.section.6.9.3">6.9.3.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#rfc.section.6.9.3">ストリームウィンドウサイズの縮小</a></li>
                                    </ul>
                                </li>
                                <li><a href="#rfc.section.6.10">6.10.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#CONTINUATION">CONTINUATION</a></li>
                            </ul>
                        </li>
                        <li><a href="#rfc.section.7">7.</a>&nbsp;&nbsp;&nbsp;<a href="#ErrorCodes">エラーコード</a></li>
                        <li><a href="#rfc.section.8">8.</a>&nbsp;&nbsp;&nbsp;<a href="#HttpLayer">HTTP/2
                                における HTTP セマンティクスの表現</a>
                            <ul>
                                <li><a href="#rfc.section.8.1">8.1.</a>&nbsp;&nbsp;&nbsp;<a href="#HttpFraming">HTTP
                                        メッセージのフレーミング</a>
                                    <ul>
                                        <li><a href="#rfc.section.8.1.1">8.1.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#malformed">不正なメッセージ</a></li>
                                    </ul>
                                </li>
                                <li><a href="#rfc.section.8.2">8.2.</a>&nbsp;&nbsp;&nbsp;<a href="#HttpHeaders">HTTP
                                        フィールド</a>
                                    <ul>
                                        <li><a href="#rfc.section.8.2.1">8.2.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#rfc.section.8.2.1">フィールドの妥当性</a></li>
                                        <li><a href="#rfc.section.8.2.2">8.2.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#ConnectionSpecific">接続固有のヘッダーフィールド</a></li>
                                        <li><a href="#rfc.section.8.2.3">8.2.3.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#CompressCookie">Cookie ヘッダーフィールドの圧縮</a></li>
                                    </ul>
                                </li>
                                <li><a href="#rfc.section.8.3">8.3.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#PseudoHeaderFields">HTTP 制御データ</a>
                                    <ul>
                                        <li><a href="#rfc.section.8.3.1">8.3.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#HttpRequest">リクエスト擬似ヘッダーフィールド</a></li>
                                        <li><a href="#rfc.section.8.3.2">8.3.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#HttpResponse">レスポンス擬似ヘッダーフィールド</a></li>
                                    </ul>
                                </li>
                                <li><a href="#rfc.section.8.4">8.4.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#PushResources">サーバープッシュ</a>
                                    <ul>
                                        <li><a href="#rfc.section.8.4.1">8.4.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#PushRequests">プッシュリクエスト</a></li>
                                        <li><a href="#rfc.section.8.4.2">8.4.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#PushResponses">プッシュレスポンス</a></li>
                                    </ul>
                                </li>
                                <li><a href="#rfc.section.8.5">8.5.</a>&nbsp;&nbsp;&nbsp;<a href="#CONNECT">CONNECT
                                        メソッド</a></li>
                                <li><a href="#rfc.section.8.6">8.6.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#informational-responses">Upgrade ヘッダーフィールド</a></li>
                                <li><a href="#rfc.section.8.7">8.7.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#Reliability">リクエストの信頼性</a></li>
                                <li><a href="#rfc.section.8.8">8.8.</a>&nbsp;&nbsp;&nbsp;<a href="#HttpExamples">例</a>
                                    <ul>
                                        <li><a href="#rfc.section.8.8.1">8.8.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#rfc.section.8.8.1">単純なリクエスト</a></li>
                                        <li><a href="#rfc.section.8.8.2">8.8.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#rfc.section.8.8.2">単純なレスポンス</a></li>
                                        <li><a href="#rfc.section.8.8.3">8.8.3.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#rfc.section.8.8.3">複雑なリクエスト</a></li>
                                        <li><a href="#rfc.section.8.8.4">8.8.4.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#rfc.section.8.8.4">本文付きレスポンス</a></li>
                                        <li><a href="#rfc.section.8.8.5">8.8.5.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#rfc.section.8.8.5">情報レスポンス</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li><a href="#rfc.section.9">9.</a>&nbsp;&nbsp;&nbsp;<a href="#HttpExtra">HTTP/2 接続</a>
                            <ul>
                                <li><a href="#rfc.section.9.1">9.1.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#rfc.section.9.1">接続管理</a>
                                    <ul>
                                        <li><a href="#rfc.section.9.1.1">9.1.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#reuse">接続の再利用</a></li>
                                    </ul>
                                </li>
                                <li><a href="#rfc.section.9.2">9.2.</a>&nbsp;&nbsp;&nbsp;<a href="#TLSUsage">TLS
                                        機能の使用</a>
                                    <ul>
                                        <li><a href="#rfc.section.9.2.1">9.2.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#tls12features">TLS 1.2 の機能</a></li>
                                        <li><a href="#rfc.section.9.2.2">9.2.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#tls12ciphers">TLS 1.2 の暗号スイート</a></li>
                                        <li><a href="#rfc.section.9.2.3">9.2.3.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#tls13features">TLS 1.3 の機能</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li><a href="#rfc.section.10">10.</a>&nbsp;&nbsp;&nbsp;<a href="#security">セキュリティに関する考慮事項</a>
                            <ul>
                                <li><a href="#rfc.section.10.1">10.1.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#authority">サーバーの権限</a></li>
                                <li><a href="#rfc.section.10.2">10.2.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#rfc.section.10.2">クロスプロトコル攻撃</a></li>
                                <li><a href="#rfc.section.10.3">10.3.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#rfc.section.10.3">仲介者カプセル化攻撃</a></li>
                                <li><a href="#rfc.section.10.4">10.4.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#rfc.section.10.4">プッシュされたレスポンスのキャッシュ可能性</a></li>
                                <li><a href="#rfc.section.10.5">10.5.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#dos">サービス拒否（DoS）に関する考慮事項</a>
                                    <ul>
                                        <li><a href="#rfc.section.10.5.1">10.5.1.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#MaxFieldBlock">フィールドブロックサイズの制限</a></li>
                                        <li><a href="#rfc.section.10.5.2">10.5.2.</a>&nbsp;&nbsp;&nbsp;<a
                                                href="#connectDos">CONNECT の問題</a></li>
                                    </ul>
                                </li>
                                <li><a href="#rfc.section.10.6">10.6.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#rfc.section.10.6">圧縮の使用</a></li>
                                <li><a href="#rfc.section.10.7">10.7.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#padding">パディングの使用</a></li>
                                <li><a href="#rfc.section.10.8">10.8.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#rfc.section.10.8">プライバシーに関する考慮事項</a></li>
                                <li><a href="#rfc.section.10.9">10.9.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#rfc.section.10.9">リモートタイミング攻撃</a></li>
                            </ul>
                        </li>
                        <li><a href="#rfc.section.11">11.</a>&nbsp;&nbsp;&nbsp;<a href="#iana">IANA に関する考慮事項</a>
                            <ul>
                                <li><a href="#rfc.section.11.1">11.1.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#HTTP2-Settings">HTTP2-Settings ヘッダーフィールド登録</a></li>
                                <li><a href="#rfc.section.11.2">11.2.</a>&nbsp;&nbsp;&nbsp;<a href="#iana-h2c">h2c
                                        アップグレードトークン</a></li>
                            </ul>
                        </li>
                        <li><a href="#rfc.section.12">12.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">参考文献</a>
                            <ul>
                                <li><a href="#rfc.section.12.1">12.1.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#rfc.references.2">規範的参考文献</a></li>
                                <li><a href="#rfc.section.12.2">12.2.</a>&nbsp;&nbsp;&nbsp;<a
                                        href="#rfc.references.3">情報参考文献</a></li>
                            </ul>
                        </li>
                        <li><a href="#rfc.section.A">Appendix A.</a>&nbsp;&nbsp;&nbsp;<a href="#BadCipherSuites">付録 A.
                                禁止された TLS 1.2 暗号スイート</a></li>
                        <li><a href="#rfc.section.B">Appendix B.</a>&nbsp;&nbsp;&nbsp;<a href="#revision-updates">付録 B.
                                RFC 7540 からの変更</a></li>
                        <li><a href="#rfc.section.unnumbered-4">Acknowledgments</a></li>
                        <li><a href="#rfc.section.unnumbered-5">Contributors</a></li>
                        <li><a href="#rfc.authors">Authors' Addresses</a></li>
                    </ul>
                </div>
                <hr class="hidden-print">
                <section id="intro">
                    <h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a href="#intro">はじめに</a>
                    </h2>
                    <div id="rfc.section.1.p.1">
                        <p>ハイパーテキスト転送プロトコル（HTTP、<a href="#RFC9110"><cite
                                    title="HTTP Semantics">[HTTP]</cite></a>）を使用するアプリケーションの性能は、各 HTTP
                            バージョンが基盤となるトランスポートをどのように利用するか、およびトランスポートがどのような条件下で動作するかに依存します。</p>
                    </div>
                    <div id="rfc.section.1.p.2">
                        <p>複数の同時リクエストを行うことで遅延を低減し、アプリケーションの性能を改善できます。HTTP/1.0 は特定の TCP <a href="#RFC0793"><cite
                                    title="Transmission Control Protocol">[TCP]</cite></a> 接続に対して同時に処理できるリクエストを 1
                            件にしか許可していませんでした。HTTP/1.1 <a href="#RFC9112"><cite title="HTTP/1.1">[HTTP/1.1]</cite></a>
                            はリクエストのパイプライン化を追加しましたが、これはリクエストの並列性を部分的にしか解決せず、アプリケーション層のヘッド・オブ・ライン（head-of-line）ブロッキングの影響を受け続けます。そのため、HTTP/1.0
                            および HTTP/1.1 のクライアントは並列リクエストを行うためにサーバーへの複数の接続を使用します。</p>
                    </div>
                    <div id="rfc.section.1.p.3">
                        <p>さらに、HTTP フィールドはしばしば冗長で冗長な記述が多く、不要なネットワークトラフィックを引き起こすとともに、初期の TCP
                            混雑ウィンドウを急速に満たしてしまいます。これにより、新しい
                            TCP 接続で複数のリクエストが行われると過度の遅延が発生することがあります。</p>
                    </div>
                    <div id="rfc.section.1.p.4">
                        <p>HTTP/2 は、HTTP のセマンティクスを基盤接続に最適にマッピングすることでこれらの問題に対処します。具体的には、同一接続上でメッセージのインターリービングを可能にし、HTTP
                            フィールドに対して効率的なエンコーディングを使用します。またリクエストの優先付けを可能にし、重要度の高いリクエストをより早く完了させることで性能をさらに改善します。</p>
                    </div>
                    <div id="rfc.section.1.p.5">
                        <p>結果として、このプロトコルは HTTP/1.x と比較して TCP
                            接続の数を減らすことができるため、ネットワークに優しくなります。これは他のフローとの競合が減り、接続の寿命が長くなることで利用可能なネットワーク容量のより良い活用につながります。ただし、このプロトコルは
                            TCP のヘッド・オブ・ラインブロッキング自体を解決するものではない点に注意してください。</p>
                    </div>
                    <div id="rfc.section.1.p.6">
                        <p>最後に、HTTP/2 はバイナリメッセージフレーミングを使用することでメッセージ処理の効率化も可能にします。</p>
                    </div>
                    <div id="rfc.section.1.p.7">
                        <p>この文書は RFCs 7540 および 8740 を廃止します。<a href="#revision-updates" title="Changes from RFC 7540">付録
                                B</a> には顕著な変更点が挙げられています。</p>
                    </div>
                </section>
                <hr class="hidden-print">
                <section id="Overview">
                    <h2 id="rfc.section.2" class="np"><a href="#rfc.section.2">2.</a>&nbsp;<a href="#Overview">HTTP/2
                            プロトコル概要</a></h2>
                    <div id="rfc.section.2.p.1">
                        <p>HTTP/2 は HTTP セマンティクスのための最適化されたトランスポートを提供します。HTTP/2 は HTTP の全てのコア機能をサポートしますが、HTTP/1.1
                            よりも効率的であることを目指しています。</p>
                    </div>
                    <div id="rfc.section.2.p.2">
                        <p>HTTP/2 は TCP 接続（<a href="#RFC0793"><cite
                                    title="Transmission Control Protocol">[TCP]</cite></a>）上で動作する接続指向のアプリケーション層プロトコルです。クライアントは
                            TCP 接続の開始者です。</p>
                    </div>
                    <div id="rfc.section.2.p.3">
                        <p>HTTP/2 における基本的なプロトコル単位はフレームです（<a href="#FrameHeader" title="Frame Format">セクション
                                4.1</a>）。各フレームタイプは異なる目的を持ちます。例えば、<a href="#HEADERS" title="HEADERS">HEADERS</a> フレームと <a
                                href="#DATA" title="DATA">DATA</a> フレームは HTTP リクエストおよびレスポンスの基礎を形成します（<a
                                href="#HttpFraming" title="HTTP Message Framing">セクション 8.1</a>）。その他のフレームタイプとしては、<a
                                href="#SETTINGS" title="SETTINGS">SETTINGS</a>、<a href="#WINDOW_UPDATE"
                                title="WINDOW_UPDATE">WINDOW_UPDATE</a>、および <a href="#PUSH_PROMISE"
                                title="PUSH_PROMISE">PUSH_PROMISE</a> などがあり、これらは他の HTTP/2 機能を支援するために使用されます。</p>
                    </div>
                    <div id="rfc.section.2.p.4">
                        <p>リクエストの多重化は、各 HTTP リクエスト／レスポンス交換をそれぞれ固有のストリームに関連付けることで実現されます（<a href="#StreamsLayer"
                                title="Streams and Multiplexing">セクション
                                5</a>）。ストリームは互いに大部分で独立しているため、あるリクエストやレスポンスがブロックまたは停滞しても他のストリームの進行を妨げません。</p>
                    </div>
                    <div id="rfc.section.2.p.5">
                        <p>多重化を効果的に利用するにはフロー制御と優先付けが重要です。フロー制御（<a href="#FlowControl" title="Flow Control">セクション
                                5.2</a>）は、受信側が処理可能な範囲に送信データを制限することで多重化されたストリームを効率的に利用可能にします。優先付け（<a
                                href="#StreamPriority" title="Prioritization">セクション
                                5.3</a>）は、限られた資源が最も効果的に使われるようにします。本改訂では、<a href="#RFC7540"><cite
                                    title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>
                            の優先度シグナリング方式は非推奨となっています。</p>
                    </div>
                    <div id="rfc.section.2.p.6">
                        <p>接続で使用される HTTP フィールドは冗長なデータを多く含むことがあるため、それらを含むフレームは圧縮されます（<a href="#FieldBlock"
                                title="Field Section Compression and Decompression">セクション
                                4.3</a>）。これは共通ケースにおけるリクエストサイズに特に有利に働き、多くのリクエストを 1 パケットに圧縮できるようにします。</p>
                    </div>
                    <div id="rfc.section.2.p.7">
                        <p>最後に、HTTP/2 はサーバーがクライアントへレスポンスをプッシュできる新しい（任意の）相互作用モードを追加します（<a href="#PushResources"
                                title="Server Push">セクション
                                8.4</a>）。これはサーバーがクライアントが必要とするだろうと推測するデータを投機的に送信することで、ネットワーク使用量を多少増やす代わりに遅延を低減することを意図しています。サーバーは合成リクエストを生成し、それを
                            <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a>
                            フレームとして送信することでこれを行います。その後、サーバーは別のストリーム上で合成リクエストに対するレスポンスを送信できます。
                        </p>
                    </div>
                    <section id="n-document-organization">
                        <h3 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a>&nbsp;<a
                                href="#n-document-organization">文書の構成</a></h3>
                        <div id="rfc.section.2.1.p.1" class="avoidbreakafter">
                            <p>HTTP/2 仕様は 4 つの部分に分かれています：</p>
                        </div>
                        <div id="rfc.section.2.1.p.2">
                            <ul>
                                <li>Starting HTTP/2（<a href="#starting" title="Starting HTTP/2">セクション 3</a>）は HTTP/2
                                    接続の開始方法を扱います。</li>
                                <li>フレーム層（<a href="#FramingLayer" title="HTTP Frames">セクション 4</a>）とストリーム層（<a
                                        href="#StreamsLayer" title="Streams and Multiplexing">セクション 5</a>）は、HTTP/2
                                    フレームがどのように構造化され、多重化されたストリームに形成されるかを記述します。</li>
                                <li>フレーム（<a href="#FrameTypes" title="Frame Definitions">セクション 6</a>）およびエラー（<a
                                        href="#ErrorCodes" title="Error Codes">セクション 7</a>）の定義は、HTTP/2
                                    で使用されるフレームとエラータイプの詳細を含みます。</li>
                                <li>HTTP マッピング（<a href="#HttpLayer" title="Expressing HTTP Semantics in HTTP/2">セクション
                                        8</a>）および追加要件（<a href="#HttpExtra" title="HTTP/2 Connections">セクション
                                        9</a>）は、フレームとストリームを用いて HTTP セマンティクスがどのように表現されるかを説明します。</li>
                            </ul>
                        </div>
                        <div id="rfc.section.2.1.p.3">
                            <p>フレーム層およびストリーム層の概念の一部は HTTP から独立しているものの、本仕様は完全に一般的なフレーム層を定義するものではありません。フレーム層とストリーム層は HTTP
                                のニーズに合わせて調整されています。</p>
                        </div>
                    </section>
                    <section id="n-conventions-and-terminology">
                        <h3 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a>&nbsp;<a
                                href="#n-conventions-and-terminology">慣例と用語</a></h3>
                        <div id="rfc.section.2.2.p.1">
                            <p>本書中のキーワード "<em class="bcp14">MUST</em>", "<em class="bcp14">MUST NOT</em>", "<em
                                    class="bcp14">REQUIRED</em>", "<em class="bcp14">SHALL</em>", "<em
                                    class="bcp14">SHALL
                                    NOT</em>", "<em class="bcp14">SHOULD</em>", "<em class="bcp14">SHOULD NOT</em>",
                                "<em class="bcp14">RECOMMENDED</em>", "<em class="bcp14">NOT RECOMMENDED</em>", "<em
                                    class="bcp14">MAY</em>", および "<em class="bcp14">OPTIONAL</em>"
                                は、すべて大文字で表示されている場合に限り、<span class="nobr">BCP 14</span>（<a href="#RFC2119"><cite
                                        title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>）および
                                <a href="#RFC8174"><cite
                                        title="Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words">[RFC8174]</cite></a>
                                に記載されているとおりに解釈されます。
                            </p>
                        </div>
                        <div id="rfc.section.2.2.p.2">
                            <p>すべての数値はネットワークバイトオーダーです。値は特に示されない限り符号なしです。リテラル値は適切に 10 進または 16 進で示されます。16 進リテラルは 10
                                進リテラルと区別するために "<span class="tt">0x</span>" プレフィックスが付されます。</p>
                        </div>
                        <div id="rfc.section.2.2.p.3">
                            <p>本仕様はバイナリ形式を RFC 9000 の <a
                                    href="https://www.rfc-editor.org/rfc/rfc9000.html#section-1.3">セクション 1.3</a>
                                に記載された慣例で記述します。<a href="#RFC9000"><cite
                                        title="QUIC: A UDP-Based Multiplexed and Secure Transport">RFC
                                        9000</cite></a>（<cite
                                    title="QUIC: A UDP-Based Multiplexed and Secure Transport">[QUIC]</cite>）を参照してください。この形式はネットワークバイトオーダーを使用し、高位ビットが低位ビットより前に列挙されることに注意してください。
                            </p>
                        </div>
                        <div id="rfc.section.2.2.p.4" class="avoidbreakafter">
                            <p>以下の用語が使用されます：</p>
                        </div>
                        <div id="rfc.section.2.2.p.5">
                            <dl>
                                <dt>client:</dt>
                                <dd style="margin-left: 1.5em">HTTP/2 接続を開始するエンドポイント。クライアントは HTTP リクエストを送信し、HTTP
                                    レスポンスを受信します。</dd>
                                <dt>connection:</dt>
                                <dd style="margin-left: 1.5em">二つのエンドポイント間のトランスポート層の接続。</dd>
                                <dt>connection error:</dt>
                                <dd style="margin-left: 1.5em">HTTP/2 接続全体に影響するエラー。</dd>
                                <dt>endpoint:</dt>
                                <dd style="margin-left: 1.5em">接続のクライアントまたはサーバーのいずれか。</dd>
                                <dt>frame:</dt>
                                <dd style="margin-left: 1.5em">ヘッダとフレームタイプに従って構造化された可変長のオクテット列から成る、HTTP/2 接続内の最小の通信単位。
                                </dd>
                                <dt>peer:</dt>
                                <dd style="margin-left: 1.5em">
                                    エンドポイント。特定のエンドポイントについて議論する際、「peer」は主要な議論対象から見てリモートなエンドポイントを指します。</dd>
                                <dt>receiver:</dt>
                                <dd style="margin-left: 1.5em">フレームを受信しているエンドポイント。</dd>
                                <dt>sender:</dt>
                                <dd style="margin-left: 1.5em">フレームを送信しているエンドポイント。</dd>
                                <dt>server:</dt>
                                <dd style="margin-left: 1.5em">HTTP/2 接続を受け入れるエンドポイント。サーバーは HTTP リクエストを受信し、HTTP
                                    レスポンスを送信します。
                                </dd>
                                <dt>stream:</dt>
                                <dd style="margin-left: 1.5em">HTTP/2 接続内の双方向のフレームの流れ。</dd>
                                <dt>stream error:</dt>
                                <dd style="margin-left: 1.5em">個々の HTTP/2 ストリーム上のエラー。</dd>
                            </dl>
                        </div>
                        <div id="rfc.section.2.2.p.6">
                            <p>最後に、「gateway」、「intermediary」、「proxy」、および「tunnel」という用語は <a
                                    href="https://www.rfc-editor.org/rfc/rfc9110.html#section-3.7">RFC 9110 のセクション
                                    3.7</a>
                                に定義されています。インターミディアリは異なる時点でクライアントおよびサーバーとして振る舞います。</p>
                        </div>
                        <div id="rfc.section.2.2.p.7">
                            <p>メッセージ本文に適用される「content」という用語は <a
                                    href="https://www.rfc-editor.org/rfc/rfc9110.html#section-6.4">RFC 9110 のセクション
                                    6.4</a>
                                に定義されています。</p>
                        </div>
                    </section>
                </section>
                <hr class="hidden-print">
                <section id="starting">
                    <h2 id="rfc.section.3" class="np"><a href="#rfc.section.3">3.</a>&nbsp;<a href="#starting">HTTP/2
                            の開始</a></h2>
                    <div id="rfc.section.3.p.1">
                        <p>HTTP リクエストを生成する実装は、サーバーが HTTP/2 をサポートしているかどうかを検出する必要があります。</p>
                    </div>
                    <div id="rfc.section.3.p.2">
                        <p>HTTP/2 は <span class="tt">http</span> および <span class="tt">https</span> URI スキーム（RFC 9110 の
                            <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-4.2">セクション 4.2</a>
                            で定義）を使用し、デフォルトのポート番号は HTTP/1.1 と同じです（<a href="#RFC9112"><cite
                                    title="HTTP/1.1">[HTTP/1.1]</cite></a>）。これらの URI
                            は、上流のサーバー（クライアントが接続を確立しようとする直近のピア）がサポートする HTTP バージョンについての情報を含みません。
                        </p>
                    </div>
                    <div id="rfc.section.3.p.3">
                        <p>HTTP/2 のサポートを判定する手段は <span class="tt">http</span> と <span class="tt">https</span> の URI
                            ごとに異なります。<span class="tt">https</span> URI の検出は <a href="#discover-https"
                                title="Starting HTTP/2 for &#34;https&#34; URIs">セクション 3.2</a> に記述されています。<span
                                class="tt">http</span> URI に対する HTTP/2 のサポートはアウトオブバンドな手段でのみ発見可能であり、事前知識に基づくサポートが必要です（<a
                                href="#known-http" title="Starting HTTP/2 with Prior Knowledge">セクション 3.3</a> を参照）。</p>
                    </div>
                    <section id="versioning">
                        <h3 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a>&nbsp;<a href="#versioning">HTTP/2
                                バージョン識別</a></h3>
                        <div id="rfc.section.3.1.p.1">
                            <p>本書で定義されたプロトコルには二つの識別子があります。いずれかに基づいて接続を作成することは、本書で記述されたトランスポート、フレーミング、およびメッセージのセマンティクスの使用を意味します。
                            </p>
                        </div>
                        <div id="rfc.section.3.1.p.2">
                            <ul>
                                <li>
                                    <div>
                                        <p>文字列 "h2" は HTTP/2 がトランスポート層セキュリティ（TLS）を使用するプロトコルを識別します（<a href="#TLSUsage"
                                                title="Use of TLS Features">セクション 9.2</a> を参照）。この識別子は TLS の ALPN
                                            フィールドや、HTTP/2 over TLS が識別されるあらゆる場所で使用されます（<a href="#RFC7301"><cite
                                                    title="Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension">TLS-ALPN</cite></a>）。
                                        </p>
                                    </div>
                                    <div>
                                        <p>"h2" 文字列は ALPN プロトコル識別子として 2 バイト列 0x68, 0x32 としてシリアライズされます。</p>
                                    </div>
                                </li>
                                <li>
                                    <div>
                                        <p>文字列 "h2c" は以前 HTTP Upgrade メカニズムの Upgrade ヘッダーフィールドで使用されていました（RFC 9110 の <a
                                                href="https://www.rfc-editor.org/rfc/rfc9110.html#section-7.8">セクション
                                                7.8</a>）。この使用法は広く展開されることはなく、本書で非推奨とされています。HTTP2-Settings ヘッダーフィールドも
                                            "h2c"
                                            へのアップグレードで使用されましたが、同様に非推奨です。</p>
                                    </div>
                                </li>
                            </ul>
                        </div>
                    </section>
                    <section id="discover-https">
                        <h3 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a>&nbsp;<a
                                href="#discover-https">"<span class="tt">https</span>" URI のための HTTP/2 の開始</a></h3>
                        <div id="rfc.section.3.2.p.1">
                            <p><span class="tt">https</span> URI へのリクエストを行うクライアントは、<a href="#RFC8446"><cite
                                        title="The Transport Layer Security (TLS) Protocol Version 1.3">TLS</cite></a>（<cite
                                    title="The Transport Layer Security (TLS) Protocol Version 1.3">[TLS13]</cite>）を
                                ALPN
                                拡張（<a href="#RFC7301"><cite
                                        title="Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension">[TLS-ALPN]</cite></a>）と共に使用します。
                            </p>
                        </div>
                        <div id="rfc.section.3.2.p.2">
                            <p>TLS 上の HTTP/2 は "h2" プロトコル識別子を使用します。クライアントが "h2c" を送信したりサーバーがそれを選択したりしてはならず（<em
                                    class="bcp14">MUST NOT</em>）、"h2c" は TLS を使用しないプロトコルを記述する識別子です。</p>
                        </div>
                        <div id="rfc.section.3.2.p.3">
                            <p>TLS ネゴシエーションが完了したら、クライアントとサーバーの両方が接続序文（<a href="#preface"
                                    title="HTTP/2 Connection Preface">セクション 3.4</a>）を送信する必要があります（<em
                                    class="bcp14">MUST</em>）。</p>
                        </div>
                    </section>
                    <section id="known-http">
                        <h3 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a>&nbsp;<a href="#known-http">事前知識による
                                HTTP/2 の開始</a></h3>
                        <div id="rfc.section.3.3.p.1">
                            <p>クライアントは他の手段で特定のサーバーが HTTP/2 をサポートしていることを知ることができます。例えば、クライアントがサーバーが HTTP/2
                                をサポートすると設定されている場合があります。</p>
                        </div>
                        <div id="rfc.section.3.3.p.2">
                            <p>サーバーが HTTP/2 をサポートするとクライアントが知っている場合、クライアントは TCP 接続を確立して接続序文（<a href="#preface"
                                    title="HTTP/2 Connection Preface">セクション 3.4</a>）を送信し、その後に HTTP/2
                                フレームを送信できます。サーバーは接続序文の存在によってこれらの接続を識別できます。これは平文 TCP 上での HTTP/2 接続の確立にのみ影響し、TLS 上の HTTP/2
                                接続は
                                <a href="#RFC7301"><cite
                                        title="Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension">TLS
                                        におけるプロトコルネゴシエーション</cite></a>（[TLS-ALPN]）を使用しなければなりません（<em
                                    class="bcp14">MUST</em>）。
                            </p>
                        </div>
                        <div id="rfc.section.3.3.p.3">
                            <p>同様に、サーバーは接続序文（<a href="#preface" title="HTTP/2 Connection Preface">セクション
                                    3.4</a>）を送信しなければなりません（<em class="bcp14">MUST</em>）。</p>
                        </div>
                        <div id="rfc.section.3.3.p.4">
                            <p>追加情報がない限り、過去に HTTP/2 をサポートしていたという事実は将来の接続で必ずしも同じサーバーが HTTP/2
                                をサポートする強いシグナルとはなりません。例えば、サーバー構成が変更される可能性や、クラスタ化されたサーバー間で構成が異なる可能性、ネットワーク条件が変化する可能性があります。
                            </p>
                        </div>
                    </section>
                    <section id="preface">
                        <h3 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4.</a>&nbsp;<a href="#preface">HTTP/2
                                接続序文</a>
                        </h3>
                        <div id="rfc.section.3.4.p.1">
                            <p>HTTP/2 では、各エンドポイントは使用プロトコルの最終確認としておよび HTTP/2
                                接続の初期設定を確立するために接続序文を送信することが要求されます。クライアントとサーバーはそれぞれ異なる接続序文を送信します。</p>
                        </div>
                        <div id="rfc.section.3.4.p.2" class="avoidbreakafter">
                            <p>クライアント接続序文は 24 オクテットのシーケンスで始まり、16 進表記では次のとおりです：</p>
                        </div>
                        <div id="rfc.section.3.4.p.3">
                            <pre class="inline">
  0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a
</pre>
                        </div>
                        <div id="rfc.section.3.4.p.4">
                            <p>すなわち接続序文は文字列 "<span class="tt">PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n</span>" で始まります。このシーケンスは
                                <a href="#SETTINGS" title="SETTINGS">SETTINGS</a> フレーム（<a href="#SETTINGS"
                                    title="SETTINGS">セクション 6.5</a>）に続かなければならず（<em class="bcp14">MUST</em>）、その SETTINGS
                                フレームは空であっても構いません（<em
                                    class="bcp14">MAY</em>）。クライアントはクライアント接続序文を接続の最初のアプリケーションデータオクテットとして送信します。
                            </p>
                        </div>
                        <div id="rfc.section.3.4.p.5">
                            <aside>
                                <div id="rfc.section.3.4.p.5.1">
                                    <p>注：クライアント接続序文は、多くの HTTP/1.1 または HTTP/1.0
                                        のサーバーやインターミディアリがこれ以上のフレームを処理しようとしないように選ばれています。これは <a href="#TALKING"><cite
                                                title="Talking to Yourself for Fun and Profit">[TALKING]</cite></a>
                                        で提起された懸念を解決するものではない点に注意してください。</p>
                                </div>
                            </aside>
                        </div>
                        <div id="rfc.section.3.4.p.6">
                            <p>サーバー接続序文は、最初にサーバーが送信するフレームでなければならない可能性のある空であり得る <a href="#SETTINGS"
                                    title="SETTINGS">SETTINGS</a> フレーム（セクション 6.5）で構成されます（<em class="bcp14">MUST</em>）。
                            </p>
                        </div>
                        <div id="rfc.section.3.4.p.7">
                            <p>接続序文の一部としてピアから受信した <a href="#SETTINGS" title="SETTINGS">SETTINGS</a>
                                フレームは、接続序文を送信した後に確認（acknowledge）されなければなりません（<a href="#SettingsSync"
                                    title="Settings Synchronization">セクション 6.5.3</a> を参照）（<em class="bcp14">MUST</em>）。
                            </p>
                        </div>
                        <div id="rfc.section.3.4.p.8">
                            <p>不必要な遅延を避けるため、クライアントはサーバー接続序文を受信するのを待たずにクライアント接続序文送信直後に追加のフレームをサーバーへ送信することが許可されています。ただし、サーバー接続序文の
                                <a href="#SETTINGS" title="SETTINGS">SETTINGS</a>
                                フレームにはクライアントがサーバーと通信する方法を変更する設定が含まれる可能性があることに注意することが重要です。クライアントは <a href="#SETTINGS"
                                    title="SETTINGS">SETTINGS</a>
                                フレームを受信したら、確立された設定を尊重することが期待されます。いくつかの構成では、サーバーがクライアントが追加フレームを送信する前に <a href="#SETTINGS"
                                    title="SETTINGS">SETTINGS</a> を送信することでこの問題を避けられることがあります。
                            </p>
                        </div>
                        <div id="rfc.section.3.4.p.9">
                            <p>クライアントとサーバーは、不正な接続序文を接続エラー（<a href="#ConnectionErrorHandler"
                                    title="Connection Error Handling">セクション 5.4.1</a>）として扱わなければなりません（<em
                                    class="bcp14">MUST</em>）。この場合、接続序文が無効であることはピアが HTTP/2 を使用していないことを示すため、<a
                                    href="#GOAWAY" title="GOAWAY">GOAWAY</a> フレーム（<a href="#GOAWAY" title="GOAWAY">セクション
                                    6.8</a>）は省略されることがあります（<em class="bcp14">MAY</em>）。</p>
                        </div>
                    </section>
                </section>
                <hr class="hidden-print">
                <section id="FramingLayer">
                    <h2 id="rfc.section.4" class="np"><a href="#rfc.section.4">4.</a>&nbsp;<a href="#FramingLayer">HTTP
                            フレーム</a></h2>
                    <div id="rfc.section.4.p.1">
                        <p>HTTP/2 接続が確立されると、エンドポイントはフレームの交換を開始できます。</p>
                    </div>
                    <section id="FrameHeader">
                        <h3 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a>&nbsp;<a
                                href="#FrameHeader">フレーム形式</a>
                        </h3>
                        <div id="rfc.section.4.1.p.1">
                            <p>すべてのフレームは固定長の 9 オクテットヘッダで始まり、その後に可変長のフレームペイロードが続きます。</p>
                        </div>
                        <div id="FrameLayout"></div>
                        <div id="rfc.figure.1">
                            <div>
                                <pre class="inline">
HTTP Frame {
  Length (24),
  Type (8),

  Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Frame Payload (..),
}
</pre>
                            </div>
                        </div>
                        <p class="figure">図 1: フレームレイアウト</p>
                        <div id="rfc.section.4.1.p.2" class="avoidbreakafter">
                            <p>フレームヘッダのフィールドは次のように定義されます：</p>
                        </div>
                        <div id="rfc.section.4.1.p.3">
                            <dl>
                                <dt>Length:</dt>
                                <dd style="margin-left: 1.5em">
                                    <div>フレームペイロードの長さをオクテット単位で表した符号なし 24 ビット整数。受信者が <a
                                            href="#SETTINGS_MAX_FRAME_SIZE">SETTINGS_MAX_FRAME_SIZE</a>
                                        に対してより大きな値を設定していない限り、2<sup>14</sup>（16,384）を超える値は送信してはなりません（<em
                                            class="bcp14">MUST
                                            NOT</em>）。</div>
                                    <div>フレームヘッダの 9 オクテットはこの値に含まれません。</div>
                                </dd>
                                <dt>Type:</dt>
                                <dd style="margin-left: 1.5em">
                                    <div>フレームの 8 ビットの型。フレームタイプはフレームの形式とセマンティクスを決定します。本書で定義されたフレームは <a href="#FrameTypes"
                                            title="Frame Definitions">セクション 6</a>
                                        に列挙されています。実装は不明な型のフレームを無視して破棄しなければなりません（<em class="bcp14">MUST</em>）。</div>
                                </dd>
                                <dt>Flags:</dt>
                                <dd style="margin-left: 1.5em">
                                    <div>フレームタイプ固有のブールフラグのために予約された 8 ビットフィールド。</div>
                                    <div>
                                        フラグには示されたフレームタイプに固有の意味が割り当てられます。未使用のフラグとは、特定のフレームタイプに対して定義された意味を持たないものです。未使用のフラグは受信時に無視され、送信時には未設定（0x00）にしておかなければなりません（<em
                                            class="bcp14">MUST</em>）。</div>
                                </dd>
                                <dt>Reserved:</dt>
                                <dd style="margin-left: 1.5em">
                                    <div>予約された 1
                                        ビットフィールド。このビットのセマンティクスは未定義であり、送信時は未設定（0x00）にしておかなければならず、受信時は無視されなければなりません（<em
                                            class="bcp14">MUST</em>）。</div>
                                </dd>
                                <dt>Stream Identifier:</dt>
                                <dd style="margin-left: 1.5em">
                                    <div>ストリーム識別子（<a href="#StreamIdentifiers" title="Stream Identifiers">セクション
                                            5.1.1</a>
                                        を参照）を符号なし 31 ビット整数で表したもの。値 0x00 は個々のストリームではなく接続全体に関連付けられるフレームのために予約されています。</div>
                                </dd>
                            </dl>
                        </div>
                        <div id="rfc.section.4.1.p.4">
                            <p>フレームペイロードの構造と内容はフレームタイプに完全に依存します。</p>
                        </div>
                    </section>
                    <section id="FrameSize">
                        <h3 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a>&nbsp;<a
                                href="#FrameSize">フレームサイズ</a>
                        </h3>
                        <div id="rfc.section.4.2.p.1">
                            <p>フレームペイロードのサイズは、受信者が SETTINGS_MAX_FRAME_SIZE 設定で広告する最大サイズによって制限されます。この設定は
                                2<sup>14</sup>（16,384）から 2<sup>24</sup>-1（16,777,215）オクテットまでの任意の値を取り得ます。</p>
                        </div>
                        <div id="rfc.section.4.2.p.2">
                            <p>すべての実装は、9 オクテットのフレームヘッダを除く最大 2<sup>14</sup> オクテットまでのフレームを受信して最小限に処理できる能力を持たなければなりません（<a
                                    href="#FrameHeader" title="Frame Format">セクション
                                    4.1</a>）。フレームサイズを記述する際にはフレームヘッダのサイズは含まれません。</p>
                        </div>
                        <div id="rfc.section.4.2.p.3">
                            <aside>
                                <div id="rfc.section.4.2.p.3.1">
                                    <p>注：PING（<a href="#PING" title="PING">セクション
                                            6.7</a>）などの特定のフレームタイプは、許容されるフレームペイロードデータ量に追加の制限を課すことがあります。</p>
                                </div>
                            </aside>
                        </div>
                        <div id="rfc.section.4.2.p.4">
                            <p>エンドポイントは、フレームが <a href="#SETTINGS_MAX_FRAME_SIZE">SETTINGS_MAX_FRAME_SIZE</a>
                                で定義されたサイズを超える場合、フレームタイプに定義されたいかなる制限を超える場合、または必須のフレームデータを含むには小さすぎる場合、<a
                                    href="#FRAME_SIZE_ERROR">FRAME_SIZE_ERROR</a> のエラーコードを送信しなければなりません（<em
                                    class="bcp14">MUST</em>）。接続全体の状態を変更し得るフレーム内のフレームサイズエラーは接続エラー（<a
                                    href="#ConnectionErrorHandler" title="Connection Error Handling">セクション
                                    5.4.1</a>）として扱われなければなりません（<em class="bcp14">MUST</em>）。これにはフィールドブロックを運ぶ任意のフレーム（<a
                                    href="#FieldBlock" title="Field Section Compression and Decompression">セクション
                                    4.3</a>、すなわち <a href="#HEADERS" title="HEADERS">HEADERS</a>, <a href="#PUSH_PROMISE"
                                    title="PUSH_PROMISE">PUSH_PROMISE</a>, および <a href="#CONTINUATION"
                                    title="CONTINUATION">CONTINUATION</a>）、<a href="#SETTINGS"
                                    title="SETTINGS">SETTINGS</a>
                                フレーム、およびストリーム識別子が 0 の任意のフレームが含まれます。</p>
                        </div>
                        <div id="rfc.section.4.2.p.5">
                            <p>エンドポイントはフレーム内の利用可能なすべての空間を使い切る義務はありません。許容最大サイズより小さいフレームを使用することで応答性が向上することがあります。大きなフレームを送信すると、<a
                                    href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a>、<a href="#WINDOW_UPDATE"
                                    title="WINDOW_UPDATE">WINDOW_UPDATE</a>、または <a href="#PRIORITY"
                                    title="PRIORITY">PRIORITY</a>
                                のような時間センシティブなフレームの送信が遅延される可能性があり、大きなフレームの送信によりこれらがブロックされると性能に影響を与える場合があります。</p>
                        </div>
                    </section>
                    <section id="FieldBlock">
                        <h3 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a>&nbsp;<a
                                href="#FieldBlock">フィールドセクションの圧縮と解凍</a></h3>
                        <div id="rfc.section.4.3.p.1">
                            <p>フィールドセクションの圧縮とは、フィールドラインの集合（RFC 9110 の <a
                                    href="https://www.rfc-editor.org/rfc/rfc9110.html#section-5.2">セクション 5.2</a>
                                を参照）を圧縮してフィールドブロックを形成するプロセスです。フィールドセクションの解凍とは、フィールドブロックをデコードしてフィールドラインの集合に戻すプロセスです。HTTP/2
                                のフィールドセクション圧縮と解凍の詳細は <a href="#RFC7541"><cite
                                        title="HPACK: Header Compression for HTTP/2">[COMPRESSION]</cite></a>
                                に定義されており、歴史的理由からこれらのプロセスをヘッダ圧縮およびヘッダ解凍と呼んでいます。</p>
                        </div>
                        <div id="rfc.section.4.3.p.2">
                            <p>各フィールドブロックは単一のフィールドセクションの圧縮されたフィールドラインをすべて運びます。ヘッダセクションは擬似ヘッダーフィールド（<a
                                    href="#PseudoHeaderFields" title="HTTP Control Data">セクション
                                    8.3</a>）というメッセージに関連する制御データも含み、これらはフィールドラインと同じ形式を使用します。</p>
                        </div>
                        <div id="rfc.section.4.3.p.3">
                            <aside>
                                <div id="rfc.section.4.3.p.3.1">
                                    <p>注：RFC 7540（<a href="#RFC7540"><cite
                                                title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>）は歴史的に
                                        "header block" という用語をより一般的な "field block" の代わりに使用していました。</p>
                                </div>
                            </aside>
                        </div>
                        <div id="rfc.section.4.3.p.4">
                            <p>フィールドブロックはリクエスト、レスポンス、約束されたリクエスト、およびプッシュされたレスポンスの制御データとヘッダセクションを運びます（<a
                                    href="#PushResources" title="Server Push">セクション 8.4</a> を参照）。これらのメッセージはすべて、途中応答および
                                PUSH_PROMISE (<a href="#PUSH_PROMISE" title="PUSH_PROMISE">セクション 6.6</a>)
                                に含まれるリクエストを除き、トレーラセクションを運ぶフィールドブロックをオプションで含めることができます。</p>
                        </div>
                        <div id="rfc.section.4.3.p.5">
                            <p>フィールドセクションはフィールドラインの集合です。フィールドブロック内の各フィールドラインは単一の値を運びます。直列化されたフィールドブロックはその後、フィールドブロックフラグメントと呼ばれる
                                1 つ以上のオクテット列に分割されます。最初のフィールドブロックフラグメントは HEADERS（<a href="#HEADERS" title="HEADERS">セクション
                                    6.2</a>）または PUSH_PROMISE（<a href="#PUSH_PROMISE" title="PUSH_PROMISE">セクション
                                    6.6</a>）のフレームのフレームペイロード内で送信され、その後に続くフィールドブロックフラグメントを運ぶために CONTINUATION（<a
                                    href="#CONTINUATION" title="CONTINUATION">セクション 6.10</a>）フレームが続くことがあります。</p>
                        </div>
                        <div id="rfc.section.4.3.p.6">
                            <p><a href="#RFC6265"><cite title="HTTP State Management Mechanism">Cookie header
                                        field</cite></a>（[COOKIE]）は HTTP マッピングで特別に扱われます（<a href="#CompressCookie"
                                    title="Compressing the Cookie Header Field">セクション 8.2.3</a> を参照）。</p>
                        </div>
                        <div id="rfc.section.4.3.p.7">
                            <p>受信エンドポイントはフィールドブロックをフラグメントを連結して再構成し、その後ブロックを解凍してフィールドセクションを復元します。</p>
                        </div>
                        <div id="rfc.section.4.3.p.8" class="avoidbreakafter">
                            <p>完全なフィールドセクションは次のいずれかで構成されます：</p>
                        </div>
                        <div id="rfc.section.4.3.p.9">
                            <ul>
                                <li>END_HEADERS フラグが設定された単一の <a href="#HEADERS" title="HEADERS">HEADERS</a> または <a
                                        href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> フレーム、または</li>
                                <li>END_HEADERS フラグが未設定の <a href="#HEADERS" title="HEADERS">HEADERS</a> または <a
                                        href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> フレームと、続く 1 個以上の <a
                                        href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> フレームで、最後の <a
                                        href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> フレームに END_HEADERS
                                    フラグが設定されている場合。</li>
                            </ul>
                        </div>
                        <div id="rfc.section.4.3.p.10">
                            <p>各フィールドブロックは離散的な単位として処理されます。フィールドブロックは連続したフレーム列として送信されなければならず（<em
                                    class="bcp14">MUST</em>）、他の型のフレームや他のストリームからのフレームが途中に挟まってはなりません。<a href="#HEADERS"
                                    title="HEADERS">HEADERS</a> または <a href="#CONTINUATION"
                                    title="CONTINUATION">CONTINUATION</a> の列の最後のフレームには END_HEADERS フラグが設定されます。<a
                                    href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> または <a
                                    href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> の列の最後のフレームにも END_HEADERS
                                フラグが設定されます。これによりフィールドブロックは論理的に単一フレームと同等になります。</p>
                        </div>
                        <div id="rfc.section.4.3.p.11">
                            <p>フィールドブロックフラグメントは <a href="#HEADERS" title="HEADERS">HEADERS</a>、<a href="#PUSH_PROMISE"
                                    title="PUSH_PROMISE">PUSH_PROMISE</a>、または <a href="#CONTINUATION"
                                    title="CONTINUATION">CONTINUATION</a>
                                フレームのフレームペイロードとしてのみ送信できます。これらのフレームは受信者が保持する圧縮コンテキストを変更し得るデータを運ぶためです。<a href="#HEADERS"
                                    title="HEADERS">HEADERS</a>、<a href="#PUSH_PROMISE"
                                    title="PUSH_PROMISE">PUSH_PROMISE</a>、または <a href="#CONTINUATION"
                                    title="CONTINUATION">CONTINUATION</a>
                                フレームを受信するエンドポイントは、たとえそれらのフレームが破棄される場合でもフィールドブロックを再構成して解凍を行う必要があります。もし受信者がフィールドブロックを解凍しない場合、受信者は接続エラー（<a
                                    href="#ConnectionErrorHandler" title="Connection Error Handling">セクション 5.4.1</a>）を
                                <a href="#COMPRESSION_ERROR">COMPRESSION_ERROR</a> の種類で終了しなければなりません（<em
                                    class="bcp14">MUST</em>）。
                            </p>
                        </div>
                        <div id="rfc.section.4.3.p.12">
                            <p>フィールドブロックのデコードエラーは接続エラー（<a href="#ConnectionErrorHandler"
                                    title="Connection Error Handling">セクション 5.4.1</a>）として扱われ、<a
                                    href="#COMPRESSION_ERROR">COMPRESSION_ERROR</a> の種類に該当します（<em
                                    class="bcp14">MUST</em>）。
                            </p>
                        </div>
                        <section id="dynamic-table">
                            <h4 id="rfc.section.4.3.1"><a href="#rfc.section.4.3.1">4.3.1.</a>&nbsp;<a
                                    href="#dynamic-table">圧縮状態</a></h4>
                            <div id="rfc.section.4.3.1.p.1">
                                <p>フィールド圧縮は状態を持ちます。各エンドポイントは、接続上のすべてのフィールドブロックのエンコードとデコードに使用される HPACK エンコーダコンテキストと HPACK
                                    デコーダコンテキストを持ちます。HPACK の <a
                                        href="https://www.rfc-editor.org/rfc/rfc7541.html#section-4">セクション 4</a>
                                    は、各コンテキストの主要な状態である動的テーブルを定義します（<a href="#RFC7541"><cite
                                            title="HPACK: Header Compression for HTTP/2">[COMPRESSION]</cite></a>）。</p>
                            </div>
                            <div id="rfc.section.4.3.1.p.2">
                                <p>動的テーブルにはデコーダが設定する最大サイズがあります。エンドポイントはその HPACK デコーダコンテキストが選択したサイズを
                                    SETTINGS_HEADER_TABLE_SIZE 設定を使って伝達します（<a href="#SettingValues"
                                        title="Defined Settings">セクション 6.5.2</a> を参照）。接続が確立されると、両端の HPACK
                                    デコーダおよびエンコーダの動的テーブルサイズは SETTINGS_HEADER_TABLE_SIZE 設定の初期値である 4,096 バイトで開始します。</p>
                            </div>
                            <div id="rfc.section.4.3.1.p.3">
                                <p>SETTINGS_HEADER_TABLE_SIZE
                                    を使って設定された最大値への任意の変更は、エンドポイントが設定を確認（acknowledge）したときに有効になります（<a href="#SettingsSync"
                                        title="Settings Synchronization">セクション 6.5.3</a>）。そのエンドポイントの
                                    HPACK エンコーダはデコーダが設定した最大値までの任意のサイズに動的テーブルを設定できます。HPACK エンコーダは Dynamic Table Size
                                    Update
                                    命令で動的テーブルのサイズを宣言します（<a
                                        href="https://www.rfc-editor.org/rfc/rfc7541.html#section-6.3">RFC 7541 セクション
                                        6.3</a> を参照）。</p>
                            </div>
                            <div id="rfc.section.4.3.1.p.4">
                                <p>エンドポイントが SETTINGS_HEADER_TABLE_SIZE
                                    の変更を確認し、それによって現在の動的テーブルサイズよりも小さく最大値が低下した場合、そのエンドポイントの
                                    HPACK エンコーダは次のフィールドブロックの開始時に動的テーブルを低下後の最大値以下に設定する Dynamic Table Size Update
                                    命令で開始しなければなりません（<a
                                        href="https://www.rfc-editor.org/rfc/rfc7541.html#section-4.2">RFC
                                        7541 セクション 4.2</a> を参照）。エンドポイントは、最大動的テーブルサイズの縮小を確認した後に続くフィールドブロックが適合する Dynamic
                                    Table
                                    Size Update 命令で始まらない場合、そのフィールドブロックを接続エラー（<a href="#ConnectionErrorHandler"
                                        title="Connection Error Handling">セクション 5.4.1</a>）として <a
                                        href="#COMPRESSION_ERROR">COMPRESSION_ERROR</a> の種類で扱わなければなりません（<em
                                        class="bcp14">MUST</em>）。</p>
                            </div>
                            <div id="rfc.section.4.3.1.p.5">
                                <aside>
                                    <div id="rfc.section.4.3.1.p.5.1">
                                        <p>実装者への助言：SETTINGS_HEADER_TABLE_SIZE
                                            の値を小さくすることは広く相互運用可能ではない可能性があります。接続序文を用いて初期値
                                            4,096 未満に値を減らす使用法の方がややサポートされやすいですが、いくつかの実装では失敗する可能性があります。</p>
                                    </div>
                                </aside>
                            </div>
                        </section>
                    </section>
                </section>
                <hr class="hidden-print">
                <section id="StreamsLayer">
                    <h2 id="rfc.section.5" class="np"><a href="#rfc.section.5">5.</a>&nbsp;<a
                            href="#StreamsLayer">ストリームと多重化</a></h2>
                    <div id="rfc.section.5.p.1" class="avoidbreakafter">
                        <p>"stream"（ストリーム）とは、HTTP/2 接続内でクライアントとサーバーの間で交換される独立した双方向のフレーム列を指します。ストリームにはいくつかの重要な特徴があります：
                        </p>
                    </div>
                    <div id="rfc.section.5.p.2">
                        <ul>
                            <li>単一の HTTP/2 接続は複数の同時に開かれたストリームを含むことができ、いずれのエンドポイントも複数のストリームからフレームをインターリーブして送信できます。</li>
                            <li>ストリームは一方的に確立して使用することも、いずれのエンドポイントも共有して使用することもできます。</li>
                            <li>ストリームはどちらのエンドポイントによってもクローズできます。</li>
                            <li>フレームが送信される順序は重要です。受信者は受信した順にフレームを処理します。特に、<a href="#HEADERS" title="HEADERS">HEADERS</a>
                                および
                                <a href="#DATA" title="DATA">DATA</a> フレームの順序は意味論的に重要です。
                            </li>
                            <li>ストリームは整数で識別されます。ストリーム識別子はストリームを開始するエンドポイントによって割り当てられます。</li>
                        </ul>
                    </div>
                    <section id="StreamStates">
                        <h3 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a>&nbsp;<a
                                href="#StreamStates">ストリームの状態</a></h3>
                        <div id="rfc.section.5.1.p.1">
                            <p>ストリームのライフサイクルは <a href="#StreamStatesFigure" title="Stream States">Figure 2</a> に示されています。
                            </p>
                        </div>
                        <div id="StreamStatesFigure"></div>
                        <div id="rfc.figure.2">
                            <div class="artwork art-svg"><svg xmlns="http://www.w3.org/2000/svg"
                                    xmlns:xi="http://www.w3.org/2001/XInclude" version="1.1" height="480" width="488"
                                    viewBox="0 0 488 480" class="diagram" text-anchor="middle" font-family="monospace"
                                    font-size="13px">
                                    <g transform="translate(8,16)">
                                        <path d="M 0,112 L 0,416" fill="none" stroke="black" />
                                        <path d="M 56,80 L 56,144" fill="none" stroke="black" />
                                        <path d="M 56,240 L 56,304" fill="none" stroke="black" />
                                        <path d="M 88,144 L 88,232" fill="none" stroke="black" />
                                        <path d="M 96,304 L 96,384" fill="none" stroke="black" />
                                        <path d="M 144,80 L 144,144" fill="none" stroke="black" />
                                        <path d="M 144,240 L 144,304" fill="none" stroke="black" />
                                        <path d="M 200,0 L 200,64" fill="none" stroke="black" />
                                        <path d="M 200,160 L 200,224" fill="none" stroke="black" />
                                        <path d="M 200,368 L 200,432" fill="none" stroke="black" />
                                        <path d="M 232,64 L 232,152" fill="none" stroke="black" />
                                        <path d="M 232,224 L 232,360" fill="none" stroke="black" />
                                        <path d="M 272,0 L 272,64" fill="none" stroke="black" />
                                        <path d="M 272,160 L 272,224" fill="none" stroke="black" />
                                        <path d="M 272,368 L 272,432" fill="none" stroke="black" />
                                        <path d="M 328,80 L 328,144" fill="none" stroke="black" />
                                        <path d="M 328,240 L 328,304" fill="none" stroke="black" />
                                        <path d="M 376,304 L 376,384" fill="none" stroke="black" />
                                        <path d="M 384,144 L 384,232" fill="none" stroke="black" />
                                        <path d="M 416,80 L 416,144" fill="none" stroke="black" />
                                        <path d="M 416,240 L 416,304" fill="none" stroke="black" />
                                        <path d="M 472,112 L 472,416" fill="none" stroke="black" />
                                        <path d="M 200,0 L 272,0" fill="none" stroke="black" />
                                        <path d="M 128,32 L 200,32" fill="none" stroke="black" />
                                        <path d="M 272,32 L 344,32" fill="none" stroke="black" />
                                        <path d="M 200,64 L 272,64" fill="none" stroke="black" />
                                        <path d="M 56,80 L 144,80" fill="none" stroke="black" />
                                        <path d="M 328,80 L 416,80" fill="none" stroke="black" />
                                        <path d="M 0,112 L 56,112" fill="none" stroke="black" />
                                        <path d="M 416,112 L 472,112" fill="none" stroke="black" />
                                        <path d="M 56,144 L 144,144" fill="none" stroke="black" />
                                        <path d="M 328,144 L 416,144" fill="none" stroke="black" />
                                        <path d="M 200,160 L 272,160" fill="none" stroke="black" />
                                        <path d="M 136,192 L 200,192" fill="none" stroke="black" />
                                        <path d="M 272,192 L 336,192" fill="none" stroke="black" />
                                        <path d="M 200,224 L 272,224" fill="none" stroke="black" />
                                        <path d="M 56,240 L 144,240" fill="none" stroke="black" />
                                        <path d="M 328,240 L 416,240" fill="none" stroke="black" />
                                        <path d="M 56,304 L 144,304" fill="none" stroke="black" />
                                        <path d="M 328,304 L 416,304" fill="none" stroke="black" />
                                        <path d="M 200,368 L 272,368" fill="none" stroke="black" />
                                        <path d="M 96,384 L 192,384" fill="none" stroke="black" />
                                        <path d="M 280,384 L 376,384" fill="none" stroke="black" />
                                        <path d="M 0,416 L 192,416" fill="none" stroke="black" />
                                        <path d="M 280,416 L 472,416" fill="none" stroke="black" />
                                        <path d="M 200,432 L 272,432" fill="none" stroke="black" />
                                        <path d="M 336,192 L 356,232" fill="none" stroke="black" />
                                        <path d="M 344,32 L 364,72" fill="none" stroke="black" />
                                        <path d="M 108,72 L 128,32" fill="none" stroke="black" />
                                        <path d="M 116,232 L 136,192" fill="none" stroke="black" />
                                        <polygon class="arrowhead" points="392,232 380,226.4 380,237.6" fill="black"
                                            transform="rotate(90,384,232)" />
                                        <polygon class="arrowhead" points="372,72 360,66.4 360,77.6" fill="black"
                                            transform="rotate(63.43494882292201,364,72)" />
                                        <polygon class="arrowhead" points="364,232 352,226.4 352,237.6" fill="black"
                                            transform="rotate(63.43494882292201,356,232)" />
                                        <polygon class="arrowhead" points="288,416 276,410.4 276,421.6" fill="black"
                                            transform="rotate(180,280,416)" />
                                        <polygon class="arrowhead" points="288,384 276,378.4 276,389.6" fill="black"
                                            transform="rotate(180,280,384)" />
                                        <polygon class="arrowhead" points="240,360 228,354.4 228,365.6" fill="black"
                                            transform="rotate(90,232,360)" />
                                        <polygon class="arrowhead" points="240,152 228,146.4 228,157.6" fill="black"
                                            transform="rotate(90,232,152)" />
                                        <polygon class="arrowhead" points="200,416 188,410.4 188,421.6" fill="black"
                                            transform="rotate(0,192,416)" />
                                        <polygon class="arrowhead" points="200,384 188,378.4 188,389.6" fill="black"
                                            transform="rotate(0,192,384)" />
                                        <polygon class="arrowhead" points="124,232 112,226.4 112,237.6" fill="black"
                                            transform="rotate(116.56505117707799,116,232)" />
                                        <polygon class="arrowhead" points="116,72 104,66.4 104,77.6" fill="black"
                                            transform="rotate(116.56505117707799,108,72)" />
                                        <polygon class="arrowhead" points="96,232 84,226.4 84,237.6" fill="black"
                                            transform="rotate(90,88,232)" />
                                        <g class="text">
                                            <text x="160" y="20">send PP</text>
                                            <text x="312" y="20">recv PP</text>
                                            <text x="236" y="36">idle</text>
                                            <text x="276" y="100">send H /</text>
                                            <text x="100" y="116">reserved</text>
                                            <text x="268" y="116">recv H</text>
                                            <text x="372" y="116">reserved</text>
                                            <text x="96" y="132">(local)</text>
                                            <text x="372" y="132">(remote)</text>
                                            <text x="160" y="180">recv ES</text>
                                            <text x="312" y="180">send ES</text>
                                            <text x="52" y="196">send H</text>
                                            <text x="236" y="196">open</text>
                                            <text x="420" y="196">recv H</text>
                                            <text x="100" y="260">half-</text>
                                            <text x="372" y="260">half-</text>
                                            <text x="100" y="276">closed</text>
                                            <text x="276" y="276">send R /</text>
                                            <text x="372" y="276">closed</text>
                                            <text x="100" y="292">(remote)</text>
                                            <text x="268" y="292">recv R</text>
                                            <text x="368" y="292">(local)</text>
                                            <text x="144" y="340">send ES /</text>
                                            <text x="328" y="340">recv ES /</text>
                                            <text x="148" y="356">send R /</text>
                                            <text x="332" y="356">send R /</text>
                                            <text x="140" y="372">recv R</text>
                                            <text x="324" y="372">recv R</text>
                                            <text x="44" y="388">send R /</text>
                                            <text x="428" y="388">send R /</text>
                                            <text x="36" y="404">recv R</text>
                                            <text x="236" y="404">closed</text>
                                            <text x="420" y="404">recv R</text>
                                        </g>
                                    </g>
                                </svg></div>
                        </div>
                        <p class="figure">Figure 2: Stream States</p>
                        <div id="rfc.section.5.1.p.2">
                            <dl class="compact">
                                <dt><span class="tt">send</span>:</dt>
                                <dd style="margin-left: 1.5em">endpoint がこのフレームを送信する</dd>
                                <dt><span class="tt">recv</span>:</dt>
                                <dd style="margin-left: 1.5em">endpoint がこのフレームを受信する</dd>
                                <dt><span class="tt">H</span>:</dt>
                                <dd style="margin-left: 1.5em"><a href="#HEADERS" title="HEADERS">HEADERS</a> フレーム（暗黙の
                                    <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> フレームを含む）
                                </dd>
                                <dt><span class="tt">ES</span>:</dt>
                                <dd style="margin-left: 1.5em">END_STREAM フラグ</dd>
                                <dt><span class="tt">R</span>:</dt>
                                <dd style="margin-left: 1.5em"><a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a>
                                    フレーム
                                </dd>
                                <dt><span class="tt">PP</span>:</dt>
                                <dd style="margin-left: 1.5em"><a href="#PUSH_PROMISE"
                                        title="PUSH_PROMISE">PUSH_PROMISE</a>
                                    フレーム（暗黙の <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a>
                                    フレームを含む）；状態遷移は約束されたストリームに対するもの</dd>
                            </dl>
                        </div>
                        <div id="rfc.section.5.1.p.3">
                            <p>この図はストリーム状態の遷移およびそれらの遷移に影響するフレームとフラグのみを示しています。この点で、<a href="#CONTINUATION"
                                    title="CONTINUATION">CONTINUATION</a> フレームは状態遷移を引き起こさず、実質的にそれに続く <a href="#HEADERS"
                                    title="HEADERS">HEADERS</a> または <a href="#PUSH_PROMISE"
                                    title="PUSH_PROMISE">PUSH_PROMISE</a> の一部です。状態遷移の目的では、END_STREAM
                                フラグはそれを持つフレームとは別個のイベントとして処理されます。END_STREAM フラグが設定された <a href="#HEADERS"
                                    title="HEADERS">HEADERS</a> フレームは 2 つの状態遷移を引き起こす可能性があります。</p>
                        </div>
                        <div id="rfc.section.5.1.p.4">
                            <p>両端点はストリーム状態について主観的な見解を持ち、フレームが転送中の場合にはその見解が異なることがあります。エンドポイントはストリームの作成を協調しません；ストリームはどちらのエンドポイントからも一方的に作成されます。状態の不一致による負の影響は、RST_STREAM
                                を送信した後の "closed" 状態に限定され、クローズ後もしばらくの間フレームが受信される可能性があります。</p>
                        </div>
                        <div id="rfc.section.5.1.p.5" class="avoidbreakafter">
                            <p>ストリームは以下の状態を持ちます：</p>
                        </div>
                        <div id="rfc.section.5.1.p.6">
                            <dl>
                                <dt>idle:</dt>
                                <dd style="margin-left: 1.5em">
                                    <div>すべてのストリームは "idle" 状態で開始します。</div>
                                    <div>この状態から有効な遷移は次のとおりです：</div>
                                    <div>
                                        <ul>
                                            <li>クライアントとして <a href="#HEADERS" title="HEADERS">HEADERS</a>
                                                フレームを送信する、またはサーバーとして HEADERS フレームを受信することでストリームは "open" になります。ストリーム識別子は
                                                <a href="#StreamIdentifiers" title="Stream Identifiers">Section
                                                    5.1.1</a>
                                                に記載の通り選択されます。同じ <a href="#HEADERS" title="HEADERS">HEADERS</a>
                                                フレームは直ちにストリームを "half-closed" にすることもできます。
                                            </li>
                                            <li>別のストリーム上で <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a>
                                                フレームを送信すると、後で使用するためにアイドルストリームが予約されます。予約されたストリームの状態は "reserved (local)"
                                                に遷移します。PUSH_PROMISE フレームを送信できるのはサーバーのみです。</li>
                                            <li>別のストリーム上で <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a>
                                                フレームを受信すると、後で使用するためにアイドルストリームが予約されます。予約されたストリームの状態は "reserved (remote)"
                                                に遷移します。PUSH_PROMISE フレームを受信するのはクライアントのみです。</li>
                                            <li>PUSH_PROMISE フレームはアイドルストリーム上で送信されるのではなく、Promised Stream ID
                                                フィールドで新しく予約されたストリームを参照する点に注意してください。</li>
                                            <li>より大きな値のストリーム識別子でストリームが開かれると、そのストリームは直ちに "closed"
                                                状態に遷移します；この遷移は図には示されていません。
                                            </li>
                                        </ul>
                                    </div>
                                    <div>この状態のストリームで <a href="#HEADERS" title="HEADERS">HEADERS</a> または <a
                                            href="#PRIORITY" title="PRIORITY">PRIORITY</a> 以外の任意のフレームを受信した場合、これは接続エラー（<a
                                            href="#ConnectionErrorHandler" title="Connection Error Handling">Section
                                            5.4.1</a>）の <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a> として扱われなければなりません（<em
                                            class="bcp14">MUST</em>）。このストリームがサーバーによって開始されたものである場合（<a
                                            href="#StreamIdentifiers" title="Stream Identifiers">Section 5.1.1</a>
                                        を参照）、HEADERS フレームを受信することも接続エラー（PROTOCOL_ERROR）として扱われなければなりません。</div>
                                </dd>
                                <dt>reserved (local):</dt>
                                <dd style="margin-left: 1.5em">
                                    <div>"reserved (local)" 状態のストリームは、PUSH_PROMISE フレームを送信することで約束されたストリームです。PUSH_PROMISE
                                        フレームはリモートピアによって開始されたオープンストリームと関連付けることでアイドルストリームを予約します（<a href="#PushResources"
                                            title="Server Push">Section 8.4</a> を参照）。</div>
                                    <div>この状態では次の遷移のみ可能です：</div>
                                    <div>
                                        <ul>
                                            <li>エンドポイントは <a href="#HEADERS" title="HEADERS">HEADERS</a>
                                                フレームを送信できます。これによりストリームは "half-closed (remote)" でオープンします。</li>
                                            <li>いずれのエンドポイントも <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a>
                                                フレームを送信してストリームを "closed" にすることができます。これによりストリームの予約は解放されます。</li>
                                        </ul>
                                    </div>
                                    <div>この状態でエンドポイントは <a href="#HEADERS" title="HEADERS">HEADERS</a>、<a
                                            href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a>、または <a href="#PRIORITY"
                                            title="PRIORITY">PRIORITY</a> 以外のフレームを送信してはなりません（<em class="bcp14">MUST
                                            NOT</em>）。</div>
                                    <div><a href="#PRIORITY" title="PRIORITY">PRIORITY</a> または <a href="#WINDOW_UPDATE"
                                            title="WINDOW_UPDATE">WINDOW_UPDATE</a> フレームはこの状態で受信されてもよい（<em
                                            class="bcp14">MAY</em>）。この状態で RST_STREAM、PRIORITY、または WINDOW_UPDATE
                                        以外のフレームを受信した場合は接続エラー（<a href="#ConnectionErrorHandler"
                                            title="Connection Error Handling">Section 5.4.1</a>）の PROTOCOL_ERROR
                                        として扱わなければなりません（<em class="bcp14">MUST</em>）。</div>
                                </dd>
                                <dt>reserved (remote):</dt>
                                <dd style="margin-left: 1.5em">
                                    <div>"reserved (remote)" 状態のストリームはリモートピアによって予約されたストリームです。</div>
                                    <div>この状態では次の遷移のみ可能です：</div>
                                    <div>
                                        <ul>
                                            <li>HEADERS フレームを受信するとストリームは "half-closed (local)" に遷移します。</li>
                                            <li>いずれのエンドポイントも RST_STREAM フレームを送信してストリームを "closed" にし、予約を解除できます。</li>
                                        </ul>
                                    </div>
                                    <div>この状態でエンドポイントは RST_STREAM、WINDOW_UPDATE、または PRIORITY 以外のフレームを送信してはなりません（<em
                                            class="bcp14">MUST NOT</em>）。</div>
                                    <div>この状態で HEADERS、RST_STREAM、または PRIORITY 以外のフレームを受信した場合は接続エラー（<a
                                            href="#ConnectionErrorHandler" title="Connection Error Handling">Section
                                            5.4.1</a>）の PROTOCOL_ERROR として扱わなければなりません（<em class="bcp14">MUST</em>）。
                                    </div>
                                </dd>
                                <dt>open:</dt>
                                <dd style="margin-left: 1.5em">
                                    <div>"open" 状態のストリームは、両方のピアが任意の型のフレームを送信して使用できます。この状態では送信者は広告されたストリームレベルのフロー制御制限（<a
                                            href="#FlowControl" title="Flow Control">Section 5.2</a>）を遵守します。</div>
                                    <div>この状態からいずれのエンドポイントも END_STREAM フラグを持つフレームを送信でき、これによりストリームは "half-closed"
                                        状態のいずれかに遷移します。END_STREAM フラグを送信したエンドポイントは "half-closed (local)" となり、END_STREAM
                                        フラグを受信したエンドポイントは "half-closed (remote)" となります。</div>
                                    <div>いずれのエンドポイントもこの状態から RST_STREAM フレームを送信でき、これにより直ちに "closed" に遷移します。</div>
                                </dd>
                                <dt>half-closed (local):</dt>
                                <dd style="margin-left: 1.5em">
                                    <div>"half-closed (local)" 状態のストリームは、WINDOW_UPDATE、PRIORITY、および RST_STREAM
                                        以外のフレームを送信することはできません。</div>
                                    <div>この状態からは、END_STREAM フラグを持つフレームを受信するか、いずれのピアが RST_STREAM を送信すると "closed" に遷移します。
                                    </div>
                                    <div>この状態では任意の型のフレームを受信できます。フロー制御されたフレームの受信を継続するためには WINDOW_UPDATE
                                        フレームでフロー制御クレジットを提供する必要があります。この状態では、END_STREAM フラグが設定されたフレームを送信した後もしばらくの間
                                        WINDOW_UPDATE フレームを無視できる場合があります。</div>
                                    <div>この状態で PRIORITY フレームは受信可能です。</div>
                                </dd>
                                <dt>half-closed (remote):</dt>
                                <dd style="margin-left: 1.5em">
                                    <div>"half-closed (remote)"
                                        状態のストリームは、もはや相手ピアがフレームを送信するために使用していません。この状態では、エンドポイントはもはや受信者フロー制御ウィンドウを維持する義務を負いません。
                                    </div>
                                    <div>この状態のストリームに対して WINDOW_UPDATE、PRIORITY、または RST_STREAM
                                        以外の追加フレームを受信した場合、ストリームエラー（<a href="#StreamErrorHandler"
                                            title="Stream Error Handling">Section 5.4.2</a>）の
                                        STREAM_CLOSED を送る必要があります（<em class="bcp14">MUST</em>）。</div>
                                    <div>"half-closed (remote)"
                                        のストリームは、エンドポイントが任意の型のフレームを送信するために使用できます。この状態ではエンドポイントは引き続き広告されたストリームレベルのフロー制御制限を遵守します（<a
                                            href="#FlowControl" title="Flow Control">Section 5.2</a>）。</div>
                                    <div>この状態からは、END_STREAM フラグを持つフレームを送信するか、いずれのピアが RST_STREAM フレームを送信すると "closed"
                                        に遷移できます。
                                    </div>
                                </dd>
                                <dt>closed:</dt>
                                <dd style="margin-left: 1.5em">
                                    <div>"closed" 状態は終端状態です。</div>
                                    <div>ストリームは、両端点が END_STREAM フラグを持つフレームを送受信した後に "closed" になります。また、いずれかのエンドポイントが
                                        RST_STREAM を送信または受信した場合も "closed" になります。</div>
                                    <div>閉じられたストリーム上で PRIORITY 以外のフレームを送信してはなりません（<em class="bcp14">MUST
                                            NOT</em>）。閉じたストリームで他の型のフレームを受信した場合、エンドポイントはそれを接続エラー（<a
                                            href="#ConnectionErrorHandler" title="Connection Error Handling">Section
                                            5.4.1</a>）の STREAM_CLOSED として扱ってもよい（<em
                                            class="bcp14">MAY</em>）、ただし以下の注意があります。
                                    </div>
                                    <div>エンドポイントが END_STREAM フラグ付きフレームまたは RST_STREAM
                                        を送信した場合、ピアがそのストリームをクローズするフレームを受信して処理するまでの間に WINDOW_UPDATE や RST_STREAM
                                        を受信することがあります。
                                    </div>
                                    <div>open または half-closed (local) 状態にあるストリームに対して RST_STREAM
                                        を送信したエンドポイントは任意の型のフレームを受信する可能性があります。ピアはこれらのフレームを RST_STREAM
                                        を処理する前に送信または送信キューに入れている可能性があるためです。エンドポイントはこの状態で受信したフレームを最小限に処理して破棄しなければなりません。これには
                                        <a href="#HEADERS" title="HEADERS">HEADERS</a> や <a href="#PUSH_PROMISE"
                                            title="PUSH_PROMISE">PUSH_PROMISE</a> フレームのヘッダ圧縮状態の更新が含まれます。閉じられたストリーム上で
                                        PUSH_PROMISE を受信すると、約束されたストリームは "reserved (remote)" になります。さらに、<a href="#DATA"
                                            title="DATA">DATA</a> フレームの内容は接続フロー制御ウィンドウに対してカウントされます。
                                    </div>
                                    <div>エンドポイントは "closed"
                                        状態のすべてのストリームに対してこの最小限の処理を行うことができます。エンドポイントはピアがストリームを閉じるために送ったフレームを受信したことを検出する他の信号を使用して、PRIORITY
                                        以外のフレームを接続エラー（PROTOCOL_ERROR）として扱うことができます。エンドポイントはこの目的のためにタイマを使用すべきではありません。例えば、ストリームを閉じた後に
                                        SETTINGS フレームを送信したエンドポイントは、設定の確認を受け取った後にそのストリーム上で DATA
                                        フレームを受信した場合にエラーと見なすことができます。その他に使用され得るものとしては PING
                                        フレーム、閉じたストリームの後に作成されたストリームでのデータ受信、あるいは閉じた後に作成されたリクエストへのレスポンスなどがあります。</div>
                                </dd>
                            </dl>
                        </div>
                        <div id="rfc.section.5.1.p.7">
                            <p>より具体的な規則がない場合、実装は状態の記述で明示的に許可されていないフレームの受信を接続エラー（<a href="#ConnectionErrorHandler"
                                    title="Connection Error Handling">Section 5.4.1</a>）の PROTOCOL_ERROR として扱うべきです（<em
                                    class="bcp14">SHOULD</em>）。なお、<a href="#PRIORITY" title="PRIORITY">PRIORITY</a>
                                は任意のストリーム状態で送受信可能です。</p>
                        </div>
                        <div id="rfc.section.5.1.p.8">
                            <p>この節のルールは本書で定義されたフレームにのみ適用されます。セマンティクスが不明なフレームを受信した場合、それらを送受信する条件も不明なためエラーとして扱うことはできません；詳細は
                                <a href="#extensibility" title="Extending HTTP/2">Section 5.5</a> を参照してください。
                            </p>
                        </div>
                        <div id="rfc.section.5.1.p.9">
                            <p>HTTP リクエスト／レスポンス交換の状態遷移の例は <a href="#HttpExamples" title="Examples">Section 8.8</a>
                                にあります。サーバープッシュの状態遷移の例は <a href="#PushRequests" title="Push Requests">8.4.1</a> および <a
                                    href="#PushResponses" title="Push Responses">8.4.2</a> にあります。</p>
                        </div>
                        <section id="StreamIdentifiers">
                            <h4 id="rfc.section.5.1.1"><a href="#rfc.section.5.1.1">5.1.1.</a>&nbsp;<a
                                    href="#StreamIdentifiers">Stream Identifiers</a></h4>
                            <div id="rfc.section.5.1.1.p.1">
                                <p>ストリームは符号なし 31 ビット整数で識別されます。クライアントが開始するストリームは奇数の識別子を使用しなければなりません（<em
                                        class="bcp14">MUST</em>）；サーバーが開始するストリームは偶数の識別子を使用しなければなりません（<em
                                        class="bcp14">MUST</em>）。ストリーム識別子ゼロ（0x00）は接続制御メッセージに使用され、新しいストリームを確立するために使用できません。
                                </p>
                            </div>
                            <div id="rfc.section.5.1.1.p.2">
                                <p>新しく確立されたストリームの識別子は、そのストリームを開始したエンドポイントが既に開いたまたは予約したすべてのストリームよりも数値的に大きくなければなりません（<em
                                        class="bcp14">MUST</em>）。これは HEADERS フレームを用いて開かれるストリームと、PUSH_PROMISE
                                    を用いて予約されるストリームの両方に適用されます。予期しないストリーム識別子を受け取ったエンドポイントは接続エラー（<a
                                        href="#ConnectionErrorHandler" title="Connection Error Handling">Section
                                        5.4.1</a>）の
                                    PROTOCOL_ERROR として応答しなければなりません。</p>
                            </div>
                            <div id="rfc.section.5.1.1.p.3">
                                <p>HEADERS フレームはフレームヘッダに示されたストリーム識別子を持つクライアント開始ストリームを "idle" から "open"
                                    に遷移させます。PUSH_PROMISE
                                    フレームはフレームペイロードの Promised Stream ID フィールドに示されたサーバー開始ストリームを "idle" から "reserved
                                    (local)"
                                    または "reserved (remote)" に遷移させます。ストリームが "idle"
                                    状態を抜けるとき、ピアがより小さな値のストリーム識別子で開く可能性があったすべての
                                    "idle" ストリームは直ちに "closed"
                                    に遷移します。つまり、エンドポイントはストリーム識別子をスキップでき、その結果スキップされたストリームは即座に閉じられます。
                                </p>
                            </div>
                            <div id="rfc.section.5.1.1.p.4">
                                <p>ストリーム識別子は再利用できません。長時間接続によりエンドポイントが利用可能なストリーム識別子の範囲を使い果たすことがあります。新しいストリーム識別子を確立できないクライアントは新しいストリームのために新しい接続を確立できます。新しい識別子を確立できないサーバーは、クライアントが新しいストリームのために新しい接続を開かざるを得ないように
                                    <a href="#GOAWAY" title="GOAWAY">GOAWAY</a> フレームを送信できます。
                                </p>
                            </div>
                        </section>
                        <section id="n-stream-concurrency">
                            <h4 id="rfc.section.5.1.2"><a href="#rfc.section.5.1.2">5.1.2.</a>&nbsp;<a
                                    href="#n-stream-concurrency">Stream Concurrency</a></h4>
                            <div id="rfc.section.5.1.2.p.1">
                                <p>ピアは <a href="#SETTINGS_MAX_CONCURRENT_STREAMS">SETTINGS_MAX_CONCURRENT_STREAMS</a>
                                    パラメータ（<a href="#SettingValues" title="Defined Settings">Section 6.5.2</a> を参照）を <a
                                        href="#SETTINGS" title="SETTINGS">SETTINGS</a>
                                    フレーム内で使用して同時にアクティブなストリームの数を制限できます。最大同時ストリーム設定は各エンドポイント固有であり、その設定を受け取るピアにのみ適用されます。つまり、クライアントはサーバーが開始できる同時ストリームの最大数を指定し、サーバーはクライアントが開始できる同時ストリームの最大数を指定します。
                                </p>
                            </div>
                            <div id="rfc.section.5.1.2.p.2">
                                <p>"open" 状態またはいずれかの "half-closed"
                                    状態にあるストリームは、エンドポイントが開くことを許可されている最大ストリーム数にカウントされます。これらの三つの状態にあるストリームは <a
                                        href="#SETTINGS_MAX_CONCURRENT_STREAMS">SETTINGS_MAX_CONCURRENT_STREAMS</a>
                                    設定で広告された制限にカウントされます。"reserved" 状態のストリームはストリームの制限にカウントされません。</p>
                            </div>
                            <div id="rfc.section.5.1.2.p.3">
                                <p>エンドポイントはピアが設定した制限を超えてはならない（<em class="bcp14">MUST NOT</em>）。広告された同時ストリーム制限を超える原因となる
                                    <a href="#HEADERS" title="HEADERS">HEADERS</a> フレームを受け取ったエンドポイントは、これはストリームエラー（<a
                                        href="#StreamErrorHandler" title="Stream Error Handling">Section 5.4.2</a>）の
                                    PROTOCOL_ERROR または <a href="#REFUSED_STREAM">REFUSED_STREAM</a> として扱わなければなりません（<em
                                        class="bcp14">MUST</em>）。エラーコードの選択は自動再試行を有効にするかどうかを決定します（詳細は <a
                                        href="#Reliability" title="Request Reliability">Section 8.7</a> を参照）。
                                </p>
                            </div>
                            <div id="rfc.section.5.1.2.p.4">
                                <p>SETTINGS_MAX_CONCURRENT_STREAMS
                                    の値を現在のオープンストリーム数より小さく減らしたいエンドポイントは、新しい値を超えるストリームをクローズするか、ストリームが完了するのを許容することができます。
                                </p>
                            </div>
                        </section>
                    </section>
                    <section id="FlowControl">
                        <h3 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a>&nbsp;<a
                                href="#FlowControl">フロー制御</a>
                        </h3>
                        <div id="rfc.section.5.2.p.1">
                            <p>ストリームを用いた多重化は TCP
                                接続の使用に関する争奪をもたらし、ストリームがブロックされることがあります。フロー制御スキームは同一接続上のストリームが互いに破壊的に干渉しないようにします。フロー制御は個々のストリームおよび接続全体の両方に対して使用されます。
                            </p>
                        </div>
                        <div id="rfc.section.5.2.p.2">
                            <p>HTTP/2 は WINDOW_UPDATE フレーム（<a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">Section
                                    6.9</a>）を使用してフロー制御を提供します。</p>
                        </div>
                        <section id="fc-principles">
                            <h4 id="rfc.section.5.2.1"><a href="#rfc.section.5.2.1">5.2.1.</a>&nbsp;<a
                                    href="#fc-principles">フロー制御の原則</a></h4>
                            <div id="rfc.section.5.2.1.p.1" class="avoidbreakafter">
                                <p>HTTP/2 のストリームフロー制御は、プロトコルの変更を必要とせずにさまざまなフロー制御アルゴリズムを使用できるように設計されています。HTTP/2
                                    のフロー制御には次の特徴があります：</p>
                            </div>
                            <div id="rfc.section.5.2.1.p.2">
                                <ol type="1">
                                    <li>フロー制御は接続固有です。HTTP/2 フロー制御は単一ホップのエンドポイント間で動作し、エンドツーエンド経路全体ではありません。</li>
                                    <li>フロー制御は <a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">WINDOW_UPDATE</a>
                                        フレームに基づいています。受信者はストリームごとおよび接続全体で受信可能なオクテット数を広告します。これはクレジットベースの方式です。</li>
                                    <li>フロー制御は方向性を持ち、全体的な制御は受信者によって提供されます。受信者は各ストリームおよび接続全体に対して任意のウィンドウサイズを設定できる（<em
                                            class="bcp14">MAY</em>）。送信者は受信者が課したフロー制御制限を遵守しなければなりません（<em
                                            class="bcp14">MUST</em>）。クライアント、サーバー、およびインターミディアリはそれぞれ受信者として自らのフロー制御ウィンドウを広告し、送信時にはピアが設定した制限を守ります。
                                    </li>
                                    <li>新しいストリームおよび接続全体のフロー制御ウィンドウの初期値は 65,535 オクテットです。</li>
                                    <li>フレームタイプがフロー制御を適用するかどうかを決定します。本書で指定されたフレームのうち、フロー制御の対象となるのは <a href="#DATA"
                                            title="DATA">DATA</a>
                                        フレームのみです；他のすべてのフレームタイプは広告されたフロー制御ウィンドウの空間を消費しません。これにより重要な制御フレームがフロー制御によってブロックされないことが保証されます。
                                    </li>
                                    <li>エンドポイントは自分自身のフロー制御を無効にすることを選択できますが、ピアからのフロー制御信号を無視することはできません。</li>
                                    <li>HTTP/2 は <a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">WINDOW_UPDATE</a>
                                        フレームの形式とセマンティクスのみを定義します（<a href="#WINDOW_UPDATE" title="WINDOW_UPDATE">Section
                                            6.9</a>）。受信者がこのフレームをいつ送信するかや、その値をどのように決定するか、送信者がパケット送信をどのように選択するかは規定しません。実装は必要に応じて任意のアルゴリズムを選択できます。
                                    </li>
                                </ol>
                            </div>
                            <div id="rfc.section.5.2.1.p.3">
                                <p>実装者はリクエストやレスポンスの送信優先順位を決め、リクエストのヘッド・オブ・ラインブロッキングを回避する方法を選び、新しいストリームの作成を管理する責任があります。これらのアルゴリズムの選択は任意のフロー制御アルゴリズムと相互作用する可能性があります。
                                </p>
                            </div>
                        </section>
                        <section id="DisableFlowControl">
                            <h4 id="rfc.section.5.2.2"><a href="#rfc.section.5.2.2">5.2.2.</a>&nbsp;<a
                                    href="#DisableFlowControl">フロー制御の適切な使用</a></h4>
                            <div id="rfc.section.5.2.2.p.1">
                                <p>フロー制御は資源制約下で動作するエンドポイントを保護するために定義されています。例えば、プロキシは多数の接続間でメモリを共有する必要があり、上流接続が遅く下流接続が速い場合があります。フロー制御は、受信者があるストリームのデータを処理できないが同じ接続内の他のストリームの処理を継続したいケースを扱います。
                                </p>
                            </div>
                            <div id="rfc.section.5.2.2.p.2">
                                <p>この機能を必要としない展開では、受信側は最大サイズ（2<sup>31</sup>-1）のフロー制御ウィンドウを広告し、データを受信するたびに WINDOW_UPDATE
                                    フレームを送信してこのウィンドウを維持することができます。これはその受信者にとって実質的にフロー制御を無効にすることになります。逆に、送信者は常に受信者が広告したフロー制御ウィンドウの対象となります。
                                </p>
                            </div>
                            <div id="rfc.section.5.2.2.p.3">
                                <p>資源が制約された展開（例えばメモリ）では、フロー制御を利用してピアが消費できるメモリ量を制限できます。ただし、フロー制御が帯域幅×遅延積を考慮せずに有効にされると、利用可能なネットワークリソースの非最適な使用につながる可能性がある点に注意してください（<a
                                        href="#RFC7323"><cite
                                            title="TCP Extensions for High Performance">[RFC7323]</cite></a> を参照）。</p>
                            </div>
                            <div id="rfc.section.5.2.2.p.4">
                                <p>現在の帯域幅×遅延積を完全に把握していたとしても、フロー制御の実装は困難になり得ます。エンドポイントはデータが利用可能になったら直ちに TCP 受信バッファから
                                    HTTP/2
                                    フレームを読み取り処理しなければなりません（<em class="bcp14">MUST</em>）。迅速に読まないと WINDOW_UPDATE
                                    などの重要なフレームが読まれず作用しないことによるデッドロックが発生する可能性があります。フレームを速やかに読むことは、HTTP/2
                                    のフロー制御が資源コミットを制限するため、エンドポイントが資源枯渇攻撃にさらされることを意味しません。</p>
                            </div>
                        </section>
                        <section id="FlowControlPerformance">
                            <h4 id="rfc.section.5.2.3"><a href="#rfc.section.5.2.3">5.2.3.</a>&nbsp;<a
                                    href="#FlowControlPerformance">フロー制御の性能</a></h4>
                            <div id="rfc.section.5.2.3.p.1">
                                <p>エンドポイントがピアが常にこの接続上でピアの帯域幅×遅延積より大きなフロー制御ウィンドウ空間を持つことを保証できない場合、受信スループットは HTTP/2
                                    のフロー制御によって制限され、性能が低下します。</p>
                            </div>
                            <div id="rfc.section.5.2.3.p.2">
                                <p>適時に WINDOW_UPDATE
                                    フレームを送信することで性能は改善できます。エンドポイントは受信スループットの改善と資源枯渇リスクの管理の必要性とのバランスをとる必要があり、ウィンドウサイズ管理戦略を定義する際には
                                    <a href="#dos" title="Denial-of-Service Considerations">Section 10.5</a>
                                    を慎重に考慮するべきです。
                                </p>
                            </div>
                        </section>
                    </section>
                    <section id="StreamPriority">
                        <h3 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3.</a>&nbsp;<a
                                href="#StreamPriority">優先度付け</a></h3>
                        <div id="rfc.section.5.3.p.1">
                            <p>HTTP/2 のような多重化プロトコルでは、ストリームへの帯域幅や計算資源の割り当てに優先順位を付けることが良好な性能を得るために重要です。優先度付けが不適切だと HTTP/2
                                の性能が悪くなる可能性があります。TCP 層で並列性がない場合、性能は HTTP/1.1 よりも著しく悪化する可能性があります。</p>
                        </div>
                        <div id="rfc.section.5.3.p.2">
                            <p>良い優先度付けスキームは、リソースの内容、リソース間の相互関係、それらがピアによってどのように使用されるかといった文脈的知識の適用から恩恵を受けます。特に、クライアントはサーバーの優先度決定に関連するリクエストの優先度に関する知識を持つことがあります。その場合、クライアントが優先度情報を提供することで性能が改善することがあります。
                            </p>
                        </div>
                        <section id="PriorityHistory">
                            <h4 id="rfc.section.5.3.1"><a href="#rfc.section.5.3.1">5.3.1.</a>&nbsp;<a
                                    href="#PriorityHistory">RFC 7540 における優先度の背景</a></h4>
                            <div id="rfc.section.5.3.1.p.1">
                                <p>RFC 7540 はリクエストの優先度をシグナリングするための豊富なシステムを定義しました。しかし、このシステムは複雑であり、一様に実装されることはありませんでした。
                                </p>
                            </div>
                            <div id="rfc.section.5.3.1.p.2">
                                <p>柔軟なスキームのために、クライアントは非常に異なる方法で優先度を表現することが可能であり、採用されたアプローチに一貫性がほとんどありませんでした。サーバーにとって汎用的なサポートを実装することは複雑でした。クライアントとサーバーの両方で優先度の実装は不均一でした。多くのサーバー展開ではリクエストの扱いに際してクライアントのシグナルを無視していました。
                                </p>
                            </div>
                            <div id="rfc.section.5.3.1.p.3">
                                <p>要するに、<a href="#RFC7540"><cite
                                            title="Hypertext Transfer Protocol Version 2 (HTTP/2)">RFC
                                            7540</cite></a> の優先度シグナリングは成功しませんでした。</p>
                            </div>
                        </section>
                        <section id="PriorityHere">
                            <h4 id="rfc.section.5.3.2"><a href="#rfc.section.5.3.2">5.3.2.</a>&nbsp;<a
                                    href="#PriorityHere">本書における優先度シグナリング</a></h4>
                            <div id="rfc.section.5.3.2.p.1">
                                <p>この HTTP/2 の改訂は RFC 7540
                                    で定義された優先度シグナリングを非推奨にします。優先度信号に関連する本文の大部分は本書に含まれていません。フレームフィールドの記述と一部の必須処理は保持されており、本書の実装が
                                    RFC 7540 の優先度シグナリングを使用する実装と相互運用可能であり続けるようにしています。</p>
                            </div>
                            <div id="rfc.section.5.3.2.p.2">
                                <p>RFC 7540 の優先度スキームの詳細な説明は <a
                                        href="https://www.rfc-editor.org/rfc/rfc7540.html#section-5.3">RFC 7540 の
                                        Section
                                        5.3</a> に残されています。</p>
                            </div>
                            <div id="rfc.section.5.3.2.p.3">
                                <p>優先度情報のシグナリングは多くの場合において良好な性能を得るために必要です。優先度情報のシグナリングが重要な場合、エンドポイントは <a
                                        href="#RFC9218"><cite
                                            title="Extensible Prioritization Scheme for HTTP">[HTTP-PRIORITY]</cite></a>
                                    に記載されているような代替スキームの使用を検討することが推奨されます。</p>
                            </div>
                            <div id="rfc.section.5.3.2.p.4">
                                <p>RFC 7540 の優先度シグナリングは広く採用されませんでしたが、それが提供する情報はより良い代替がない場合にまだ有用であり得ます。HEADERS や PRIORITY
                                    フレームで優先度シグナルを受信するエンドポイントは、その情報を適用することで恩恵を受けることができます。特に、これらのシグナルを消すことは代替手段がない場合には恩恵を失うことになります。
                                </p>
                            </div>
                            <div id="rfc.section.5.3.2.p.5">
                                <p>サーバーは優先度シグナルがない場合にリクエストの優先度を決定する際、他の文脈情報を使用するべきです（<em
                                        class="bcp14">SHOULD</em>）。サーバーはシグナルが完全に存在しないことを、クライアントがその機能を実装していないことの指標と解釈してもよい（<em
                                        class="bcp14">MAY</em>）。RFC 7540 のデフォルト（<a
                                        href="https://www.rfc-editor.org/rfc/rfc7540.html#section-5.3.5">Section
                                        5.3.5</a>）はほとんどの条件下で性能が悪いことが知られており、それらを意図的に使用することは考えにくいです。</p>
                            </div>
                        </section>
                    </section>
                    <section id="ErrorHandler">
                        <h3 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4.</a>&nbsp;<a
                                href="#ErrorHandler">エラー処理</a>
                        </h3>
                        <div id="rfc.section.5.4.p.1" class="avoidbreakafter">
                            <p>HTTP/2 フレーミングは二つのクラスのエラーを許容します：</p>
                        </div>
                        <div id="rfc.section.5.4.p.2">
                            <ul>
                                <li>接続全体を使用不能にするエラー条件は接続エラーです。</li>
                                <li>個々のストリームのエラーはストリームエラーです。</li>
                            </ul>
                        </div>
                        <div id="rfc.section.5.4.p.3">
                            <p>エラーコードの一覧は <a href="#ErrorCodes" title="Error Codes">Section 7</a> に含まれています。</p>
                        </div>
                        <div id="rfc.section.5.4.p.4">
                            <p>実装は処理中に複数のエラーを検出することがありますが、実装は報告するストリームエラーは最大で 1 件、接続エラーは最大で 1 件に留めるべきです（<em
                                    class="bcp14">SHOULD</em>）。</p>
                        </div>
                        <div id="rfc.section.5.4.p.5">
                            <p>特定のストリームで報告された最初のストリームエラーは、そのストリームで他のエラーが報告されるのを防ぎます。プロトコルは複数の GOAWAY
                                フレームを許可していますが、エンドポイントは優雅な終了中にエラーが発生した場合を除き、通常は一種類の接続エラーのみを報告するべきです（<em
                                    class="bcp14">SHOULD</em>）。もしそうなった場合、エンドポイントは既存の GOAWAY（NO_ERROR
                                を含むもの）の他に新しいエラーコードを持つ追加の GOAWAY フレームを送信してもよい（<em class="bcp14">MAY</em>）。</p>
                        </div>
                        <div id="rfc.section.5.4.p.6">
                            <p>エンドポイントが複数の異なるエラーを検出した場合、任意の一つのエラーを報告することができます（<em
                                    class="bcp14">MAY</em>）。フレームが接続エラーを引き起こす場合、そのエラーは必ず報告されなければなりません（<em
                                    class="bcp14">MUST</em>）。さらに、エンドポイントは適用可能な任意のエラーコードを使用できます；一般的なエラーコード（PROTOCOL_ERROR
                                や
                                INTERNAL_ERROR など）は、より具体的なエラーコードの代わりに常に使用できます。</p>
                        </div>
                        <section id="ConnectionErrorHandler">
                            <h4 id="rfc.section.5.4.1"><a href="#rfc.section.5.4.1">5.4.1.</a>&nbsp;<a
                                    href="#ConnectionErrorHandler">接続エラー処理</a></h4>
                            <div id="rfc.section.5.4.1.p.1">
                                <p>接続エラーとは、フレーム層のさらなる処理を阻止するか、接続状態を破壊する任意のエラーです。</p>
                            </div>
                            <div id="rfc.section.5.4.1.p.2">
                                <p>接続エラーを検出したエンドポイントは、最初にピアから正常に受信した最後のストリーム識別子を含む <a href="#GOAWAY"
                                        title="GOAWAY">GOAWAY</a> フレーム（<a href="#GOAWAY" title="GOAWAY">Section
                                        6.8</a>）を送信することが望ましい（<em class="bcp14">SHOULD</em>）。GOAWAY
                                    フレームには接続を終了する理由を示すエラーコード（<a href="#ErrorCodes" title="Error Codes">Section
                                        7</a>）が含まれます。エラー条件のために GOAWAY を送信した後、エンドポイントは TCP 接続を閉じなければなりません（<em
                                        class="bcp14">MUST</em>）。</p>
                            </div>
                            <div id="rfc.section.5.4.1.p.3">
                                <p>GOAWAY が受信側に確実に届かない可能性があることに注意してください。接続エラーの場合、GOAWAY
                                    は接続を終了する理由をピアに伝える最善の試みを提供するに過ぎません。
                                </p>
                            </div>
                            <div id="rfc.section.5.4.1.p.4">
                                <p>エンドポイントはいつでも接続を終了できます。特に、エンドポイントはストリームエラーを接続エラーと見なすことができます（<em
                                        class="bcp14">MAY</em>）。状況が許せば、エンドポイントは接続を終了するときに GOAWAY フレームを送信するべきです（<em
                                        class="bcp14">SHOULD</em>）。</p>
                            </div>
                        </section>
                        <section id="StreamErrorHandler">
                            <h4 id="rfc.section.5.4.2"><a href="#rfc.section.5.4.2">5.4.2.</a>&nbsp;<a
                                    href="#StreamErrorHandler">ストリームエラー処理</a></h4>
                            <div id="rfc.section.5.4.2.p.1">
                                <p>ストリームエラーとは、他のストリームの処理には影響しない特定のストリームに関連するエラーです。</p>
                            </div>
                            <div id="rfc.section.5.4.2.p.2">
                                <p>ストリームエラーを検出したエンドポイントは、エラーが発生したストリームの識別子を含む <a href="#RST_STREAM"
                                        title="RST_STREAM">RST_STREAM</a> フレームを送信します（<a href="#RST_STREAM"
                                        title="RST_STREAM">Section 6.4</a>）。RST_STREAM フレームにはエラーの種類を示すエラーコードが含まれます。</p>
                            </div>
                            <div id="rfc.section.5.4.2.p.3">
                                <p>RST_STREAM はエンドポイントがストリーム上で送信できる最後のフレームです。RST_STREAM
                                    を送信するピアは、リモートピアが送信したか送信キューに入れたフレームを受信する準備をしていなければなりません。これらのフレームは、フィールドセクション圧縮やフロー制御のような接続状態を変更しない限り無視できます。
                                </p>
                            </div>
                            <div id="rfc.section.5.4.2.p.4">
                                <p>通常、エンドポイントは任意のストリームに対して RST_STREAM を複数回送信すべきではありません（<em class="bcp14">SHOULD
                                        NOT</em>）。しかし、閉じたストリーム上でラウンドトリップ時間を超えてフレームを受信した場合には追加の RST_STREAM を送信してもよい（<em
                                        class="bcp14">MAY</em>）。この挙動は不正な実装に対処するために許可されています。</p>
                            </div>
                            <div id="rfc.section.5.4.2.p.5">
                                <p>ループを避けるために、エンドポイントは RST_STREAM に対して RST_STREAM で応答してはなりません（<em class="bcp14">MUST
                                        NOT</em>）。</p>
                            </div>
                        </section>
                        <section id="n-connection-termination">
                            <h4 id="rfc.section.5.4.3"><a href="#rfc.section.5.4.3">5.4.3.</a>&nbsp;<a
                                    href="#n-connection-termination">接続の終了</a></h4>
                            <div id="rfc.section.5.4.3.p.1">
                                <p>TCP 接続が閉じられたりリセットされたりしている間にストリームが "open" または "half-closed"
                                    の状態にある場合、影響を受けたストリームは自動的に再試行できません（詳細は <a href="#Reliability"
                                        title="Request Reliability">Section 8.7</a> を参照）。</p>
                            </div>
                        </section>
                    </section>
                    <section id="extensibility">
                        <h3 id="rfc.section.5.5"><a href="#rfc.section.5.5">5.5.</a>&nbsp;<a
                                href="#extensibility">HTTP/2
                                の拡張</a></h3>
                        <div id="rfc.section.5.5.p.1">
                            <p>HTTP/2
                                はプロトコルの拡張を許可します。本節で述べる制限内で、プロトコル拡張は追加のサービスを提供したりプロトコルのあらゆる側面を変更したりするために使用できます。拡張は単一の
                                HTTP/2 接続の範囲内でのみ有効です。</p>
                        </div>
                        <div id="rfc.section.5.5.p.2">
                            <p>これは本書で定義されたプロトコル要素に適用されます。これは新しいメソッド、ステータスコード、またはフィールドを定義するなど既存の HTTP
                                拡張オプションに影響を与えるものではありません（詳細は <a
                                    href="https://www.rfc-editor.org/rfc/rfc9110.html#section-16">Section 16</a> を参照）。
                            </p>
                        </div>
                        <div id="rfc.section.5.5.p.3">
                            <p>拡張は新しいフレームタイプ（<a href="#FrameHeader" title="Frame Format">Section 4.1</a>）、新しい設定（<a
                                    href="#SETTINGS" title="SETTINGS">Section 6.5</a>）、または新しいエラーコード（<a
                                    href="#ErrorCodes" title="Error Codes">Section
                                    7</a>）を使用することができます。これら拡張ポイントを管理するためのレジストリは <a
                                    href="https://www.rfc-editor.org/rfc/rfc7540.html#section-11">RFC 7540 の Section
                                    11</a>
                                に定義されています。</p>
                        </div>
                        <div id="rfc.section.5.5.p.4">
                            <p>実装はすべての拡張可能なプロトコル要素において未知またはサポートされない値を無視しなければなりません（<em
                                    class="bcp14">MUST</em>）。実装は未知またはサポートされない型のフレームを破棄しなければなりません（<em
                                    class="bcp14">MUST</em>）。これは、これらの拡張ポイントが事前の取り決めやネゴシエーションなしに拡張によって安全に使用できることを意味します。しかし、フィールドブロックの途中に現れる拡張フレームは許可されません；それらは接続エラー（<a
                                    href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>）の
                                PROTOCOL_ERROR として扱われなければなりません（<em class="bcp14">MUST</em>）。</p>
                        </div>
                        <div id="rfc.section.5.5.p.5">
                            <p>拡張は本書で定義されたプロトコル要素や拡張機構が定義されていない要素を変更することを避けるべきです（<em
                                    class="bcp14">SHOULD</em>）。これにはフレームのレイアウトの変更、フレームが HTTP メッセージにどのように構成されるかの追加または変更（<a
                                    href="#HttpFraming" title="HTTP Message Framing">Section
                                    8.1</a>）、擬似ヘッダーフィールドの定義、または準拠エンドポイントが接続エラー（<a href="#ConnectionErrorHandler"
                                    title="Connection Error Handling">Section 5.4.1</a>）と見なす可能性のあるあらゆるプロトコル要素の変更が含まれます。
                            </p>
                        </div>
                        <div id="rfc.section.5.5.p.6">
                            <p>既存のプロトコル要素や状態を変更する拡張は、使用される前にネゴシエートされなければなりません（<em class="bcp14">MUST</em>）。例えば、HEADERS
                                フレームのレイアウトを変更する拡張は、ピアがそれを受け入れることを肯定的に示すまでは使用できません。この場合、改訂されたレイアウトがいつ有効になるかを調整する必要があるかもしれません。例えば
                                DATA 以外のフレームをフロー制御の対象とすることは双方の理解を必要とする意味の変更を伴うため、ネゴシエーションを通じてのみ可能です。</p>
                        </div>
                        <div id="rfc.section.5.5.p.7">
                            <p>本書は拡張の使用をネゴシエートする特定の方法を義務付けていませんが、設定（<a href="#SettingValues"
                                    title="Defined Settings">Section
                                    6.5.2</a>）がその目的に使用できることを指摘します。もし両ピアが拡張の使用を示す値を設定した場合、拡張は使用可能になります。設定が拡張ネゴシエーションに使用される場合、初期値は拡張が最初は無効になるように定義されなければなりません（<em
                                    class="bcp14">MUST</em>）。</p>
                        </div>
                    </section>
                </section>
                <hr class="hidden-print">
                <section id="FrameTypes">
                    <h2 id="rfc.section.6" class="np"><a href="#rfc.section.6">6.</a>&nbsp;<a
                            href="#FrameTypes">フレーム定義</a>
                    </h2>
                    <div id="rfc.section.6.p.1">
                        <p>本仕様は多数のフレームタイプを定義しており、それぞれ一意の 8
                            ビットのタイプコードで識別されます。各フレームタイプは接続全体または個々のストリームの確立および管理において異なる役割を果たします。</p>
                    </div>
                    <div id="rfc.section.6.p.2">
                        <p>特定のフレームタイプの送受信は接続の状態を変化させることがあります。エンドポイントが接続状態を同期して保持できない場合、接続内での正常な通信は不可能になります。したがって、エンドポイントは任意のフレームの使用によって状態がどのように影響を受けるかを共有して理解していることが重要です。
                        </p>
                    </div>
                    <section id="DATA">
                        <h3 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a>&nbsp;<a href="#DATA">DATA</a></h3>
                        <div id="rfc.section.6.1.p.1">
                            <p>DATA フレーム（type=0x00）は、ストリームに関連する任意の可変長オクテット列を運びます。例えば、HTTP のリクエストまたはレスポンスのメッセージ本文を運ぶために 1
                                個以上の DATA フレームが使用されます。</p>
                        </div>
                        <div id="rfc.section.6.1.p.2">
                            <p>DATA フレームはパディングを含めることが <em class="bcp14">MAY</em> あります。パディングはメッセージのサイズを隠すために DATA
                                フレームへ追加できます。パディングはセキュリティ機能です（詳細は <a href="#padding" title="Use of Padding">Section
                                    10.7</a>
                                を参照）。</p>
                        </div>
                        <div id="DATAFrameFormat"></div>
                        <div id="rfc.figure.3">
                            <div>
                                <pre class="inline">
DATA Frame {
  Length (24),
  Type (8) = 0x00,

  Unused Flags (4),
  PADDED Flag (1),
  Unused Flags (2),
  END_STREAM Flag (1),

  Reserved (1),
  Stream Identifier (31),

  [Pad Length (8)],
  Data (..),
  Padding (..2040),
}
</pre>
                            </div>
                        </div>
                        <p class="figure">図 3: DATA フレーム形式</p>
                        <div id="rfc.section.6.1.p.3" class="avoidbreakafter">
                            <p>Length、Type、Unused Flag(s)、Reserved、および Stream Identifier フィールドは <a href="#FramingLayer"
                                    title="HTTP Frames">Section 4</a> に記述されています。DATA フレームは次の追加フィールドを含みます：</p>
                        </div>
                        <div id="rfc.section.6.1.p.4">
                            <dl>
                                <dt>Pad Length:</dt>
                                <dd style="margin-left: 1.5em">フレームパディングの長さ（オクテット単位）を含む 8 ビットフィールド。これは PADDED
                                    フラグが設定されている場合にのみ存在します。</dd>
                                <dt>Data:</dt>
                                <dd style="margin-left: 1.5em">アプリケーションデータ。データの量は、存在する他のフィールドの長さを差し引いたフレームペイロードの残りです。
                                </dd>
                                <dt>Padding:</dt>
                                <dd style="margin-left: 1.5em">
                                    アプリケーション的な意味を持たないパディングオクテット。送信時、パディングオクテットはゼロに設定されなければなりません（<em
                                        class="bcp14">MUST</em>）。受信者はパディングを検証する義務はありませんが、非ゼロのパディングを <a
                                        href="#ConnectionErrorHandler" title="Connection Error Handling">Section
                                        5.4.1</a>
                                    の種類の接続エラー（<a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>）として扱うことが <em
                                        class="bcp14">MAY</em> あります。</dd>
                            </dl>
                        </div>
                        <div id="rfc.section.6.1.p.5" class="avoidbreakafter">
                            <p>DATA フレームは以下のフラグを定義します：</p>
                        </div>
                        <div id="rfc.section.6.1.p.6">
                            <dl>
                                <dt>PADDED (0x08):</dt>
                                <dd style="margin-left: 1.5em">設定されていると、PADDED フラグは Pad Length
                                    フィールドとそれが示すパディングが存在することを示します。
                                </dd>
                                <dt>END_STREAM (0x01):</dt>
                                <dd style="margin-left: 1.5em">設定されていると、END_STREAM
                                    フラグはこのフレームが識別されたストリームに関して送信者が送る最後のフレームであることを示します。このフラグの設定はストリームを「半クローズ」状態または「クローズ」状態に遷移させます（<a
                                        href="#StreamStates" title="Stream States">Section 5.1</a>）。</dd>
                            </dl>
                        </div>
                        <div id="rfc.section.6.1.p.7">
                            <aside>
                                <div id="rfc.section.6.1.p.7.1">
                                    <p>注：すべてのデータを送信した後にストリームのクローズを知ったエンドポイントは、ゼロ長の Data フィールドと END_STREAM フラグを持つ DATA
                                        フレームを送信してストリームを閉じることができます。これはトレーラを送信しない場合にのみ可能です。トレーラを送信する場合、END_STREAM フラグは
                                        HEADERS
                                        フレーム上に現れます（詳細は <a href="#HttpFraming" title="HTTP Message Framing">Section
                                            8.1</a>
                                        を参照）。</p>
                                </div>
                            </aside>
                        </div>
                        <div id="rfc.section.6.1.p.8">
                            <p>DATA フレームはストリームに関連付けられていることが <em class="bcp14">MUST</em> です。Stream Identifier フィールドが 0x00
                                の
                                DATA フレームを受信した場合、受信者は <a href="#ConnectionErrorHandler"
                                    title="Connection Error Handling">Section 5.4.1</a> の種類の接続エラー（<a
                                    href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>）で応答しなければなりません。</p>
                        </div>
                        <div id="rfc.section.6.1.p.9">
                            <p>DATA フレームはフロー制御の対象であり、ストリームが "open" または "half-closed (remote)"
                                の状態にあるときにのみ送信できます。フレームペイロード全体（Pad Length および Padding フィールドを含む）はフロー制御の対象です。ストリームが "open"
                                または
                                "half-closed (local)" でないストリームに対する DATA フレームを受信した場合、受信者は <a href="#StreamErrorHandler"
                                    title="Stream Error Handling">Section 5.4.2</a> の種類のストリームエラー（<a
                                    href="#STREAM_CLOSED">STREAM_CLOSED</a>）で応答しなければなりません。</p>
                        </div>
                        <div id="rfc.section.6.1.p.10">
                            <p>パディングオクテットの総数は Pad Length フィールドの値により決まります。パディングの長さがフレームペイロードの長さ以上である場合、受信者はこれを <a
                                    href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>
                                の種類の接続エラー（<a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>）として扱わなければなりません。</p>
                        </div>
                        <div id="rfc.section.6.1.p.11">
                            <aside>
                                <div id="rfc.section.6.1.p.11.1">
                                    <p>注：Pad Length フィールドにゼロを含めることで、フレームのサイズを 1 オクテット増やすことができます。</p>
                                </div>
                            </aside>
                        </div>
                    </section>
                    <section id="HEADERS">
                        <h3 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a>&nbsp;<a href="#HEADERS">HEADERS</a>
                        </h3>
                        <div id="rfc.section.6.2.p.1">
                            <p>HEADERS フレーム（type=0x01）はストリームをオープンするために使用され（<a href="#StreamStates"
                                    title="Stream States">Section 5.1</a>）、フィールドブロックのフラグメントも運びます。名称に反して、HEADERS
                                フレームはヘッダセクションまたはトレーラセクションのいずれも運ぶことができます。HEADERS フレームは "idle"、"reserved
                                (local)"、"open"、または
                                "half-closed (remote)" の状態にあるストリーム上で送信できます。</p>
                        </div>
                        <div id="HEADERSFrameFormat"></div>
                        <div id="rfc.figure.4">
                            <div>
                                <pre class="inline">
HEADERS Frame {
  Length (24),
  Type (8) = 0x01,

  Unused Flags (2),
  PRIORITY Flag (1),
  Unused Flag (1),
  PADDED Flag (1),
  END_HEADERS Flag (1),
  Unused Flag (1),
  END_STREAM Flag (1),

  Reserved (1),
  Stream Identifier (31),

  [Pad Length (8)],
  [Exclusive (1)],
  [Stream Dependency (31)],
  [Weight (8)],
  Field Block Fragment (..),
  Padding (..2040),
}
</pre>
                            </div>
                        </div>
                        <p class="figure">図 4: HEADERS フレーム形式</p>
                        <div id="rfc.section.6.2.p.2" class="avoidbreakafter">
                            <p>Length、Type、Unused Flag(s)、Reserved、および Stream Identifier フィールドは <a href="#FramingLayer"
                                    title="HTTP Frames">Section 4</a> に記述されています。HEADERS フレームのペイロードは次の追加フィールドを持ちます：</p>
                        </div>
                        <div id="rfc.section.6.2.p.3">
                            <dl>
                                <dt>Pad Length:</dt>
                                <dd style="margin-left: 1.5em">フレームパディングの長さ（オクテット単位）を含む 8 ビットフィールド。PADDED
                                    フラグが設定されている場合にのみ存在します。</dd>
                                <dt>Exclusive:</dt>
                                <dd style="margin-left: 1.5em">単一ビットのフラグ。これは PRIORITY フラグが設定されている場合にのみ存在します。HEADERS
                                    フレームでの優先度シグナルは非推奨です（詳細は <a href="#PriorityHere"
                                        title="Priority Signaling in This Document">Section 5.3.2</a> を参照）。</dd>
                                <dt>Stream Dependency:</dt>
                                <dd style="margin-left: 1.5em">31 ビットのストリーム識別子。これは PRIORITY フラグが設定されている場合にのみ存在します。</dd>
                                <dt>Weight:</dt>
                                <dd style="margin-left: 1.5em">符号なし 8 ビット整数。これは PRIORITY フラグが設定されている場合にのみ存在します。</dd>
                                <dt>Field Block Fragment:</dt>
                                <dd style="margin-left: 1.5em">フィールドブロックのフラグメント（<a href="#FieldBlock"
                                        title="Field Section Compression and Decompression">Section 4.3</a>）。</dd>
                                <dt>Padding:</dt>
                                <dd style="margin-left: 1.5em">アプリケーション的意味を持たないパディングオクテット。送信時にパディングはゼロに設定されなければなりません（<em
                                        class="bcp14">MUST</em>）。受信者は検証義務を負いませんが、非ゼロのパディングを接続エラー（<a
                                        href="#ConnectionErrorHandler" title="Connection Error Handling">Section
                                        5.4.1</a>）の
                                    <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a> として扱うことが <em class="bcp14">MAY</em>
                                    あります。
                                </dd>
                            </dl>
                        </div>
                        <div id="rfc.section.6.2.p.4" class="avoidbreakafter">
                            <p>HEADERS フレームは以下のフラグを定義します：</p>
                        </div>
                        <div id="rfc.section.6.2.p.5">
                            <dl>
                                <dt>PRIORITY (0x20):</dt>
                                <dd style="margin-left: 1.5em">
                                    <div>設定されていると、PRIORITY フラグは Exclusive、Stream Dependency、および Weight
                                        フィールドが存在することを示します。
                                    </div>
                                </dd>
                                <dt>PADDED (0x08):</dt>
                                <dd style="margin-left: 1.5em">
                                    <div>設定されていると、PADDED フラグは Pad Length フィールドとそれが示すパディングが存在することを示します。</div>
                                </dd>
                                <dt>END_HEADERS (0x04):</dt>
                                <dd style="margin-left: 1.5em">
                                    <div>設定されていると、END_HEADERS フラグはこのフレームが完全なフィールドブロック（<a href="#FieldBlock"
                                            title="Field Section Compression and Decompression">Section
                                            4.3</a>）を含み、同じストリームに続く CONTINUATION フレームがないことを示します。</div>
                                    <div>END_HEADERS フラグが設定されていない HEADERS フレームは同じストリームの CONTINUATION
                                        フレームで続かなければなりません（<em
                                            class="bcp14">MUST</em>）。受信者は他の型のフレームや別のストリームのフレームを受信した場合、それを接続エラー（<a
                                            href="#ConnectionErrorHandler" title="Connection Error Handling">Section
                                            5.4.1</a>）の <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a> と扱わなければなりません。</div>
                                </dd>
                                <dt>END_STREAM (0x01):</dt>
                                <dd style="margin-left: 1.5em">
                                    <div>設定されていると、END_STREAM フラグはこのフィールドブロック（<a href="#FieldBlock"
                                            title="Field Section Compression and Decompression">Section
                                            4.3</a>）が識別されたストリームに関して送信者が送る最後のものであることを示します。</div>
                                    <div>END_STREAM フラグが設定された HEADERS フレームはストリームの終了を示します。ただし、END_STREAM が設定された HEADERS
                                        フレームの後に同じストリーム上で CONTINUATION フレームが続くことがあり得ます。論理的には CONTINUATION フレームは HEADERS
                                        フレームの一部です。</div>
                                </dd>
                            </dl>
                        </div>
                        <div id="rfc.section.6.2.p.6">
                            <p>HEADERS フレームのフレームペイロードはフィールドブロックのフラグメントを含みます（<a href="#FieldBlock"
                                    title="Field Section Compression and Decompression">Section 4.3</a>）。フィールドブロックが
                                HEADERS
                                フレームに収まらない場合、CONTINUATION フレームで継続されます（<a href="#CONTINUATION"
                                    title="CONTINUATION">Section
                                    6.10</a>）。</p>
                        </div>
                        <div id="rfc.section.6.2.p.7">
                            <p>HEADERS フレームはストリームに関連付けられていることが <em class="bcp14">MUST</em> です。Stream Identifier フィールドが
                                0x00
                                の HEADERS フレームを受信した場合、受信者は <a href="#ConnectionErrorHandler"
                                    title="Connection Error Handling">Section 5.4.1</a> の種類の接続エラー（<a
                                    href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>）で応答しなければなりません。</p>
                        </div>
                        <div id="rfc.section.6.2.p.8">
                            <p>HEADERS フレームは <a href="#FieldBlock"
                                    title="Field Section Compression and Decompression">Section 4.3</a>
                                に記述されたとおり接続状態を変更します。
                            </p>
                        </div>
                        <div id="rfc.section.6.2.p.9">
                            <p>パディングオクテットの総数は Pad Length フィールドの値により決まります。パディングの長さがフレームペイロードの長さ以上である場合、受信者はこれを <a
                                    href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>
                                の種類の接続エラー（<a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>）として扱わなければなりません。</p>
                        </div>
                        <div id="rfc.section.6.2.p.10">
                            <aside>
                                <div id="rfc.section.6.2.p.10.1">
                                    <p>注：Pad Length フィールドにゼロを含めることで、フレームのサイズを 1 オクテット増やすことができます。</p>
                                </div>
                            </aside>
                        </div>
                    </section>
                    <section id="PRIORITY">
                        <h3 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a>&nbsp;<a
                                href="#PRIORITY">PRIORITY</a>
                        </h3>
                        <div id="rfc.section.6.3.p.1">
                            <p>PRIORITY フレーム（type=0x02）は非推奨です（参照：<a href="#PriorityHere"
                                    title="Priority Signaling in This Document">Section 5.3.2</a>）。PRIORITY
                                フレームは任意のストリーム状態で送信可能で、idle や closed のストリームでも送信できます。</p>
                        </div>
                        <div id="PRIORITYFrameFormat"></div>
                        <div id="rfc.figure.5">
                            <div>
                                <pre class="inline">
PRIORITY Frame {
  Length (24) = 0x05,
  Type (8) = 0x02,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Exclusive (1),
  Stream Dependency (31),
  Weight (8),
}
</pre>
                            </div>
                        </div>
                        <p class="figure">図 5: PRIORITY フレーム形式</p>
                        <div id="rfc.section.6.3.p.2" class="avoidbreakafter">
                            <p>Length、Type、Unused Flag(s)、Reserved、および Stream Identifier フィールドは <a href="#FramingLayer"
                                    title="HTTP Frames">Section 4</a> に記述されています。PRIORITY フレームのペイロードは次の追加フィールドを含みます：</p>
                        </div>
                        <div id="rfc.section.6.3.p.3">
                            <dl>
                                <dt>Exclusive:</dt>
                                <dd style="margin-left: 1.5em">単一ビットのフラグ。</dd>
                                <dt>Stream Dependency:</dt>
                                <dd style="margin-left: 1.5em">31 ビットのストリーム識別子。</dd>
                                <dt>Weight:</dt>
                                <dd style="margin-left: 1.5em">符号なし 8 ビット整数。</dd>
                            </dl>
                        </div>
                        <div id="rfc.section.6.3.p.4">
                            <p>PRIORITY フレームはフラグを定義しません。</p>
                        </div>
                        <div id="rfc.section.6.3.p.5">
                            <p>PRIORITY フレームは常にストリームを識別します。Stream Identifier が 0x00 の PRIORITY フレームを受信した場合、受信者は <a
                                    href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>
                                の種類の接続エラー（<a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>）で応答しなければなりません。</p>
                        </div>
                        <div id="rfc.section.6.3.p.6">
                            <p>PRIORITY フレームの送受信は任意のストリームの状態に影響を与えません（<a href="#StreamStates"
                                    title="Stream States">Section
                                    5.1</a>）。PRIORITY フレームは "idle" や "closed" を含む任意の状態のストリーム上で送信できます。PRIORITY
                                フレームは単一のフィールドブロックを構成する連続したフレーム間で送信してはなりません（<a href="#FieldBlock"
                                    title="Field Section Compression and Decompression">Section 4.3</a>）。</p>
                        </div>
                        <div id="rfc.section.6.3.p.7">
                            <p>長さが 5 オクテットでない PRIORITY フレームは、ストリームエラー（<a href="#StreamErrorHandler"
                                    title="Stream Error Handling">Section 5.4.2</a>）の <a
                                    href="#FRAME_SIZE_ERROR">FRAME_SIZE_ERROR</a> として扱われなければなりません（<em
                                    class="bcp14">MUST</em>）。</p>
                        </div>
                    </section>
                    <section id="RST_STREAM">
                        <h3 id="rfc.section.6.4"><a href="#rfc.section.6.4">6.4.</a>&nbsp;<a
                                href="#RST_STREAM">RST_STREAM</a></h3>
                        <div id="rfc.section.6.4.p.1">
                            <p>RST_STREAM フレーム（type=0x03）はストリームを即時に終了させるためのものです。RST_STREAM
                                はストリームのキャンセルを要求するため、またはエラー条件が発生したことを示すために送信されます。</p>
                        </div>
                        <div id="RST_STREAMFrameFormat"></div>
                        <div id="rfc.figure.6">
                            <div>
                                <pre class="inline">
RST_STREAM Frame {
  Length (24) = 0x04,
  Type (8) = 0x03,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Error Code (32),
}
</pre>
                            </div>
                        </div>
                        <p class="figure">図 6: RST_STREAM フレーム形式</p>
                        <div id="rfc.section.6.4.p.2">
                            <p>Length、Type、Unused Flag(s)、Reserved、および Stream Identifier フィールドは <a href="#FramingLayer"
                                    title="HTTP Frames">Section 4</a> に記述されています。加えて、RST_STREAM フレームはエラーコードを示す 32
                                ビット符号なし整数を
                                1 つ含みます（<a href="#ErrorCodes" title="Error Codes">Section
                                    7</a>）。このエラーコードはストリームが終了される理由を示します。</p>
                        </div>
                        <div id="rfc.section.6.4.p.3">
                            <p>RST_STREAM フレームはフラグを定義しません。</p>
                        </div>
                        <div id="rfc.section.6.4.p.4">
                            <p>RST_STREAM フレームは参照されたストリームを完全に終了させ、「closed」状態にします。ストリームで RST_STREAM
                                を受信した後、受信者はそのストリームに対して追加のフレームを送信してはなりません（<em class="bcp14">MUST NOT</em>）、ただし <a
                                    href="#PRIORITY" title="PRIORITY">PRIORITY</a> は例外です。しかし、RST_STREAM を送信した後、送信側は
                                RST_STREAM 到着前にピアが既に送信したか送信キューに入れている可能性のある追加フレームを受信して処理する準備を <em class="bcp14">MUST</em>
                                しておかなければなりません。</p>
                        </div>
                        <div id="rfc.section.6.4.p.5">
                            <p>RST_STREAM フレームはストリームに関連付けられていることが <em class="bcp14">MUST</em> です。Stream Identifier が
                                0x00 の
                                RST_STREAM フレームを受信した場合、受信者は <a href="#ConnectionErrorHandler"
                                    title="Connection Error Handling">Section 5.4.1</a> の種類の接続エラー（<a
                                    href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>）として扱わなければなりません。</p>
                        </div>
                        <div id="rfc.section.6.4.p.6">
                            <p>RST_STREAM フレームは "idle" 状態のストリームに対して送信してはなりません（<em class="bcp14">MUST NOT</em>）。"idle"
                                ストリームを識別する RST_STREAM を受信した場合、受信者は <a href="#ConnectionErrorHandler"
                                    title="Connection Error Handling">Section 5.4.1</a> の種類の接続エラー（<a
                                    href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>）として扱わなければなりません。</p>
                        </div>
                        <div id="rfc.section.6.4.p.7">
                            <p>長さが 4 オクテットでない RST_STREAM フレームは <a href="#ConnectionErrorHandler"
                                    title="Connection Error Handling">Section 5.4.1</a> の種類の接続エラー（<a
                                    href="#FRAME_SIZE_ERROR">FRAME_SIZE_ERROR</a>）として扱われなければなりません。</p>
                        </div>
                    </section>
                    <section id="SETTINGS">
                        <h3 id="rfc.section.6.5"><a href="#rfc.section.6.5">6.5.</a>&nbsp;<a
                                href="#SETTINGS">SETTINGS</a>
                        </h3>
                        <div id="rfc.section.6.5.p.1">
                            <p>SETTINGS フレーム（type=0x04）は、ピアの振る舞いに関する好みや制約など、エンドポイント間の通信に影響を与える構成パラメータを伝達します。SETTINGS
                                フレームはそれらの設定の受領を確認するためにも使用されます。SETTINGS フレーム内の個々の構成パラメータは「setting」と呼ばれます。</p>
                        </div>
                        <div id="rfc.section.6.5.p.2">
                            <p>設定は交渉されるものではなく、送信ピアの特性を記述して受信ピアが利用します。同じ設定に対して各ピアが異なる値を広告することができます。例えば、クライアントは高い初期フロー制御ウィンドウを設定するかもしれませんが、サーバーは資源を節約するためにより低い値を設定することがあります。
                            </p>
                        </div>
                        <div id="rfc.section.6.5.p.3">
                            <p>接続開始時に両端点が SETTINGS フレームを <em class="bcp14">MUST</em> 送信し、接続の有効期間中いつでも任意の時点でいずれのエンドポイントも
                                SETTINGS フレームを送信することが <em class="bcp14">MAY</em>
                                あります。実装は本仕様で定義されたすべての設定をサポートしなければなりません（<em class="bcp14">MUST</em>）。</p>
                        </div>
                        <div id="rfc.section.6.5.p.4">
                            <p>SETTINGS フレーム内の各パラメータはそのパラメータの既存の値を置き換えます。設定は出現順に処理され、SETTINGS
                                フレームの受信者は各設定の現在値以外の状態を保持する必要はありません。したがって、SETTINGS パラメータの値は受信者が最後に見た値となります。</p>
                        </div>
                        <div id="rfc.section.6.5.p.5" class="avoidbreakafter">
                            <p>SETTINGS フレームは受信ピアによって確認されます。これを可能にするために、SETTINGS フレームは ACK フラグを定義します：</p>
                        </div>
                        <div id="rfc.section.6.5.p.6">
                            <dl>
                                <dt>ACK (0x01):</dt>
                                <dd style="margin-left: 1.5em">設定されていると、このフレームがピアの SETTINGS
                                    フレームの受領と適用を確認することを示します。このビットが設定されている場合、SETTINGS フレームのフレームペイロードは <em
                                        class="bcp14">MUST</em> 空でなければなりません。ACK フラグが設定されており長さフィールド値が 0 でない SETTINGS
                                    フレームの受信は、<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section
                                        5.4.1</a> の種類の接続エラー（<a
                                        href="#FRAME_SIZE_ERROR">FRAME_SIZE_ERROR</a>）として扱われなければなりません。詳細は <a
                                        href="#SettingsSync" title="Settings Synchronization">Section 6.5.3</a>
                                    を参照してください（「Settings Synchronization」）。</dd>
                            </dl>
                        </div>
                        <div id="rfc.section.6.5.p.7">
                            <p>SETTINGS フレームは常に接続に適用され、単一のストリームには適用されません。SETTINGS フレームの Stream Identifier フィールドは 0x00
                                でなければなりません（<em class="bcp14">MUST</em>）。Stream Identifier が 0x00 でない SETTINGS
                                フレームを受信した場合、受信者は <a href="#ConnectionErrorHandler"
                                    title="Connection Error Handling">Section
                                    5.4.1</a> の種類の接続エラー（<a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>）で応答しなければなりません。</p>
                        </div>
                        <div id="rfc.section.6.5.p.8">
                            <p>SETTINGS フレームは接続状態に影響します。不正に形成されたまたは不完全な SETTINGS フレームは <a href="#ConnectionErrorHandler"
                                    title="Connection Error Handling">Section 5.4.1</a> の種類の接続エラー（<a
                                    href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>）として扱われなければなりません。</p>
                        </div>
                        <div id="rfc.section.6.5.p.9">
                            <p>長さが 6 オクテットの倍数でない SETTINGS フレームは <a href="#ConnectionErrorHandler"
                                    title="Connection Error Handling">Section 5.4.1</a> の種類の接続エラー（<a
                                    href="#FRAME_SIZE_ERROR">FRAME_SIZE_ERROR</a>）として扱われなければなりません。</p>
                        </div>
                        <section id="SettingFormat">
                            <h4 id="rfc.section.6.5.1"><a href="#rfc.section.6.5.1">6.5.1.</a>&nbsp;<a
                                    href="#SettingFormat">SETTINGS 形式</a></h4>
                            <div id="rfc.section.6.5.1.p.1">
                                <p>SETTINGS フレームのフレームペイロードはゼロ個以上の設定で構成され、各設定は符号なし 16 ビットの設定識別子と符号なし 32 ビットの値から成ります。</p>
                            </div>
                            <div id="SettingFrameFormat"></div>
                            <div id="rfc.figure.7">
                                <div>
                                    <pre class="inline">
SETTINGS Frame {
  Length (24),
  Type (8) = 0x04,

  Unused Flags (7),
  ACK Flag (1),

  Reserved (1),
  Stream Identifier (31) = 0,

  Setting (48) ...,
}

Setting {
  Identifier (16),
  Value (32),
}
</pre>
                                </div>
                            </div>
                            <p class="figure">図 7: SETTINGS フレーム形式</p>
                            <div id="rfc.section.6.5.1.p.2" class="avoidbreakafter">
                                <p>Length、Type、Unused Flag(s)、Reserved、および Stream Identifier フィールドは <a
                                        href="#FramingLayer" title="HTTP Frames">Section 4</a> に記載されています。SETTINGS
                                    フレームのペイロードは任意個の Setting
                                    フィールドを含み、各フィールドは次の要素で構成されます：</p>
                            </div>
                            <div id="rfc.section.6.5.1.p.3">
                                <dl>
                                    <dt>Identifier:</dt>
                                    <dd style="margin-left: 1.5em">16 ビットの設定識別子（定義は <a href="#SettingValues"
                                            title="Defined Settings">Section 6.5.2</a> を参照）。</dd>
                                    <dt>Value:</dt>
                                    <dd style="margin-left: 1.5em">その設定の 32 ビット値。</dd>
                                </dl>
                            </div>
                        </section>
                        <section id="SettingValues">
                            <h4 id="rfc.section.6.5.2"><a href="#rfc.section.6.5.2">6.5.2.</a>&nbsp;<a
                                    href="#SettingValues">定義された設定</a></h4>
                            <div id="rfc.section.6.5.2.p.1" class="avoidbreakafter">
                                <p>次の設定が定義されています：</p>
                            </div>
                            <div id="rfc.section.6.5.2.p.2">
                                <dl>
                                    <dt id="SETTINGS_HEADER_TABLE_SIZE">SETTINGS_HEADER_TABLE_SIZE (0x01):</dt>
                                    <dd style="margin-left: 1.5em">
                                        <div>
                                            この設定は、受信側がフィールドブロックをデコードするために使用する圧縮テーブルの最大サイズをオクテット単位で送信者に通知します。エンコーダはこの値以下の任意のサイズを選択できます（圧縮形式固有のシグナリングを用いる。詳細は
                                            <a href="#RFC7541"><cite
                                                    title="HPACK: Header Compression for HTTP/2">[COMPRESSION]</cite></a>
                                            を参照）。初期値は 4,096 オクテットです。
                                        </div>
                                    </dd>
                                    <dt id="SETTINGS_ENABLE_PUSH">SETTINGS_ENABLE_PUSH (0x02):</dt>
                                    <dd style="margin-left: 1.5em">
                                        <div>この設定はサーバープッシュを有効または無効にするために使用できます。サーバーはこのパラメータが 0 に設定されていることを受信した場合、<a
                                                href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a>
                                            フレームを送信してはなりません（<a href="#PushResources" title="Server Push">Section 8.4</a>
                                            を参照）。クライアントがこのパラメータを 0 に設定し確認を受けている場合、PUSH_PROMISE を受信すると接続エラー（<a
                                                href="#ConnectionErrorHandler" title="Connection Error Handling">Section
                                                5.4.1</a>）の <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a> として扱わなければなりません。
                                        </div>
                                        <div>SETTINGS_ENABLE_PUSH の初期値は 1 です。クライアントにとって、この値は PUSH_PROMISE
                                            を受け取る意思があることを示します。サーバーにとって、この初期値は無効であり、値 0 と同等です。0 または 1 以外の値は接続エラー（<a
                                                href="#ConnectionErrorHandler" title="Connection Error Handling">Section
                                                5.4.1</a>）の <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>
                                            として扱われなければなりません。
                                        </div>
                                        <div>サーバーはこの値を明示的に 1 に設定してはなりません。サーバーは SETTINGS フレームでこの設定を省略することが <em
                                                class="bcp14">MAY</em> ありますが、もし値を含めるならそれは 0 でなければなりません（<em
                                                class="bcp14">MUST</em>）。クライアントは SETTINGS_ENABLE_PUSH を 1 に設定した SETTINGS
                                            フレームを受信した場合、それを接続エラー（<a href="#ConnectionErrorHandler"
                                                title="Connection Error Handling">Section 5.4.1</a>）の <a
                                                href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a> として扱わなければなりません。</div>
                                    </dd>
                                    <dt id="SETTINGS_MAX_CONCURRENT_STREAMS">SETTINGS_MAX_CONCURRENT_STREAMS (0x03):
                                    </dt>
                                    <dd style="margin-left: 1.5em">
                                        <div>
                                            この設定は送信者が許容する同時並行ストリームの最大数を示します。この制限は方向性を持ち、送信者が受信者に対して許可するストリーム数に適用されます。初期状態ではこの値に制限はありません。並列性を不必要に制限しないために、この値は
                                            100 未満にしないことが推奨されます。</div>
                                        <div>SETTINGS_MAX_CONCURRENT_STREAMS に対して 0 の値を特別扱いしては <em class="bcp14">SHOULD
                                                NOT</em>
                                            という注意が示されています。ゼロ値は新しいストリームの作成を防ぎますが、これはアクティブなストリームで枯渇した任意の制限についても同様に発生し得ます。サーバーは短時間のみゼロ値を設定することが
                                            <em class="bcp14">SHOULD</em> されます。長期間リクエストを受け付けたくない場合は、接続を閉じる方が適切です。
                                        </div>
                                    </dd>
                                    <dt id="SETTINGS_INITIAL_WINDOW_SIZE">SETTINGS_INITIAL_WINDOW_SIZE (0x04):</dt>
                                    <dd style="margin-left: 1.5em">
                                        <div>この設定はストリームレベルのフロー制御のための送信者の初期ウィンドウサイズ（オクテット単位）を示します。初期値は
                                            2<sup>16</sup>-1（65,535）オクテットです。</div>
                                        <div>この設定はすべてのストリームのウィンドウサイズに影響します（詳細は <a href="#InitialWindowSize"
                                                title="Initial Flow-Control Window Size">Section 6.9.2</a> を参照）。</div>
                                        <div>最大フロー制御ウィンドウサイズ 2<sup>31</sup>-1 を超える値は接続エラー（<a
                                                href="#ConnectionErrorHandler" title="Connection Error Handling">Section
                                                5.4.1</a>）の <a href="#FLOW_CONTROL_ERROR">FLOW_CONTROL_ERROR</a>
                                            として扱われなければなりません（<em class="bcp14">MUST</em>）。</div>
                                    </dd>
                                    <dt id="SETTINGS_MAX_FRAME_SIZE">SETTINGS_MAX_FRAME_SIZE (0x05):</dt>
                                    <dd style="margin-left: 1.5em">
                                        <div>この設定は、送信者が受信することを望む最大のフレームペイロードサイズをオクテット単位で示します。</div>
                                        <div>初期値は
                                            2<sup>14</sup>（16,384）オクテットです。エンドポイントが広告する値はこの初期値と最大許容フレームサイズ（2<sup>24</sup>-1
                                            または 16,777,215 オクテット）の間でなければなりません（<em
                                                class="bcp14">MUST</em>）。この範囲外の値は接続エラー（<a href="#ConnectionErrorHandler"
                                                title="Connection Error Handling">Section
                                                5.4.1</a>）の <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>
                                            として扱われなければなりません。
                                        </div>
                                    </dd>
                                    <dt id="SETTINGS_MAX_HEADER_LIST_SIZE">SETTINGS_MAX_HEADER_LIST_SIZE (0x06):</dt>
                                    <dd style="margin-left: 1.5em">
                                        <div>
                                            この助言的設定は、送信者が受け入れる準備がある最大のフィールドセクションサイズをオクテット単位でピアに通知します。値は未圧縮のフィールドラインサイズ（名前と値の長さのオクテット単位）に各フィールドラインあたり
                                            32 オクテットのオーバーヘッドを加えたものに基づきます。</div>
                                        <div>任意のリクエストに対して、広告された値より低い上限が適用されることが <em class="bcp14">MAY</em>
                                            あります。この設定の初期値は無制限です。</div>
                                    </dd>
                                </dl>
                            </div>
                            <div id="rfc.section.6.5.2.p.3">
                                <p>未知またはサポートされない識別子を含む SETTINGS フレームを受け取ったエンドポイントは、その設定を無視しなければなりません（<em
                                        class="bcp14">MUST</em>）。</p>
                            </div>
                        </section>
                        <section id="SettingsSync">
                            <h4 id="rfc.section.6.5.3"><a href="#rfc.section.6.5.3">6.5.3.</a>&nbsp;<a
                                    href="#SettingsSync">設定の同期</a></h4>
                            <div id="rfc.section.6.5.3.p.1">
                                <p>多くの SETTINGS 値は、ピアが変更されたパラメータ値を受け取り適用した時点を理解することが有益または必要です。そのために、ACK フラグが設定されていない
                                    SETTINGS フレームの受信者は、受信後できるだけ速やかに更新された設定を適用しなければなりません（<em
                                        class="bcp14">MUST</em>）。SETTINGS フレームは受信順に確認されます。</p>
                            </div>
                            <div id="rfc.section.6.5.3.p.2">
                                <p>SETTINGS フレーム内の値は、間に他のフレーム処理を挟まず出現順に処理されなければなりません（<em
                                        class="bcp14">MUST</em>）。サポートされない設定は無視されなければなりません。すべての値が処理されたら、受信者は直ちに ACK
                                    フラグが設定された
                                    SETTINGS フレームを送信しなければなりません。ACK フラグが設定された SETTINGS フレームを受信した送信者は、最も古い未確認の SETTINGS
                                    フレームの値が適用されたと見なすことができます。</p>
                            </div>
                            <div id="rfc.section.6.5.3.p.3">
                                <p>送信者が合理的な時間内に確認を受け取らない場合、その送信者は接続エラー（<a href="#ConnectionErrorHandler"
                                        title="Connection Error Handling">Section 5.4.1</a>）の <a
                                        href="#SETTINGS_TIMEOUT">SETTINGS_TIMEOUT</a> を発生させることが <em
                                        class="bcp14">MAY</em>
                                    あります。タイムアウトを設定する際には、ピア側の処理遅延に対する余裕を考慮する必要があります。往復時間のみを基準にしたタイムアウトは誤検出を招く可能性があります。
                                </p>
                            </div>
                        </section>
                    </section>
                    <section id="PUSH_PROMISE">
                        <h3 id="rfc.section.6.6"><a href="#rfc.section.6.6">6.6.</a>&nbsp;<a
                                href="#PUSH_PROMISE">PUSH_PROMISE</a></h3>
                        <div id="rfc.section.6.6.p.1">
                            <p>PUSH_PROMISE フレーム（type=0x05）は、送信者が開始する意図のあるストリームを事前にピアに通知するために使用されます。PUSH_PROMISE
                                フレームには送信者が作成する予定のストリームの符号なし 31
                                ビット識別子と、そのストリームに対する追加のコンテキストを提供するフィールドセクションが含まれます。PUSH_PROMISE の詳細な使用法は <a
                                    href="#PushResources" title="Server Push">Section 8.4</a> にあります。</p>
                        </div>
                        <div id="PUSH_PROMISEFrameFormat"></div>
                        <div id="rfc.figure.8">
                            <div>
                                <pre class="inline">
PUSH_PROMISE Frame {
  Length (24),
  Type (8) = 0x05,

  Unused Flags (4),
  PADDED Flag (1),
  END_HEADERS Flag (1),
  Unused Flags (2),

  Reserved (1),
  Stream Identifier (31),

  [Pad Length (8)],
  Reserved (1),
  Promised Stream ID (31),
  Field Block Fragment (..),
  Padding (..2040),
}
</pre>
                            </div>
                        </div>
                        <p class="figure">図 8: PUSH_PROMISE フレーム形式</p>
                        <div id="rfc.section.6.6.p.2" class="avoidbreakafter">
                            <p>Length、Type、Unused Flag(s)、Reserved、および Stream Identifier フィールドは <a href="#FramingLayer"
                                    title="HTTP Frames">Section 4</a> に記述されています。PUSH_PROMISE フレームのペイロードは次の追加フィールドを持ちます：
                            </p>
                        </div>
                        <div id="rfc.section.6.6.p.3">
                            <dl>
                                <dt>Pad Length:</dt>
                                <dd style="margin-left: 1.5em">フレームパディングの長さ（オクテット単位）を含む 8 ビットフィールド。PADDED
                                    フラグが設定されている場合にのみ存在します。</dd>
                                <dt>Promised Stream ID:</dt>
                                <dd style="margin-left: 1.5em">PUSH_PROMISE によって予約されるストリームを識別する符号なし 31
                                    ビット整数。約束されたストリーム識別子は送信者が次に送るストリームとして妥当な選択でなければなりません（<a href="#StreamIdentifiers"
                                        title="Stream Identifiers">Section 5.1.1</a> の「new stream identifier」を参照）。</dd>
                                <dt>Field Block Fragment:</dt>
                                <dd style="margin-left: 1.5em">リクエスト制御データとヘッダセクションを含むフィールドブロックのフラグメント（<a
                                        href="#FieldBlock" title="Field Section Compression and Decompression">Section
                                        4.3</a>）。</dd>
                                <dt>Padding:</dt>
                                <dd style="margin-left: 1.5em">
                                    アプリケーション的意味を持たないパディングオクテット。送信時、パディングオクテットはゼロに設定されなければなりません（<em
                                        class="bcp14">MUST</em>）。受信者は検証義務を負いませんが、非ゼロのパディングを接続エラー（<a
                                        href="#ConnectionErrorHandler" title="Connection Error Handling">Section
                                        5.4.1</a>）の
                                    <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a> として扱うことが <em class="bcp14">MAY</em>
                                    あります。
                                </dd>
                            </dl>
                        </div>
                        <div id="rfc.section.6.6.p.4" class="avoidbreakafter">
                            <p>PUSH_PROMISE フレームは次のフラグを定義します：</p>
                        </div>
                        <div id="rfc.section.6.6.p.5">
                            <dl>
                                <dt>PADDED (0x08):</dt>
                                <dd style="margin-left: 1.5em">
                                    <div>設定されていると、PADDED フラグは Pad Length フィールドとそれが示すパディングが存在することを示します。</div>
                                </dd>
                                <dt>END_HEADERS (0x04):</dt>
                                <dd style="margin-left: 1.5em">
                                    <div>設定されていると、END_HEADERS フラグはこのフレームが完全なフィールドブロック（<a href="#FieldBlock"
                                            title="Field Section Compression and Decompression">Section
                                            4.3</a>）を含み、同じストリームに続く CONTINUATION フレームがないことを示します。</div>
                                    <div>END_HEADERS フラグが設定されていない PUSH_PROMISE フレームは、同じストリームの CONTINUATION
                                        フレームで続かなければなりません（<em
                                            class="bcp14">MUST</em>）。受信者は他の型のフレームや別のストリームのフレームを受信した場合、それを接続エラー（<a
                                            href="#ConnectionErrorHandler" title="Connection Error Handling">Section
                                            5.4.1</a>）の <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a> と扱わなければなりません。</div>
                                </dd>
                            </dl>
                        </div>
                        <div id="rfc.section.6.6.p.6">
                            <p>PUSH_PROMISE フレームは、送信者がピアによって開始されたストリーム上でかつそのストリームが "open" または "half-closed (remote)"
                                状態にある場合にのみ送信することが <em class="bcp14">MUST</em> です。PUSH_PROMISE の Stream Identifier
                                フィールドはそれが関連するストリームを示します。Stream Identifier が 0x00 の場合、受信者は <a
                                    href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>
                                の種類の接続エラー（<a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>）で応答しなければなりません。</p>
                        </div>
                        <div id="rfc.section.6.6.p.7">
                            <p>約束されたストリームは約束された順序で使用される必要はありません。PUSH_PROMISE は単に将来の使用のためにストリーム識別子を予約するだけです。</p>
                        </div>
                        <div id="rfc.section.6.6.p.8">
                            <p>PUSH_PROMISE はピアの SETTINGS_ENABLE_PUSH 設定が 0 に設定されている場合に送信してはなりません（<em class="bcp14">MUST
                                    NOT</em>）。この設定を 0 に設定し確認を受けたエンドポイントは、PUSH_PROMISE を受信した場合それを接続エラー（<a
                                    href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>）の
                                <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a> として扱わなければなりません。
                            </p>
                        </div>
                        <div id="rfc.section.6.6.p.9">
                            <p>PUSH_PROMISE の受信者は、約束されたストリームを拒否するために、約束されたストリーム識別子を参照する <a href="#RST_STREAM"
                                    title="RST_STREAM">RST_STREAM</a> を送信して送信者に返すことができます。</p>
                        </div>
                        <div id="rfc.section.6.6.p.10">
                            <p>PUSH_PROMISE フレームは接続状態を二つの方法で変更します。第一に、フィールドブロック（<a href="#FieldBlock"
                                    title="Field Section Compression and Decompression">Section
                                    4.3</a>）の包含はフィールドセクション圧縮のために維持される状態を変更する可能性があります。第二に、PUSH_PROMISE
                                はストリームを将来の使用のために予約し、約束されたストリームを "reserved (local)" または "reserved (remote)"
                                状態にします。送信者は、そのストリームが "open" または "half-closed (remote)" のいずれかでない限り PUSH_PROMISE
                                を送信してはなりません（<em class="bcp14">MUST
                                    NOT</em>）。送信者は約束されたストリームが新しいストリーム識別子として妥当な選択であることを確認しなければなりません（<a
                                    href="#StreamIdentifiers" title="Stream Identifiers">Section
                                    5.1.1</a>）。すなわち、約束されたストリームは
                                "idle" 状態でなければなりません（<em class="bcp14">MUST</em>）。</p>
                        </div>
                        <div id="rfc.section.6.6.p.11">
                            <p>PUSH_PROMISE を無視するとストリームが不定状態になるため、約束されたストリームは無視されるべきではありません。受信者は、PUSH_PROMISE
                                を受信していて関連するストリームが "open" でも "half-closed (local)" でもない場合、それを接続エラー（<a
                                    href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>）の
                                <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a> として扱わなければなりません。しかし、関連するストリームで既に <a
                                    href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> を送信しているエンドポイントは、RST_STREAM
                                が受信・処理される前に作成された可能性のある PUSH_PROMISE フレームを処理しなければなりません。
                            </p>
                        </div>
                        <div id="rfc.section.6.6.p.12">
                            <p>約束された不正なストリーム識別子（<a href="#StreamIdentifiers" title="Stream Identifiers">Section
                                    5.1.1</a>）を約束する PUSH_PROMISE の受信は、接続エラー（<a href="#ConnectionErrorHandler"
                                    title="Connection Error Handling">Section 5.4.1</a>）の <a
                                    href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a> として扱わなければなりません。ここで不正なストリーム識別子とは現在 "idle"
                                状態にないストリームの識別子を指します。</p>
                        </div>
                        <div id="rfc.section.6.6.p.13">
                            <p>パディングオクテットの総数は Pad Length フィールドの値により決まります。パディングの長さがフレームペイロードの長さ以上である場合、受信者はこれを接続エラー（<a
                                    href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>）の
                                <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a> として扱わなければなりません。
                            </p>
                        </div>
                        <div id="rfc.section.6.6.p.14">
                            <aside>
                                <div id="rfc.section.6.6.p.14.1">
                                    <p>注：Pad Length フィールドにゼロを含めることで、フレームのサイズを 1 オクテット増やすことができます。</p>
                                </div>
                            </aside>
                        </div>
                    </section>
                    <section id="PING">
                        <h3 id="rfc.section.6.7"><a href="#rfc.section.6.7">6.7.</a>&nbsp;<a href="#PING">PING</a></h3>
                        <div id="rfc.section.6.7.p.1">
                            <p>PING フレーム（type=0x06）は送信者からの最小往復時間を測定し、アイドル接続がまだ機能しているかを確認する手段です。PING
                                フレームは任意のエンドポイントから送信できます。
                            </p>
                        </div>
                        <div id="PINGFrameFormat"></div>
                        <div id="rfc.figure.9">
                            <div>
                                <pre class="inline">
PING Frame {
  Length (24) = 0x08,
  Type (8) = 0x06,

  Unused Flags (7),
  ACK Flag (1),

  Reserved (1),
  Stream Identifier (31) = 0,

  Opaque Data (64),
}
</pre>
                            </div>
                        </div>
                        <p class="figure">図 9: PING フレーム形式</p>
                        <div id="rfc.section.6.7.p.2">
                            <p>Length、Type、Unused Flag(s)、Reserved、および Stream Identifier フィールドは <a href="#FramingLayer"
                                    title="HTTP Frames">Section 4</a> に記述されています。</p>
                        </div>
                        <div id="rfc.section.6.7.p.3">
                            <p>フレームヘッダに加えて、PING フレームはペイロードに 8 オクテットの不透明データを <em class="bcp14">MUST</em>
                                含める必要があります。送信者は任意の値を含め、そのオクテットを任意の方法で使用できます。</p>
                        </div>
                        <div id="rfc.section.6.7.p.4">
                            <p>ACK フラグを含まない PING フレームを受信した受信者は、同一のフレームペイロードを持ち ACK フラグを設定した PING フレームで応答しなければなりません（<em
                                    class="bcp14">MUST</em>）。PING 応答は他のフレームより高い優先度で処理されることが <em
                                    class="bcp14">SHOULD</em>
                                あります。</p>
                        </div>
                        <div id="rfc.section.6.7.p.5" class="avoidbreakafter">
                            <p>PING フレームは以下のフラグを定義します：</p>
                        </div>
                        <div id="rfc.section.6.7.p.6">
                            <dl>
                                <dt>ACK (0x01):</dt>
                                <dd style="margin-left: 1.5em">設定されていると、この PING フレームが PING 応答であることを示します。エンドポイントは PING
                                    応答でこのフラグを設定しなければなりません（<em class="bcp14">MUST</em>）。このフラグを含む PING
                                    フレームには応答してはなりません（<em class="bcp14">MUST NOT</em>）。</dd>
                            </dl>
                        </div>
                        <div id="rfc.section.6.7.p.7">
                            <p>PING フレームは個々のストリームには関連付けられていません。Stream Identifier が 0x00 でない PING
                                フレームを受信した場合、受信者は接続エラー（<a href="#ConnectionErrorHandler"
                                    title="Connection Error Handling">Section 5.4.1</a>）の <a
                                    href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a> として応答しなければなりません。</p>
                        </div>
                        <div id="rfc.section.6.7.p.8">
                            <p>長さフィールド値が 8 でない PING フレームの受信は、接続エラー（<a href="#ConnectionErrorHandler"
                                    title="Connection Error Handling">Section 5.4.1</a>）の <a
                                    href="#FRAME_SIZE_ERROR">FRAME_SIZE_ERROR</a> として扱われなければなりません。</p>
                        </div>
                    </section>
                    <section id="GOAWAY">
                        <h3 id="rfc.section.6.8"><a href="#rfc.section.6.8">6.8.</a>&nbsp;<a href="#GOAWAY">GOAWAY</a>
                        </h3>
                        <div id="rfc.section.6.8.p.1">
                            <p>GOAWAY フレーム（type=0x07）は接続のシャットダウンを開始するか、重大なエラー状態を通知するために使用されます。GOAWAY
                                により、エンドポイントは新しいストリームの受け入れを優雅に停止しつつ、既に確立されたストリームの処理を完了できます。これによりサーバーメンテナンスのような管理操作が可能になります。
                            </p>
                        </div>
                        <div id="rfc.section.6.8.p.2">
                            <p>エンドポイントが新しいストリームを開始することと、リモートピアが GOAWAY を送信することの間には本質的な競合状態があります。この場合に対処するため、GOAWAY
                                には送信者がこの接続で処理した、または処理する可能性のある最後のピア開始ストリームの識別子が含まれます。例えば、サーバーが GOAWAY
                                を送信する場合、その識別子はクライアントが開始した最大番号のストリームです。</p>
                        </div>
                        <div id="rfc.section.6.8.p.3">
                            <p>GOAWAY を送信した後、送信者は含まれている last stream identifier
                                より大きな識別子を持つ、受信者が開始したストリーム上で送られたフレームを無視します。GOAWAY を受信した受信者は接続上で追加のストリームを開いてはなりません（<em
                                    class="bcp14">MUST NOT</em>）、ただし新しいストリームのために新しい接続を確立することはできます。</p>
                        </div>
                        <div id="rfc.section.6.8.p.4">
                            <p>GOAWAY の受信者が GOAWAY
                                に示されたものより高いストリーム識別子でストリーム上にデータを送信している場合、それらのストリームは処理されていないか処理されないことになります。GOAWAY
                                の受信者はそれらのストリームを作成されていなかったかのように扱い、新しい接続でそれらのストリームを再試行できます。</p>
                        </div>
                        <div id="rfc.section.6.8.p.5">
                            <p>エンドポイントは接続を閉じる前に常に GOAWAY を送信することが <em class="bcp14">SHOULD</em>
                                推奨されます。これによりリモートピアはストリームが部分的に処理されたかどうかを知ることができます。例えば、HTTP クライアントが POST
                                を送信している最中にサーバーが接続を閉じた場合、サーバーがどのストリームに対して処理を始めたかを示す GOAWAY を送信しないとクライアントは判断できません。</p>
                        </div>
                        <div id="rfc.section.6.8.p.6">
                            <p>不正なピアに対しては、エンドポイントは GOAWAY を送信せずに接続を閉じることを選択する場合があります。</p>
                        </div>
                        <div id="rfc.section.6.8.p.7">
                            <p>GOAWAY フレームが直ちに接続の終了に先行するとは限りません。GOAWAY を受信して接続を使用しなくなった受信者であっても、接続を終了する前に GOAWAY
                                を送信することが
                                <em class="bcp14">SHOULD</em> 推奨されます。
                            </p>
                        </div>
                        <div id="GOAWAYFrameFormat"></div>
                        <div id="rfc.figure.10">
                            <div>
                                <pre class="inline">
GOAWAY Frame {
  Length (24),
  Type (8) = 0x07,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31) = 0,

  Reserved (1),
  Last-Stream-ID (31),
  Error Code (32),
  Additional Debug Data (..),
}
</pre>
                            </div>
                        </div>
                        <p class="figure">図 10: GOAWAY フレーム形式</p>
                        <div id="rfc.section.6.8.p.8">
                            <p>Length、Type、Unused Flag(s)、Reserved、および Stream Identifier フィールドは <a href="#FramingLayer"
                                    title="HTTP Frames">Section 4</a> に記述されています。</p>
                        </div>
                        <div id="rfc.section.6.8.p.9">
                            <p>GOAWAY フレームはフラグを定義しません。</p>
                        </div>
                        <div id="rfc.section.6.8.p.10">
                            <p>GOAWAY フレームは接続に適用され、特定のストリームには適用されません。Stream Identifier が 0x00 でない GOAWAY
                                フレームを受信した場合、受信者は <a href="#ConnectionErrorHandler"
                                    title="Connection Error Handling">Section 5.4.1</a>
                                の種類の接続エラー（<a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>）として扱わなければなりません（<em
                                    class="bcp14">MUST</em>）。</p>
                        </div>
                        <div id="rfc.section.6.8.p.11">
                            <p>GOAWAY の last stream identifier
                                には、送信者が何らかの処理を行った可能性がある、またはこれから行う可能性がある最高番号のストリーム識別子が含まれます。識別されたストリームまでのすべてのストリームは何らかの形で処理されている可能性があります。処理されたストリームがない場合、last
                                stream identifier は 0 に設定できます。</p>
                        </div>
                        <div id="rfc.section.6.8.p.12">
                            <aside>
                                <div id="rfc.section.6.8.p.12.1">
                                    <p>注：この文脈における「処理された」とは、ストリームからの何らかのデータが上位レイヤのソフトウェアに渡され、その結果何らかのアクションが取られた可能性があることを意味します。
                                    </p>
                                </div>
                            </aside>
                        </div>
                        <div id="rfc.section.6.8.p.13">
                            <p>接続が GOAWAY なしで終了した場合、last stream identifier は事実上可能な最高のストリーム識別子と見なされます。</p>
                        </div>
                        <div id="rfc.section.6.8.p.14">
                            <p>接続が閉じられる前に完全に閉じられなかった last stream identifier
                                以下のストリームでは、リクエストやトランザクションの再試行は可能ではありません（ただし、HTTP
                                GET、PUT、DELETE のような冪等な操作は例外です）。より大きな番号のストリームに対するプロトコル活動は新しい接続で安全に再試行できます。</p>
                        </div>
                        <div id="rfc.section.6.8.p.15">
                            <p>last stream identifier 以下のストリーム上の活動はまだ正常に完了する可能性があります。GOAWAY を送信するエンドポイントは、GOAWAY
                                を送信した後に進行中のストリームが完了するまで接続を「open」状態に維持して優雅にシャットダウンすることができます。</p>
                        </div>
                        <div id="rfc.section.6.8.p.16">
                            <p>状況が変化した場合、エンドポイントは複数の GOAWAY を送信することが <em class="bcp14">MAY</em> あります。例えば、優雅にシャットダウンするために
                                NO_ERROR で GOAWAY を送信した後に、即時の接続終了を要求する条件が発生した場合です。最後に受信した GOAWAY の last stream
                                identifier
                                はどのストリームに対して処理が行われたかを示します。エンドポイントは送信する last stream identifier の値を増加させてはなりません（<em
                                    class="bcp14">MUST NOT</em>）、なぜならピアは既に未処理のリクエストを別の接続で再試行している可能性があるためです。</p>
                        </div>
                        <div id="rfc.section.6.8.p.17">
                            <p>クライアントが再試行できない場合、サーバーが接続を閉じたときに進行中のすべてのリクエストを失います。これは HTTP/2
                                を使用していないクライアントを扱うインターミディアリに特に当てはまります。サーバーが接続を優雅にシャットダウンしようとする場合、最初に last stream
                                identifier を
                                2<sup>31</sup>-1 に設定し、<a href="#NO_ERROR">NO_ERROR</a> コードを付けた GOAWAY を送信することが <em
                                    class="bcp14">SHOULD</em>
                                推奨されます。これはクライアントにシャットダウンが差し迫っており、さらなるリクエストの開始が禁止されていることを通知します。進行中のストリーム作成のために十分な時間（少なくとも
                                1
                                往復時間）を与えた後、サーバーは更新された last stream identifier を持つ別の GOAWAY を送信しても <em
                                    class="bcp14">MAY</em>
                                あります。これによりリクエストを失うことなく接続をクリーンにシャットダウンできます。</p>
                        </div>
                        <div id="rfc.section.6.8.p.18">
                            <p>GOAWAY を送信した後、送信者は識別された last stream
                                より大きな識別子を持つ、受信者が開始したストリームのフレームを破棄することができます。ただし、接続状態を変更するフレームを完全に無視することはできません。例えば、<a
                                    href="#HEADERS" title="HEADERS">HEADERS</a>、<a href="#PUSH_PROMISE"
                                    title="PUSH_PROMISE">PUSH_PROMISE</a>、および <a href="#CONTINUATION"
                                    title="CONTINUATION">CONTINUATION</a> フレームはフィールドセクション圧縮の状態を一貫させるために最小限の処理を <em
                                    class="bcp14">MUST</em> 受ける必要があります（<a href="#FieldBlock"
                                    title="Field Section Compression and Decompression">Section 4.3</a> を参照）。同様に、DATA
                                フレームは接続のフロー制御ウィンドウに対してカウントされなければなりません。これらのフレームを処理しないとフロー制御やフィールドセクション圧縮の状態が不整合になります。</p>
                        </div>
                        <div id="rfc.section.6.8.p.19">
                            <p>GOAWAY フレームには接続を閉じる理由を示す 32 ビットのエラーコード（<a href="#ErrorCodes" title="Error Codes">Section
                                    7</a>）も含まれます。</p>
                        </div>
                        <div id="rfc.section.6.8.p.20">
                            <p>エンドポイントは任意の GOAWAY フレームのペイロードに不透明データを付加することが <em class="bcp14">MAY</em>
                                あります。追加のデバッグデータは診断目的のみを意図しており意味論的な価値を持ちません。デバッグ情報にはセキュリティやプライバシーに敏感なデータが含まれる可能性があります。ログに保存されるなど永続的に保管されるデバッグデータは不正アクセスを防ぐための適切な保護が
                                <em class="bcp14">MUST</em> 必要です。
                            </p>
                        </div>
                    </section>
                    <section id="WINDOW_UPDATE">
                        <h3 id="rfc.section.6.9"><a href="#rfc.section.6.9">6.9.</a>&nbsp;<a
                                href="#WINDOW_UPDATE">WINDOW_UPDATE</a></h3>
                        <div id="rfc.section.6.9.p.1">
                            <p>WINDOW_UPDATE フレーム（type=0x08）はフロー制御を実装するために使用されます。概要は <a href="#FlowControl"
                                    title="Flow Control">Section 5.2</a> を参照してください。</p>
                        </div>
                        <div id="rfc.section.6.9.p.2">
                            <p>フロー制御は二つのレベルで動作します：個々のストリームごとと接続全体です。</p>
                        </div>
                        <div id="rfc.section.6.9.p.3">
                            <p>両方のフロー制御はホップごと（すなわち両端点間）で行われます。インターミディアリは依存関係のある接続間で WINDOW_UPDATE
                                フレームを転送しません。しかし、受信側によるデータ転送の抑制は元の送信者に向けてフロー制御情報の間接的な伝播を引き起こす可能性があります。</p>
                        </div>
                        <div id="rfc.section.6.9.p.4">
                            <p>フロー制御はフロー制御の対象と識別されるフレームにのみ適用されます。本書で定義されたフレームタイプのうち、フロー制御の対象となるのは <a href="#DATA"
                                    title="DATA">DATA</a>
                                フレームのみです。フロー制御の対象外のフレームは、受信者がそのフレームの処理にリソースを割り当てられない場合を除き、受け入れ処理されなければなりません（<em
                                    class="bcp14">MUST</em>）。受信者がフレームを受け入れられない場合、ストリームエラー（<a href="#StreamErrorHandler"
                                    title="Stream Error Handling">Section 5.4.2</a>）または接続エラー（<a
                                    href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>）の
                                <a href="#FLOW_CONTROL_ERROR">FLOW_CONTROL_ERROR</a> を返すことが <em class="bcp14">MAY</em>
                                あります。
                            </p>
                        </div>
                        <div id="WINDOW_UPDATEFrameFormat"></div>
                        <div id="rfc.figure.11">
                            <div>
                                <pre class="inline">
WINDOW_UPDATE Frame {
  Length (24) = 0x04,
  Type (8) = 0x08,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Reserved (1),
  Window Size Increment (31),
}
</pre>
                            </div>
                        </div>
                        <p class="figure">図 11: WINDOW_UPDATE フレーム形式</p>
                        <div id="rfc.section.6.9.p.5">
                            <p>Length、Type、Unused Flag(s)、Reserved、および Stream Identifier フィールドは <a href="#FramingLayer"
                                    title="HTTP Frames">Section 4</a> に記述されています。WINDOW_UPDATE フレームのペイロードは 1
                                ビットの予約ビットと、送信者が既存のフロー制御ウィンドウに加えて送信できるオクテット数を示す符号なし 31
                                ビット整数から成ります。フロー制御ウィンドウの増分に対する合法的範囲は 1
                                から 2<sup>31</sup>-1（2,147,483,647）オクテットです。</p>
                        </div>
                        <div id="rfc.section.6.9.p.6">
                            <p>WINDOW_UPDATE フレームはフラグを定義しません。</p>
                        </div>
                        <div id="rfc.section.6.9.p.7">
                            <p>WINDOW_UPDATE フレームはストリーム固有にも接続全体にも適用できます。前者ではフレームのストリーム識別子が影響するストリームを示し、後者では値 "0"
                                が接続全体を示します。
                            </p>
                        </div>
                        <div id="rfc.section.6.9.p.8">
                            <p>フロー制御ウィンドウ増分が 0 の WINDOW_UPDATE フレームを受信した受信者は、それをストリームエラー（<a href="#StreamErrorHandler"
                                    title="Stream Error Handling">Section 5.4.2</a>）の <a
                                    href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a> として扱わなければなりません（<em
                                    class="bcp14">MUST</em>）。接続フロー制御ウィンドウに対するエラーは接続エラー（<a href="#ConnectionErrorHandler"
                                    title="Connection Error Handling">Section 5.4.1</a>）として扱われなければなりません。</p>
                        </div>
                        <div id="rfc.section.6.9.p.9">
                            <p>WINDOW_UPDATE は END_STREAM フラグを持つフレームを送信したピアによって送信される可能性があります。つまり、受信者が "half-closed
                                (remote)"
                                または "closed" 状態のストリームで WINDOW_UPDATE を受信することがありますが、受信者はこれをエラーとして扱ってはなりません（<a
                                    href="#StreamStates" title="Stream States">Section 5.1</a> を参照）。</p>
                        </div>
                        <div id="rfc.section.6.9.p.10">
                            <p>フロー制御対象フレームを受信した受信者は、接続フロー制御ウィンドウに対するその寄与を常に勘案しなければなりません（<em
                                    class="bcp14">MUST</em>）、ただし受信者がこれを接続エラー（<a href="#ConnectionErrorHandler"
                                    title="Connection Error Handling">Section
                                    5.4.1</a>）と見なす場合を除きます。これはフレームがエラーであっても必要です。送信者はフレームをフロー制御ウィンドウに対してカウントしますが、受信者がカウントしないと送信者と受信者のフロー制御ウィンドウが不一致になります。
                            </p>
                        </div>
                        <div id="rfc.section.6.9.p.11">
                            <p>長さが 4 オクテットでない WINDOW_UPDATE フレームは <a href="#ConnectionErrorHandler"
                                    title="Connection Error Handling">Section 5.4.1</a> の種類の接続エラー（<a
                                    href="#FRAME_SIZE_ERROR">FRAME_SIZE_ERROR</a>）として扱われなければなりません。</p>
                        </div>
                        <section id="n-the-flow-control-window">
                            <h4 id="rfc.section.6.9.1"><a href="#rfc.section.6.9.1">6.9.1.</a>&nbsp;<a
                                    href="#n-the-flow-control-window">フロー制御ウィンドウ</a></h4>
                            <div id="rfc.section.6.9.1.p.1">
                                <p>HTTP/2
                                    におけるフロー制御は、各ストリームごとに各送信者が保持するウィンドウを用いて実装されます。フロー制御ウィンドウは送信者が送信を許可されているオクテット数を示す単純な整数値であり、そのサイズは受信者のバッファ容量の尺度です。
                                </p>
                            </div>
                            <div id="rfc.section.6.9.1.p.2">
                                <p>適用されるフロー制御ウィンドウは二つあります：ストリームのフロー制御ウィンドウと接続のフロー制御ウィンドウです。送信者は受信者が広告したいずれのフロー制御ウィンドウにも収まらない長さのフロー制御対象フレームを送信してはなりません（<em
                                        class="bcp14">MUST NOT</em>）。END_STREAM フラグを持つゼロ長のフレーム（つまり空の DATA
                                    フレーム）は、いずれのフロー制御ウィンドウにも空きがない場合に <em class="bcp14">MAY</em> 送信できます。</p>
                            </div>
                            <div id="rfc.section.6.9.1.p.3">
                                <p>フロー制御の計算では、9 オクテットのフレームヘッダはカウントされません。</p>
                            </div>
                            <div id="rfc.section.6.9.1.p.4">
                                <p>フロー制御対象フレームを送信した後、送信者は送信したフレームの長さだけ両方のウィンドウの利用可能空間を減らします。</p>
                            </div>
                            <div id="rfc.section.6.9.1.p.5">
                                <p>フレームの受信者はデータを消費してフロー制御ウィンドウの空間を解放する際に WINDOW_UPDATE
                                    フレームを送信します。ストリームレベルと接続レベルのそれぞれに対して別個の
                                    WINDOW_UPDATE が送信されます。受信者は非常に小さな増分の WINDOW_UPDATE を送信しないような仕組みを持つことが推奨されます（参考：<a
                                        href="https://www.rfc-editor.org/rfc/rfc1122.html#section-4.2.3.3">RFC 1122
                                        Section
                                        4.2.3.3</a>）。</p>
                            </div>
                            <div id="rfc.section.6.9.1.p.6">
                                <p>WINDOW_UPDATE を受け取った送信者は、対応するウィンドウをフレームで指定された量だけ更新します。</p>
                            </div>
                            <div id="rfc.section.6.9.1.p.7">
                                <p>送信者はフロー制御ウィンドウを 2<sup>31</sup>-1 オクテットを超えてはいけません（<em class="bcp14">MUST
                                        NOT</em>）。WINDOW_UPDATE
                                    を受け取りその結果ウィンドウがこの最大値を超える場合、送信者は適切にストリームまたは接続を終了しなければなりません。ストリームの場合は <a
                                        href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> を <a
                                        href="#FLOW_CONTROL_ERROR">FLOW_CONTROL_ERROR</a> で送信し、接続の場合は <a href="#GOAWAY"
                                        title="GOAWAY">GOAWAY</a> を同じエラーコードで送信します（<em class="bcp14">MUST</em>）。</p>
                            </div>
                            <div id="rfc.section.6.9.1.p.8">
                                <p>送信者のフロー制御対象フレームと受信者の WINDOW_UPDATE
                                    フレームは完全に非同期です。この特性により、受信者はストリームのスタールを防ぐために送信者が保持するウィンドウサイズを積極的に更新できます。</p>
                            </div>
                        </section>
                        <section id="InitialWindowSize">
                            <h4 id="rfc.section.6.9.2"><a href="#rfc.section.6.9.2">6.9.2.</a>&nbsp;<a
                                    href="#InitialWindowSize">初期フロー制御ウィンドウサイズ</a></h4>
                            <div id="rfc.section.6.9.2.p.1">
                                <p>HTTP/2 接続が確立されると、新しいストリームは初期フロー制御ウィンドウサイズ 65,535 オクテットで作成されます。接続フロー制御ウィンドウも同様に 65,535
                                    オクテットです。両端点は <a
                                        href="#SETTINGS_INITIAL_WINDOW_SIZE">SETTINGS_INITIAL_WINDOW_SIZE</a> を
                                    <a href="#SETTINGS" title="SETTINGS">SETTINGS</a>
                                    フレームに含めることで新しいストリームの初期ウィンドウサイズを調整できます。接続フロー制御ウィンドウは WINDOW_UPDATE フレームを使用してのみ変更できます。
                                </p>
                            </div>
                            <div id="rfc.section.6.9.2.p.2">
                                <p><a href="#SETTINGS" title="SETTINGS">SETTINGS</a> フレームで SETTINGS_INITIAL_WINDOW_SIZE
                                    の値が設定される前は、エンドポイントはデフォルトの初期ウィンドウサイズのみを使用してフロー制御対象フレームを送信できます。同様に、接続フロー制御ウィンドウは
                                    WINDOW_UPDATE を受け取るまでデフォルト値に基づいて設定されます。</p>
                            </div>
                            <div id="rfc.section.6.9.2.p.3">
                                <p><a href="#SETTINGS" title="SETTINGS">SETTINGS</a>
                                    フレームはまだアクティブでないストリームのフロー制御ウィンドウを変更するだけでなく、すでにアクティブなフロー制御ウィンドウを持つストリーム（つまり "open" または
                                    "half-closed (remote)" 状態）に対する初期フロー制御ウィンドウサイズも変更できます。SETTINGS_INITIAL_WINDOW_SIZE
                                    の値が変化した場合、受信者は保持しているすべてのストリームフロー制御ウィンドウのサイズを新旧の差分だけ調整しなければなりません（<em
                                        class="bcp14">MUST</em>）。</p>
                            </div>
                            <div id="rfc.section.6.9.2.p.4">
                                <p>SETTINGS_INITIAL_WINDOW_SIZE
                                    の変更によりフロー制御ウィンドウの利用可能空間が負の値になることがあります。送信者は負のフロー制御ウィンドウを追跡し、WINDOW_UPDATE
                                    によってウィンドウが正の値に戻るまで新しいフロー制御対象フレームを送信してはなりません（<em class="bcp14">MUST NOT</em>）。</p>
                            </div>
                            <div id="rfc.section.6.9.2.p.5">
                                <p>例えば、クライアントが接続確立時に直ちに 60 KB を送信し、その後サーバーが初期ウィンドウサイズを 16 KB に設定した場合、クライアントは <a
                                        href="#SETTINGS" title="SETTINGS">SETTINGS</a> フレームの受信により利用可能なフロー制御ウィンドウを -44 KB
                                    に再計算します。クライアントは WINDOW_UPDATE によってウィンドウが正に回復するまで負のウィンドウを保持し、その後送信を再開できます。</p>
                            </div>
                            <div id="rfc.section.6.9.2.p.6">
                                <p><a href="#SETTINGS" title="SETTINGS">SETTINGS</a> フレームは接続フロー制御ウィンドウを変更できません。</p>
                            </div>
                            <div id="rfc.section.6.9.2.p.7">
                                <p>SETTINGS_INITIAL_WINDOW_SIZE の変更が任意のフロー制御ウィンドウを最大サイズを超えるようにする場合、エンドポイントは接続エラー（<a
                                        href="#ConnectionErrorHandler" title="Connection Error Handling">Section
                                        5.4.1</a>）の
                                    <a href="#FLOW_CONTROL_ERROR">FLOW_CONTROL_ERROR</a> として扱わなければなりません（<em
                                        class="bcp14">MUST</em>）。
                                </p>
                            </div>
                        </section>
                        <section id="n-reducing-the-stream-window-size">
                            <h4 id="rfc.section.6.9.3"><a href="#rfc.section.6.9.3">6.9.3.</a>&nbsp;<a
                                    href="#n-reducing-the-stream-window-size">ストリームウィンドウサイズの縮小</a></h4>
                            <div id="rfc.section.6.9.3.p.1">
                                <p>受信者が現在のサイズより小さいフロー制御ウィンドウを使用したい場合、新しい <a href="#SETTINGS"
                                        title="SETTINGS">SETTINGS</a>
                                    フレームを送信できます。ただし、送信者は SETTINGS
                                    フレームを処理する前にそのより低い制限を超えるデータを送信する可能性があるため、受信者はそのようなデータを受信する準備を <em
                                        class="bcp14">MUST</em>
                                    しておかなければなりません。</p>
                            </div>
                            <div id="rfc.section.6.9.3.p.2">
                                <p>初期フロー制御ウィンドウサイズを減らす SETTINGS フレームを送信した後も、受信者はフロー制御制限を超えるストリームの処理を継続することが <em
                                        class="bcp14">MAY</em>
                                    あります。処理を継続することは直ちにフロー制御ウィンドウのために確保する空間を縮小することを許しません。これらのストリームの進行は、送信者が送信を再開するために必要な
                                    WINDOW_UPDATE を受け取るまで停滞する可能性があります。受信者は代わりに影響を受けるストリームに対して <a href="#RST_STREAM"
                                        title="RST_STREAM">RST_STREAM</a> を <a
                                        href="#FLOW_CONTROL_ERROR">FLOW_CONTROL_ERROR</a> のエラーコードで送信しても <em
                                        class="bcp14">MAY</em> あります。</p>
                            </div>
                        </section>
                    </section>
                    <section id="CONTINUATION">
                        <h3 id="rfc.section.6.10"><a href="#rfc.section.6.10">6.10.</a>&nbsp;<a
                                href="#CONTINUATION">CONTINUATION</a></h3>
                        <div id="rfc.section.6.10.p.1">
                            <p>CONTINUATION フレーム（type=0x09）はフィールドブロックフラグメントの連続を継続するために使用されます（<a href="#FieldBlock"
                                    title="Field Section Compression and Decompression">Section
                                    4.3</a>）。先行するフレームが同じストリーム上であり、END_HEADERS フラグが設定されていない HEADERS、PUSH_PROMISE、または
                                CONTINUATION フレームである限り、任意の数の CONTINUATION フレームを送信できます。</p>
                        </div>
                        <div id="CONTINUATIONFrameFormat"></div>
                        <div id="rfc.figure.12">
                            <div>
                                <pre class="inline">
CONTINUATION Frame {
  Length (24),
  Type (8) = 0x09,

  Unused Flags (5),
  END_HEADERS Flag (1),
  Unused Flags (2),

  Reserved (1),
  Stream Identifier (31),

  Field Block Fragment (..),
}
</pre>
                            </div>
                        </div>
                        <p class="figure">図 12: CONTINUATION フレーム形式</p>
                        <div id="rfc.section.6.10.p.2">
                            <p>Length、Type、Unused Flag(s)、Reserved、および Stream Identifier フィールドは <a href="#FramingLayer"
                                    title="HTTP Frames">Section 4</a> に記述されています。CONTINUATION
                                フレームのペイロードはフィールドブロックのフラグメントを含みます（<a href="#FieldBlock"
                                    title="Field Section Compression and Decompression">Section 4.3</a>）。</p>
                        </div>
                        <div id="rfc.section.6.10.p.3" class="avoidbreakafter">
                            <p>CONTINUATION フレームは次のフラグを定義します：</p>
                        </div>
                        <div id="rfc.section.6.10.p.4">
                            <dl>
                                <dt>END_HEADERS (0x04):</dt>
                                <dd style="margin-left: 1.5em">
                                    <div>設定されていると、END_HEADERS フラグはこのフレームがフィールドブロックを終了することを示します（<a href="#FieldBlock"
                                            title="Field Section Compression and Decompression">Section 4.3</a>）。</div>
                                    <div>END_HEADERS フラグが設定されていない場合、このフレームは次の CONTINUATION フレームで続かなければなりません（<em
                                            class="bcp14">MUST</em>）。受信者は他の型のフレームや別のストリーム上のフレームを受信した場合、それを接続エラー（<a
                                            href="#ConnectionErrorHandler" title="Connection Error Handling">Section
                                            5.4.1</a>）の <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a> として扱わなければなりません。
                                    </div>
                                </dd>
                            </dl>
                        </div>
                        <div id="rfc.section.6.10.p.5">
                            <p>CONTINUATION フレームは <a href="#FieldBlock"
                                    title="Field Section Compression and Decompression">Section 4.3</a>
                                に定義されたとおり接続状態を変更します。
                            </p>
                        </div>
                        <div id="rfc.section.6.10.p.6">
                            <p>CONTINUATION フレームはストリームに関連付けられていることが <em class="bcp14">MUST</em> です。Stream Identifier が
                                0x00
                                の CONTINUATION フレームを受信した場合、受信者は <a href="#ConnectionErrorHandler"
                                    title="Connection Error Handling">Section 5.4.1</a>
                                の種類の接続エラー（PROTOCOL_ERROR）で応答しなければなりません。</p>
                        </div>
                        <div id="rfc.section.6.10.p.7">
                            <p>CONTINUATION フレームは END_HEADERS フラグが設定されていない HEADERS、PUSH_PROMISE、または CONTINUATION
                                フレームに続くものでなければなりません。受信者がこの規則に違反していることを観測した場合、受信者は <a href="#ConnectionErrorHandler"
                                    title="Connection Error Handling">Section 5.4.1</a> の種類の接続エラー（<a
                                    href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>）で応答しなければなりません。</p>
                        </div>
                    </section>
                </section>
                <hr class="hidden-print">
                <section id="ErrorCodes">
                    <h2 id="rfc.section.7" class="np"><a href="#rfc.section.7">7.</a>&nbsp;<a
                            href="#ErrorCodes">エラーコード</a>
                    </h2>
                    <div id="rfc.section.7.p.1">
                        <p>エラーコードは 32 ビットのフィールドで、<a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> および <a
                                href="#GOAWAY" title="GOAWAY">GOAWAY</a> フレームで使用され、ストリームや接続エラーの理由を伝達します。</p>
                    </div>
                    <div id="rfc.section.7.p.2">
                        <p>エラーコードは共通のコード空間を共有します。いくつかのエラーコードはストリームにのみ適用されるか接続全体にのみ適用されるもので、他の文脈では定義された意味を持ちません。</p>
                    </div>
                    <div id="rfc.section.7.p.3" class="avoidbreakafter">
                        <p>次のエラーコードが定義されています：</p>
                    </div>
                    <div id="rfc.section.7.p.4">
                        <dl>
                            <dt>NO_ERROR (0x00):</dt>
                            <dd id="NO_ERROR" style="margin-left: 1.5em">関連する状態がエラーの結果ではないことを示します。例えば、<a href="#GOAWAY"
                                    title="GOAWAY">GOAWAY</a> が接続の優雅なシャットダウンを示すためにこのコードを含む場合があります。</dd>
                            <dt>PROTOCOL_ERROR (0x01):</dt>
                            <dd id="PROTOCOL_ERROR" style="margin-left: 1.5em">
                                エンドポイントが特定されないプロトコルエラーを検出したことを示します。より具体的なエラーコードが利用できない場合に使用されます。</dd>
                            <dt>INTERNAL_ERROR (0x02):</dt>
                            <dd id="INTERNAL_ERROR" style="margin-left: 1.5em">エンドポイントが予期しない内部エラーに遭遇したことを示します。</dd>
                            <dt>FLOW_CONTROL_ERROR (0x03):</dt>
                            <dd id="FLOW_CONTROL_ERROR" style="margin-left: 1.5em">
                                ピアがフロー制御プロトコルに違反したことをエンドポイントが検出したことを示します。
                            </dd>
                            <dt>SETTINGS_TIMEOUT (0x04):</dt>
                            <dd id="SETTINGS_TIMEOUT" style="margin-left: 1.5em">エンドポイントが <a href="#SETTINGS"
                                    title="SETTINGS">SETTINGS</a> フレームを送信したが、タイムリーに応答を受け取らなかったことを示します。詳細は <a
                                    href="#SettingsSync" title="Settings Synchronization">Section 6.5.3</a>（「Settings
                                Synchronization」）を参照してください。</dd>
                            <dt>STREAM_CLOSED (0x05):</dt>
                            <dd id="STREAM_CLOSED" style="margin-left: 1.5em">ストリームが半クローズ状態の後にフレームを受信したことを示します。</dd>
                            <dt>FRAME_SIZE_ERROR (0x06):</dt>
                            <dd id="FRAME_SIZE_ERROR" style="margin-left: 1.5em">無効なサイズのフレームを受信したことを示します。</dd>
                            <dt>REFUSED_STREAM (0x07):</dt>
                            <dd id="REFUSED_STREAM" style="margin-left: 1.5em">
                                エンドポイントがアプリケーション処理を行う前にストリームを拒否したことを示します（詳細は
                                <a href="#Reliability" title="Request Reliability">Section 8.7</a> を参照）。
                            </dd>
                            <dt>CANCEL (0x08):</dt>
                            <dd id="CANCEL" style="margin-left: 1.5em">ストリームがもはや不要であることを示すためにエンドポイントが使用するエラーコードです。</dd>
                            <dt>COMPRESSION_ERROR (0x09):</dt>
                            <dd id="COMPRESSION_ERROR" style="margin-left: 1.5em">接続のフィールドセクション圧縮コンテキストを維持できないことを示します。
                            </dd>
                            <dt>CONNECT_ERROR (0x0a):</dt>
                            <dd id="CONNECT_ERROR" style="margin-left: 1.5em">CONNECT リクエスト（<a href="#CONNECT"
                                    title="The CONNECT Method">Section 8.5</a>）に応じて確立された接続がリセットされたか異常に閉じられたことを示します。</dd>
                            <dt>ENHANCE_YOUR_CALM (0x0b):</dt>
                            <dd id="ENHANCE_YOUR_CALM" style="margin-left: 1.5em">
                                ピアが過剰な負荷を生成している可能性のある振る舞いを示すことをエンドポイントが検出したことを示します。</dd>
                            <dt>INADEQUATE_SECURITY (0x0c):</dt>
                            <dd id="INADEQUATE_SECURITY" style="margin-left: 1.5em">
                                基盤となるトランスポートが最低限のセキュリティ要件を満たしていない特性を持つことを示します（<a href="#TLSUsage"
                                    title="Use of TLS Features">Section 9.2</a> を参照）。</dd>
                            <dt>HTTP_1_1_REQUIRED (0x0d):</dt>
                            <dd id="HTTP_1_1_REQUIRED" style="margin-left: 1.5em">エンドポイントが HTTP/2 の代わりに HTTP/1.1
                                の使用を要求していることを示します。</dd>
                        </dl>
                    </div>
                    <div id="rfc.section.7.p.5">
                        <p>未知またはサポートされないエラーコードは特別な動作を引き起こしては <em class="bcp14">MUST NOT</em> なりません。これらは実装によって <a
                                href="#INTERNAL_ERROR">INTERNAL_ERROR</a> と同等として扱ってもよい（<em class="bcp14">MAY</em>）です。
                        </p>
                    </div>
                </section>
                <hr class="hidden-print">
                <section id="HttpLayer">
                    <h2 id="rfc.section.8" class="np"><a href="#rfc.section.8">8.</a>&nbsp;<a href="#HttpLayer">HTTP/2
                            における
                            HTTP セマンティクスの表現</a></h2>
                    <div id="rfc.section.8.p.1">
                        <p>HTTP/2 は HTTP メッセージ抽象の具現化です（<a
                                href="https://www.rfc-editor.org/rfc/rfc9110.html#section-6">RFC
                                9110 の Section 6</a> を参照）。</p>
                    </div>
                    <section id="HttpFraming">
                        <h3 id="rfc.section.8.1"><a href="#rfc.section.8.1">8.1.</a>&nbsp;<a href="#HttpFraming">HTTP
                                メッセージのフレーミング</a></h3>
                        <div id="rfc.section.8.1.p.1">
                            <p>クライアントは新しいストリーム上で未使用のストリーム識別子を使って HTTP リクエストを送信します（<a href="#StreamIdentifiers"
                                    title="Stream Identifiers">Section 5.1.1</a> を参照）。サーバーは同じストリーム上で HTTP レスポンスを送信します。
                            </p>
                        </div>
                        <div id="rfc.section.8.1.p.2" class="avoidbreakafter">
                            <p>HTTP メッセージ（リクエストまたはレスポンス）は次で構成されます：</p>
                        </div>
                        <div id="rfc.section.8.1.p.3">
                            <ol type="1">
                                <li>1 個の <a href="#HEADERS" title="HEADERS">HEADERS</a> フレーム（続くゼロ個以上の <a
                                        href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a>
                                    フレームを含む）でヘッダセクションを含む（詳細は
                                    RFC 9110 の <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-6.3">Section
                                        6.3</a> を参照）,</li>
                                <li>ゼロ個以上の <a href="#DATA" title="DATA">DATA</a> フレームでメッセージ本文を含む（RFC 9110 の <a
                                        href="https://www.rfc-editor.org/rfc/rfc9110.html#section-6.4">Section 6.4</a>
                                    を参照）,
                                </li>
                                <li>オプションで、トレーラセクションが存在する場合は 1 個の <a href="#HEADERS" title="HEADERS">HEADERS</a>
                                    フレーム（続くゼロ個以上の <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a>
                                    フレームを含む）でトレーラを含む（RFC 9110 の <a
                                        href="https://www.rfc-editor.org/rfc/rfc9110.html#section-6.5">Section 6.5</a>
                                    を参照）。
                                </li>
                            </ol>
                        </div>
                        <div id="rfc.section.8.1.p.4">
                            <p>レスポンスに関してのみ、サーバーは最終的なレスポンスを含む <a href="#HEADERS" title="HEADERS">HEADERS</a>
                                フレームの前に任意の数の中間レスポンスを送信してもよい（<em class="bcp14">MAY</em>）。中間レスポンスは中間（1xx） HTTP
                                レスポンスの制御データとヘッダセクションを含む <a href="#HEADERS" title="HEADERS">HEADERS</a> フレーム（続くゼロ個以上の <a
                                    href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a>
                                フレームを含む）からなります。情報的なステータスコードを持つ <a href="#HEADERS" title="HEADERS">HEADERS</a> フレームが
                                END_STREAM フラグを持つ場合は誤形成です（<a href="#malformed" title="Malformed Messages">Section
                                    8.1.1</a>）。</p>
                        </div>
                        <div id="rfc.section.8.1.p.5">
                            <p>シーケンスの最後のフレームは END_STREAM フラグを伴い、<a href="#HEADERS" title="HEADERS">HEADERS</a> フレームに
                                END_STREAM が設定されていても残りのフィールドブロック断片を運ぶ <a href="#CONTINUATION"
                                    title="CONTINUATION">CONTINUATION</a> フレームが続く可能性があることを示します。</p>
                        </div>
                        <div id="rfc.section.8.1.p.6">
                            <p>他のフレーム（任意のストリームからの）は、<a href="#HEADERS" title="HEADERS">HEADERS</a> フレームとそれに続く <a
                                    href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a> フレームの間に発生してはなりません（<em
                                    class="bcp14">MUST NOT</em>）。</p>
                        </div>
                        <div id="rfc.section.8.1.p.7">
                            <p>HTTP/2 はメッセージ本文を運ぶために DATA フレームを使用します。<span class="tt">chunked</span> 転送エンコーディング（RFC 9112
                                の
                                Section 7.1）は HTTP/2 では使用できません；詳細は <a href="#ConnectionSpecific"
                                    title="Connection-Specific Header Fields">Section 8.2.2</a> を参照してください。</p>
                        </div>
                        <div id="rfc.section.8.1.p.8">
                            <p>トレーラフィールドはストリームを終了するフィールドブロック内で運ばれます。つまり、トレーラは END_STREAM フラグを持つ <a href="#HEADERS"
                                    title="HEADERS">HEADERS</a> フレームで始まり、続けてゼロ個以上の <a href="#CONTINUATION"
                                    title="CONTINUATION">CONTINUATION</a> フレームがあり、HEADERS フレームが END_STREAM
                                を持ちます。トレーラは擬似ヘッダーフィールド（<a href="#PseudoHeaderFields" title="HTTP Control Data">Section
                                    8.3</a>）を含んでは <em class="bcp14">MUST NOT</em>
                                なりません。トレーラ内に擬似ヘッダーフィールドを受信したエンドポイントは、そのリクエストまたはレスポンスを誤形成として扱わなければなりません（<a
                                    href="#malformed" title="Malformed Messages">Section 8.1.1</a>）。</p>
                        </div>
                        <div id="rfc.section.8.1.p.9">
                            <p>リクエストまたは最終（情報的でない）ステータスコードを含むレスポンスのオープニングとなる <a href="#HEADERS"
                                    title="HEADERS">HEADERS</a>
                                フレームの後に、END_STREAM フラグが設定されていない <a href="#HEADERS" title="HEADERS">HEADERS</a>
                                フレームを受信したエンドポイントは、その対応するリクエストまたはレスポンスを誤形成として扱わなければなりません（<a href="#malformed"
                                    title="Malformed Messages">Section 8.1.1</a>）。</p>
                        </div>
                        <div id="rfc.section.8.1.p.10">
                            <p>HTTP リクエスト／レスポンス交換は単一のストリームを完全に消費します。リクエストはストリームを "open" にする HEADERS フレームで始まり、END_STREAM
                                フラグを持つフレームで終了します。これによりクライアント側は "half-closed (local)"、サーバー側は "half-closed (remote)"
                                になります。レスポンスストリームはゼロ個以上の中間レスポンス（HEADERS フレーム）で始まり、最終ステータスコードを含む HEADERS フレームが続きます。</p>
                        </div>
                        <div id="rfc.section.8.1.p.11">
                            <p>サーバーが送信する、またはクライアントが受信する END_STREAM フラグを持つフレーム（必要ならそれを完了する <a href="#CONTINUATION"
                                    title="CONTINUATION">CONTINUATION</a> フレームを含む）をもって HTTP
                                レスポンスは完了します。サーバーはリクエストの未送信部分に依存しない場合、クライアントがリクエスト全体を送信する前に完全なレスポンスを送信できる（<em
                                    class="bcp14">MAY</em>）ことがあります。この場合、サーバーは完全なレスポンス（END_STREAM
                                を持つフレーム）を送信した後にクライアントにエラーなしで送信の中止を要求するために、<a href="#RST_STREAM"
                                    title="RST_STREAM">RST_STREAM</a> を <a href="#NO_ERROR">NO_ERROR</a> で送信してもよい（<em
                                    class="bcp14">MAY</em>）。クライアントはそのような RST_STREAM を受信したからといってレスポンスを破棄しては <em
                                    class="bcp14">MUST NOT</em> なりませんが、他の理由でレスポンスを破棄することは常にできます。</p>
                        </div>
                        <section id="malformed">
                            <h4 id="rfc.section.8.1.1"><a href="#rfc.section.8.1.1">8.1.1.</a>&nbsp;<a
                                    href="#malformed">誤形成メッセージ</a></h4>
                            <div id="rfc.section.8.1.1.p.1">
                                <p>誤形成のリクエストまたはレスポンスとは、HTTP/2
                                    フレームの一見有効な列であるが、余分なフレーム、禁止されたフィールドや擬似ヘッダーフィールドの存在、必須擬似ヘッダーフィールドの欠如、大文字のフィールド名の含有、あるいは特定の状況での無効なフィールド名や値のために無効となるものです（詳細は
                                    <a href="#HttpHeaders" title="HTTP Fields">Section 8.2</a> を参照）。
                                </p>
                            </div>
                            <div id="rfc.section.8.1.1.p.2">
                                <p>メッセージ本文を含むリクエストまたはレスポンスは <span class="tt">content-length</span>
                                    ヘッダフィールドを含めることができます。<span class="tt">content-length</span> の値が、コンテンツを構成する <a
                                        href="#DATA" title="DATA">DATA</a>
                                    フレームのペイロード長の合計と等しくない場合、そのメッセージは誤形成と見なされます（メッセージがコンテンツを持たないと定義されている場合を除く）。例えば 204 や
                                    304
                                    のレスポンスはコンテンツを含まないなどです。コンテンツを持たないと定義されたレスポンスであっても、非ゼロの <span
                                        class="tt">content-length</span> ヘッダフィールドを持つことは <em class="bcp14">MAY</em>
                                    ありますが、その場合 DATA フレームにコンテンツは含まれません。</p>
                            </div>
                            <div id="rfc.section.8.1.1.p.3">
                                <p>HTTP リクエストやレスポンスを処理するインターミディアリ（トンネルとして動作していないもの）は、誤形成のリクエストやレスポンスを転送しては <em
                                        class="bcp14">MUST NOT</em> なりません。検出された誤形成のリクエストやレスポンスはストリームエラー（<a
                                        href="#StreamErrorHandler" title="Stream Error Handling">Section 5.4.2</a>）の <a
                                        href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a> として扱わなければなりません（<em
                                        class="bcp14">MUST</em>）。</p>
                            </div>
                            <div id="rfc.section.8.1.1.p.4">
                                <p>誤形成のリクエストに対しては、サーバーはストリームを閉じたりリセットする前に HTTP レスポンスを送信してもよい（<em
                                        class="bcp14">MAY</em>）。クライアントは誤形成のレスポンスを受け入れては <em class="bcp14">MUST NOT</em>
                                    なりません。</p>
                            </div>
                            <div id="rfc.section.8.1.1.p.5">
                                <p>メッセージを逐次処理するエンドポイントは、リクエストやレスポンスを誤形成と識別する前に一部を処理している可能性があります。例えば、完全なリクエストを受け取る前に情報的なステータスや
                                    404
                                    を生成することが可能な場合があります。同様に、インターミディアリはエラーを検出する前に不完全なメッセージを転送することがあり得ます。サーバーは、レスポンスが残りのリクエストに依存しない場合に限り、完全なレスポンスを生成してもよい（<em
                                        class="bcp14">MAY</em>）。</p>
                            </div>
                            <div id="rfc.section.8.1.1.p.6">
                                <p>これらの要件は HTTP に対する一般的な攻撃から保護することを意図しており、寛容にするよりも厳格にする方が脆弱性にさらされにくいため、意図的に厳格に定められています。
                                </p>
                            </div>
                        </section>
                    </section>
                    <section id="HttpHeaders">
                        <h3 id="rfc.section.8.2"><a href="#rfc.section.8.2">8.2.</a>&nbsp;<a href="#HttpHeaders">HTTP
                                フィールド</a></h3>
                        <div id="rfc.section.8.2.p.1">
                            <p>HTTP フィールド（RFC 9110 の Section 5）は <a href="#HEADERS" title="HEADERS">HEADERS</a>, <a
                                    href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a>, および <a
                                    href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> フレームで伝達され、HPACK（<a
                                    href="#RFC7541"
                                    title="HPACK: Header Compression for HTTP/2">[COMPRESSION]</a>）で圧縮されます。</p>
                        </div>
                        <div id="rfc.section.8.2.p.2">
                            <p>フィールド名は HTTP/2 メッセージを構築する際に小文字に変換しなければ <em class="bcp14">MUST</em> なりません。</p>
                        </div>
                        <section id="n-field-validity">
                            <h4 id="rfc.section.8.2.1"><a href="#rfc.section.8.2.1">8.2.1.</a>&nbsp;<a
                                    href="#n-field-validity">フィールドの妥当性</a></h4>
                            <div id="rfc.section.8.2.1.p.1">
                                <p>HPACK が伝達できるいくつかの文字が、HTTP のフィールド名や値の定義では禁止されている場合があります。HTTP/2 実装は RFC 9110 の Sections
                                    <a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-5.1">5.1</a> および <a
                                        href="https://www.rfc-editor.org/rfc/rfc9110.html#section-5.5">5.5</a>
                                    に従ってフィールド名と値を検証することが <em class="bcp14">SHOULD</em> 求められ、禁止文字を含むメッセージは誤形成として扱うべきです（<a
                                        href="#malformed" title="Malformed Messages">Section 8.1.1</a>）。
                                </p>
                            </div>
                            <div id="rfc.section.8.2.1.p.2" class="avoidbreakafter">
                                <p>フィールドを検証しないとリクエストスマグリング攻撃に悪用される可能性があります。特に、未検証のフィールドは HTTP/1.1 にフォワードされる際に区切り文字として
                                    CR、LF、COLON などが使われるため攻撃を可能にすることがあります。実装はフィールド名と値に対して次の最小限の検証を <em
                                        class="bcp14">MUST</em> 行う必要があります：</p>
                            </div>
                            <div id="rfc.section.8.2.1.p.3">
                                <ul>
                                    <li>フィールド名は 0x00-0x20、0x41-0x5a、または 0x7f-0xff の範囲の文字を含んでは <em class="bcp14">MUST
                                            NOT</em> なりません（すべて含む）。これは非表示の ASCII 文字、ASCII SP（0x20）、および大文字字符（'A'〜'Z',
                                        ASCII
                                        0x41〜0x5a）を除外します。</li>
                                    <li>擬似ヘッダーフィールド（<a href="#PseudoHeaderFields" title="HTTP Control Data">Section
                                            8.3</a>）を除き、フィールド名にコロン（ASCII COLON, 0x3a）を含んでは <em class="bcp14">MUST
                                            NOT</em>
                                        なりません。</li>
                                    <li>フィールド値はゼロ値（ASCII NUL, 0x00）、ラインフィード（ASCII LF, 0x0a）、またはキャリッジリターン（ASCII CR,
                                        0x0d）を任意の位置に含んでは <em class="bcp14">MUST NOT</em> なりません。</li>
                                    <li>フィールド値は ASCII 空白文字（ASCII SP または HTAB, 0x20 または 0x09）で始まったり終わったりしては <em
                                            class="bcp14">MUST NOT</em> なりません。</li>
                                </ul>
                            </div>
                            <div id="rfc.section.8.2.1.p.4">
                                <aside>
                                    <div id="rfc.section.8.2.1.p.4.1">
                                        <p>注：RFC 9110 の該当セクションに従ってフィールドを検証する実装は、フィールド名に大文字が含まれていないことを追加でチェックすれば十分です。</p>
                                    </div>
                                </aside>
                            </div>
                            <div id="rfc.section.8.2.1.p.5">
                                <p>これらの条件に違反するフィールドを含むリクエストまたはレスポンスは誤形成として扱われなければなりません（<a href="#malformed"
                                        title="Malformed Messages">Section
                                        8.1.1</a>）。特に、転送時にフィールドを処理しないインターミディアリは、上で禁止された値を含むフィールドを転送しては <em
                                        class="bcp14">MUST NOT</em> なりません。</p>
                            </div>
                            <div id="rfc.section.8.2.1.p.6">
                                <p>リクエストメッセージがこれらの要件に違反する場合、実装は 400 (Bad Request) ステータスコードを生成することを <em
                                        class="bcp14">SHOULD</em> 勧めます（RFC 9110 の Section 15.5.1
                                    を参照）、ただしより適切なステータスが定義されている場合やステータスを送信できない場合（例えばトレーラフィールドのエラー）を除きます。</p>
                            </div>
                            <div id="rfc.section.8.2.1.p.7">
                                <aside>
                                    <div id="rfc.section.8.2.1.p.7.1">
                                        <p>注：特定フィールドの定義に従って有効でないフィールド値は、該当フィールドの定義に基づく無効性であってもリクエストを誤形成にするものではありません；上の要件は
                                            RFC 9110 の Section 5 で定義されたフィールドの一般構文にのみ適用されます。</p>
                                    </div>
                                </aside>
                            </div>
                        </section>
                        <section id="ConnectionSpecific">
                            <h4 id="rfc.section.8.2.2"><a href="#rfc.section.8.2.2">8.2.2.</a>&nbsp;<a
                                    href="#ConnectionSpecific">接続特有のヘッダフィールド</a></h4>
                            <div id="rfc.section.8.2.2.p.1">
                                <p>HTTP/2 は接続特有のヘッダフィールドを示すために <span class="tt">Connection</span> ヘッダフィールドを使用しません（RFC
                                    9110 の
                                    Section 7.6.1 を参照）。このプロトコルでは接続特有のメタデータは他の手段で伝達されます。エンドポイントは接続特有のヘッダフィールドを含む HTTP/2
                                    メッセージを生成しては <em class="bcp14">MUST NOT</em> なりません。これには <span
                                        class="tt">Connection</span> ヘッダと、RFC 9110 の Section 7.6.1
                                    に接続特有の意味を持つと列挙されているもの（<span class="tt">Proxy-Connection</span>, <span
                                        class="tt">Keep-Alive</span>, <span class="tt">Transfer-Encoding</span>, <span
                                        class="tt">Upgrade</span>）が含まれます。これらを含むメッセージは誤形成として扱われなければなりません（<a
                                        href="#malformed" title="Malformed Messages">Section 8.1.1</a>）。</p>
                            </div>
                            <div id="rfc.section.8.2.2.p.2">
                                <p>唯一の例外は TE ヘッダフィールドであり、HTTP/2 リクエストに存在しても <em class="bcp14">MAY</em> です；ただし存在する場合は
                                    "trailers" 以外の値を含んでは <em class="bcp14">MUST NOT</em> なりません。</p>
                            </div>
                            <div id="rfc.section.8.2.2.p.3">
                                <p>HTTP/1.x メッセージを HTTP/2 に変換するインターミディアリは、RFC 9110 の Section 7.6.1
                                    で議論されているように接続特有のヘッダフィールドを削除しなければなりません（さもなければ、そのメッセージは他の HTTP/2
                                    エンドポイントにより誤形成として扱われます）。
                                </p>
                            </div>
                            <div id="rfc.section.8.2.2.p.4">
                                <aside>
                                    <div id="rfc.section.8.2.2.p.4.1">
                                        <p>注：HTTP/2 は意図的に他のプロトコルへのアップグレードをサポートしていません。<a href="#starting"
                                                title="Starting HTTP/2">Section 3</a>
                                            に記載されたハンドシェイク方法で代替プロトコルの使用を交渉するのに十分であると考えられています。</p>
                                    </div>
                                </aside>
                            </div>
                        </section>
                        <section id="CompressCookie">
                            <h4 id="rfc.section.8.2.3"><a href="#rfc.section.8.2.3">8.2.3.</a>&nbsp;<a
                                    href="#CompressCookie">Cookie ヘッダフィールドの圧縮</a></h4>
                            <div id="rfc.section.8.2.3.p.1">
                                <p><a href="#RFC6265"><cite title="HTTP State Management Mechanism">Cookie header
                                            field</cite></a>（[COOKIE]）はセミコロン（";"）で
                                    cookie-pair（"crumbs"）を区切ります。このヘッダは複数の値を含みますが、コンマ（","）を区切りに使用しないため、cookie-pair
                                    を複数のフィールド行に分割して送信することを防ぎます（RFC 9110 の Section 5.2
                                    を参照）。これにより圧縮効率が著しく低下する可能性があります。なぜなら個別の
                                    cookie-pair の更新が HPACK テーブルに保存されたフィールド行を無効化するからです。</p>
                            </div>
                            <div id="rfc.section.8.2.3.p.2">
                                <p>圧縮効率を向上させるために、Cookie ヘッダフィールドは分割され、それぞれが 1 個以上の cookie-pair
                                    を持つ別個のヘッダフィールドとして送信されてもよい（<em class="bcp14">MAY</em>）。復号後に複数の Cookie
                                    ヘッダフィールドが存在する場合、それらは HTTP/1.1 接続などの非 HTTP/2
                                    コンテキストに渡される前に、2 バイトの区切り 0x3b, 0x20（ASCII 文字列 "; "）で連結されなければ <em
                                        class="bcp14">MUST</em>
                                    なりません。</p>
                            </div>
                            <div id="rfc.section.8.2.3.p.3" class="avoidbreakafter">
                                <p>したがって、次の 2 つの Cookie ヘッダリストは意味的に等価です。</p>
                            </div>
                            <div id="rfc.section.8.2.3.p.4">
                                <pre class="inline">
cookie: a=b; c=d; e=f

cookie: a=b
cookie: c=d
cookie: e=f
</pre>
                            </div>
                        </section>
                    </section>
                    <section id="PseudoHeaderFields">
                        <h3 id="rfc.section.8.3"><a href="#rfc.section.8.3">8.3.</a>&nbsp;<a
                                href="#PseudoHeaderFields">HTTP
                                制御データ</a></h3>
                        <div id="rfc.section.8.3.p.1">
                            <p>HTTP/2 は ':'（ASCII 0x3a）で始まる特殊な擬似ヘッダーフィールドを使用してメッセージ制御データを伝達します（RFC 9110 の Section 6.2
                                を参照）。
                            </p>
                        </div>
                        <div id="rfc.section.8.3.p.2">
                            <p>擬似ヘッダーフィールドは HTTP ヘッダーフィールドではありません。エンドポイントは本書で定義されたもの以外の擬似ヘッダーフィールドを生成しては <em
                                    class="bcp14">MUST NOT</em> なりません。拡張が追加の擬似ヘッダーフィールドの使用をネゴシエートする可能性がある点には注意してください（<a
                                    href="#extensibility" title="Extending HTTP/2">Section 5.5</a>）。</p>
                        </div>
                        <div id="rfc.section.8.3.p.3">
                            <p>擬似ヘッダーフィールドは定義されている文脈でのみ有効です。リクエスト用に定義された擬似ヘッダーはレスポンスに現れては <em class="bcp14">MUST
                                    NOT</em>
                                ならず、レスポンス用に定義された擬似ヘッダーはリクエストに現れては <em class="bcp14">MUST NOT</em>
                                です。擬似ヘッダーフィールドはトレーラセクションに現れては <em class="bcp14">MUST NOT</em>
                                ならず、未定義または無効な擬似ヘッダーを含むリクエストやレスポンスは誤形成として扱われなければなりません（<a href="#malformed"
                                    title="Malformed Messages">Section 8.1.1</a>）。</p>
                        </div>
                        <div id="rfc.section.8.3.p.4">
                            <p>すべての擬似ヘッダーフィールドは、通常のフィールド行よりも前にフィールドブロック内に現れなければ <em class="bcp14">MUST</em>
                                なりません。通常のフィールド行の後に擬似ヘッダーが現れるフィールドブロックは誤形成として扱われなければなりません（<a href="#malformed"
                                    title="Malformed Messages">Section 8.1.1</a>）。</p>
                        </div>
                        <div id="rfc.section.8.3.p.5">
                            <p>同じ擬似ヘッダーフィールド名はフィールドブロック内に複数回現れては <em class="bcp14">MUST NOT</em>
                                なりません。リクエストやレスポンスのフィールドブロックに重複した擬似ヘッダーフィールド名が含まれる場合、そのメッセージは誤形成として扱われなければなりません（<a
                                    href="#malformed" title="Malformed Messages">Section 8.1.1</a>）。</p>
                        </div>
                        <section id="HttpRequest">
                            <h4 id="rfc.section.8.3.1"><a href="#rfc.section.8.3.1">8.3.1.</a>&nbsp;<a
                                    href="#HttpRequest">リクエスト擬似ヘッダーフィールド</a></h4>
                            <div id="rfc.section.8.3.1.p.1" class="avoidbreakafter">
                                <p>HTTP/2 リクエストに対して次の擬似ヘッダーフィールドが定義されています：</p>
                            </div>
                            <div id="rfc.section.8.3.1.p.2">
                                <ul>
                                    <li>
                                        <div>
                                            <p>「<span class="tt">:method</span>」擬似ヘッダーフィールドは HTTP メソッドを含みます（RFC 9110 の
                                                Section 9 を参照）。</p>
                                        </div>
                                    </li>
                                    <li>
                                        <div>
                                            <p>「<span
                                                    class="tt">:scheme</span>」擬似ヘッダーフィールドはリクエストターゲットのスキーム部分を含みます。スキームは直接リクエストを生成する場合はターゲット
                                                URI から、あるいは変換されたリクエストの場合は変換元のスキームから取られます（CONNECT リクエストでは省略されます；<a
                                                    href="#CONNECT" title="The CONNECT Method">Section 8.5</a> を参照）。</p>
                                        </div>
                                        <div>
                                            <p>"<span class="tt">:scheme</span>" は "<span class="tt">http</span>" や
                                                "<span class="tt">https</span>" に限定されません。プロキシやゲートウェイは非 HTTP
                                                スキームのリクエストを翻訳して
                                                HTTP を用いて非 HTTP サービスとやり取りすることができます。</p>
                                        </div>
                                    </li>
                                    <li>
                                        <div>
                                            <p>「<span class="tt">:authority</span>」擬似ヘッダーフィールドはターゲット URI
                                                の権限部分（authority）を伝えます。HTTP/2 リクエストの受信者は "<span
                                                    class="tt">:authority</span>"
                                                が存在する場合、ターゲット URI を決定するために <span class="tt">Host</span> ヘッダフィールドを使用しては
                                                <em class="bcp14">MUST NOT</em> です。
                                            </p>
                                        </div>
                                        <div>
                                            <p>直接 HTTP/2 リクエストを生成するクライアントは、権限情報を伝えるために "<span
                                                    class="tt">:authority</span>"
                                                を使用しなければ <em class="bcp14">MUST</em> です。権限情報がない場合は "<span
                                                    class="tt">:authority</span>" を生成しては <em class="bcp14">MUST NOT</em>
                                                です。
                                            </p>
                                        </div>
                                        <div>
                                            <p>クライアントは "<span class="tt">:authority</span>" と異なる <span
                                                    class="tt">Host</span> ヘッダを生成しては <em class="bcp14">MUST NOT</em>
                                                です。サーバーは "<span class="tt">:authority</span>" と異なる <span
                                                    class="tt">Host</span> を含むリクエストを誤形成として扱うべき（<em
                                                    class="bcp14">SHOULD</em>）です。比較のために値は正規化される必要があります（RFC 3986 Section
                                                6.2
                                                を参照）。オリジンサーバーは任意の正規化を適用できますが、その他のサーバーはスキームベースの正規化を <em
                                                    class="bcp14">MUST</em> 行わなければなりません。</p>
                                        </div>
                                        <div>
                                            <p>HTTP/2 上でリクエストを転送するインターミディアリは、元のリクエストの制御データから権限情報を用いて "<span
                                                    class="tt">:authority</span>" を構築しなければ <em class="bcp14">MUST</em>
                                                なり、元リクエストのターゲット URI に権限情報がない場合は生成しては <em class="bcp14">MUST NOT</em>
                                                です。<span class="tt">Host</span> ヘッダはこの情報の唯一の源ではない点に注意してください。</p>
                                        </div>
                                        <div>
                                            <p>インターミディアリが HTTP/1.1 リクエストの構築のために <span class="tt">Host</span>
                                                フィールドを生成する必要がある場合、インターミディアリは "<span class="tt">:authority</span>" の値を
                                                <span class="tt">Host</span> の値として使用しなければ <em class="bcp14">MUST</em>
                                                です（リクエストターゲットを変更する場合を除く）。これは潜在的な HTTP ルーティングの脆弱性を避けるために既存の <span
                                                    class="tt">Host</span> を置き換えます。
                                            </p>
                                        </div>
                                        <div>
                                            <p>インターミディアリは HTTP/2 上でリクエストを転送する際に既存の <span class="tt">Host</span>
                                                ヘッダを保持してもよい（<em class="bcp14">MAY</em>）。</p>
                                        </div>
                                        <div>
                                            <p>CONNECT またはアスタリスク形式の OPTIONS リクエストのターゲットは権限情報を含まないことに注意してください。</p>
                                        </div>
                                        <div>
                                            <p>"<span class="tt">:authority</span>" は "<span class="tt">http</span>" または
                                                "<span class="tt">https</span>" スキームの URI に対して廃止された userinfo
                                                サブコンポーネントを含んでは
                                                <em class="bcp14">MUST NOT</em> です。
                                            </p>
                                        </div>
                                    </li>
                                    <li>
                                        <div>
                                            <p>「<span class="tt">:path</span>」擬似ヘッダーフィールドはターゲット URI
                                                のパスとクエリ部分（absolute-path
                                                と、オプションで '?' と query）を含みます。オプションのアスタリスク形式のリクエスト（OPTIONS）の場合は "<span
                                                    class="tt">:path</span>" に '*' を含みます。</p>
                                        </div>
                                        <div class="avoidbreakafter">
                                            <p>この擬似ヘッダーは "<span class="tt">http</span>" または "<span
                                                    class="tt">https</span>"
                                                の URI に対して空にしては <em class="bcp14">MUST NOT</em> です。パス成分を持たない "<span
                                                    class="tt">http</span>" や "<span class="tt">https</span>" の URI は
                                                '/'
                                                を含めなければ <em class="bcp14">MUST</em> です。例外は：</p>
                                        </div>
                                        <div>
                                            <ul>
                                                <li>パス成分を持たない "<span class="tt">http</span>" または "<span
                                                        class="tt">https</span>" URI に対する OPTIONS リクエストは "<span
                                                        class="tt">:path</span>" に '*' を含めなければ <em
                                                        class="bcp14">MUST</em>
                                                    です。</li>
                                                <li>CONNECT リクエストでは "<span class="tt">:path</span>" は省略されます。</li>
                                            </ul>
                                        </div>
                                    </li>
                                </ul>
                            </div>
                            <div id="rfc.section.8.3.1.p.3">
                                <p>すべての HTTP/2 リクエストは、CONNECT リクエストを除き、"<span class="tt">:method</span>", "<span
                                        class="tt">:scheme</span>", および "<span class="tt">:path</span>" の各擬似ヘッダーをちょうど 1
                                    個ずつ持たなければ <em class="bcp14">MUST</em> なり、これらが欠けているリクエストは誤形成と見なされます（<a
                                        href="#malformed" title="Malformed Messages">Section 8.1.1</a>）。</p>
                            </div>
                            <div id="rfc.section.8.3.1.p.4">
                                <p>個々の HTTP/2 リクエストは明示的なプロトコルバージョン指示を持ちません。すべての HTTP/2 リクエストは暗黙にプロトコルバージョン "2.0"
                                    を持っています。
                                </p>
                            </div>
                        </section>
                        <section id="HttpResponse">
                            <h4 id="rfc.section.8.3.2"><a href="#rfc.section.8.3.2">8.3.2.</a>&nbsp;<a
                                    href="#HttpResponse">レスポンス擬似ヘッダーフィールド</a></h4>
                            <div id="rfc.section.8.3.2.p.1">
                                <p>HTTP/2 レスポンスには "<span class="tt">:status</span>" という単一の擬似ヘッダーフィールドが定義され、HTTP
                                    ステータスコードフィールドを運びます。すべてのレスポンス（中間レスポンスを含む）にこの擬似ヘッダーが含まれていなければ <em
                                        class="bcp14">MUST</em>
                                    なりません。欠けている場合、そのレスポンスは誤形成です（<a href="#malformed" title="Malformed Messages">Section
                                        8.1.1</a>）。</p>
                            </div>
                            <div id="rfc.section.8.3.2.p.2">
                                <p>HTTP/2 レスポンスは暗黙にプロトコルバージョン "2.0" を持ちます。</p>
                            </div>
                        </section>
                    </section>
                    <section id="PushResources">
                        <h3 id="rfc.section.8.4"><a href="#rfc.section.8.4">8.4.</a>&nbsp;<a
                                href="#PushResources">サーバープッシュ</a></h3>
                        <div id="rfc.section.8.4.p.1">
                            <p>HTTP/2
                                はサーバーが先行してレスポンス（それに対応する「約束された」リクエストと共に）をクライアントに送信（「プッシュ」）できる機能を許可します。これは以前のクライアント発行リクエストに関連して行われます。
                            </p>
                        </div>
                        <div id="rfc.section.8.4.p.2">
                            <p>サーバープッシュは、サーバーが受け取ったリクエストに続いてクライアントが行うであろう追加リクエストを予測することでクライアント側の体感性能を改善するために設計されました。例えば
                                HTML
                                のリクエストにはしばしばスタイルシートやスクリプトへの参照が続きます。これらをプッシュすれば、クライアントは HTML
                                を受け取ってそれらの参照を検出し別途リクエストを出すまで待つ必要がありません。</p>
                        </div>
                        <div id="rfc.section.8.4.p.3">
                            <p>実際には、サーバープッシュは効果的に使用するのが難しく、キャッシュ、コンテンツネゴシエーション、ユーザーの振る舞いなどを考慮してサーバーが正しく追加リクエストを予測する必要があります。予測の誤りは追加データによる機会費用のために性能低下を招く可能性があります。特に大量のデータをプッシュすると、より重要なレスポンスとの競合を引き起こす場合があります。
                            </p>
                        </div>
                        <div id="rfc.section.8.4.p.4">
                            <p>クライアントはサーバープッシュを無効にするよう要求できますが、これはそれぞれのホップごとにネゴシエートされます。<a
                                    href="#SETTINGS_ENABLE_PUSH">SETTINGS_ENABLE_PUSH</a> を 0
                                に設定するとサーバープッシュが無効であることを示します。
                            </p>
                        </div>
                        <div id="rfc.section.8.4.p.5">
                            <p>約束されたリクエストは安全（safe）でなければ <em class="bcp14">MUST</em> なく、キャッシュ可能でなければ <em
                                    class="bcp14">MUST</em>
                                です。約束されたリクエストはコンテンツやトレーラセクションを含めることはできません。クライアントが約束されたリクエストがキャッシュ可能でない、あるいは安全でない、またはリクエストコンテンツの存在を示す場合は、その約束されたストリームを
                                <a href="#StreamErrorHandler" title="Stream Error Handling">Section 5.4.2</a> の <a
                                    href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a> でリセットしなければなりません。
                            </p>
                        </div>
                        <div id="rfc.section.8.4.p.6">
                            <p>キャッシュ可能なプッシュされたレスポンスは、クライアントが HTTP
                                キャッシュを実装している場合にクライアントにより保存できます。プッシュされたレスポンスは、約束されたストリーム識別子で識別されるストリームがまだ開いている間にオリジンサーバーで有効に検証されたと見なされます（例えば
                                "no-cache" がある場合など）。</p>
                        </div>
                        <div id="rfc.section.8.4.p.7">
                            <p>キャッシュ可能でないプッシュされたレスポンスは HTTP キャッシュによって保存しては <em class="bcp14">MUST NOT</em>
                                なりません。これらはアプリケーションに別個に提供されることが <em class="bcp14">MAY</em> あります。</p>
                        </div>
                        <div id="rfc.section.8.4.p.8">
                            <p>サーバーは "<span class="tt">:authority</span>" 擬似ヘッダーフィールドに対してそのサーバーが権威を持つ値を含めなければ <em
                                    class="bcp14">MUST</em> です（<a href="#authority" title="Server Authority">Section
                                    10.1</a> を参照）。クライアントはサーバーが権威を持たない <a href="#PUSH_PROMISE"
                                    title="PUSH_PROMISE">PUSH_PROMISE</a> を受信した場合、それを <a href="#StreamErrorHandler"
                                    title="Stream Error Handling">Section 5.4.2</a> の <a
                                    href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a> として扱わなければなりません。</p>
                        </div>
                        <div id="rfc.section.8.4.p.9">
                            <p>インターミディアリはサーバーからのプッシュを受け取り、それをクライアントに転送しないことを選択できます。どのようにプッシュ情報を利用するかはそのインターミディアリ次第です。同様に、インターミディアリはサーバーとは別にクライアントへ追加のプッシュを行うこともできます。
                            </p>
                        </div>
                        <div id="rfc.section.8.4.p.10">
                            <p>クライアントはプッシュを行えません。したがって、サーバーは <a href="#PUSH_PROMISE"
                                    title="PUSH_PROMISE">PUSH_PROMISE</a>
                                を受信した場合、それを接続エラー（<a href="#ConnectionErrorHandler"
                                    title="Connection Error Handling">Section
                                    5.4.1</a>）の <a href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a> として扱わなければなりません。サーバーは <a
                                    href="#SETTINGS_ENABLE_PUSH">SETTINGS_ENABLE_PUSH</a> を 0 以外の値に設定してはなりません。</p>
                        </div>
                        <section id="PushRequests">
                            <h4 id="rfc.section.8.4.1"><a href="#rfc.section.8.4.1">8.4.1.</a>&nbsp;<a
                                    href="#PushRequests">プッシュリクエスト</a></h4>
                            <div id="rfc.section.8.4.1.p.1">
                                <p>サーバープッシュはサーバーがリクエストに応答することと意味的に同等ですが、この場合そのリクエストはサーバーによって送信され、<a href="#PUSH_PROMISE"
                                        title="PUSH_PROMISE">PUSH_PROMISE</a> フレームとして送られます。</p>
                            </div>
                            <div id="rfc.section.8.4.1.p.2">
                                <p><a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a>
                                    フレームは、サーバーがそのリクエストに帰属すると見なす制御データと完全なリクエストヘッダセットを含むフィールドブロックを含みます。メッセージ本文を含むリクエストに対してはレスポンスをプッシュすることはできません。
                                </p>
                            </div>
                            <div id="rfc.section.8.4.1.p.3">
                                <p>約束されたリクエストは常にクライアントの明示的なリクエストに関連付けられます。サーバーが送る <a href="#PUSH_PROMISE"
                                        title="PUSH_PROMISE">PUSH_PROMISE</a> フレームはその明示的リクエストのストリーム上で送信されます。<a
                                        href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a>
                                    フレームにはサーバーが利用可能なストリーム識別子から選ばれた約束されたストリーム識別子が含まれます（<a href="#StreamIdentifiers"
                                        title="Stream Identifiers">Section 5.1.1</a> を参照）。</p>
                            </div>
                            <div id="rfc.section.8.4.1.p.4">
                                <p><a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> と続く <a
                                        href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a>
                                    フレームのヘッダフィールドは、完全で有効なリクエストヘッダセットでなければ <em class="bcp14">MUST</em> ありません（<a
                                        href="#HttpRequest" title="Request Pseudo-Header Fields">Section
                                        8.3.1</a>）。サーバーは "<span class="tt">:method</span>" に安全でキャッシュ可能なメソッドを含めなければ <em
                                        class="bcp14">MUST</em>
                                    ません。クライアントが完全かつ有効なヘッダセットを含まない PUSH_PROMISE を受け取るか "<span class="tt">:method</span>"
                                    が安全でないメソッドを示す場合、クライアントは約束されたストリームで <a href="#StreamErrorHandler"
                                        title="Stream Error Handling">Section 5.4.2</a> の <a
                                        href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a> で応答しなければなりません。</p>
                            </div>
                            <div id="rfc.section.8.4.1.p.5">
                                <p>サーバーは、参照される予定のある約束されたレスポンスを参照するフレームを送信する前に <a href="#PUSH_PROMISE"
                                        title="PUSH_PROMISE">PUSH_PROMISE</a> を送ることを <em class="bcp14">SHOULD</em>
                                    推奨します。これによりクライアントが約束されたフレームを受け取る前にリソースをリクエストしてしまう競合を避けられます。</p>
                            </div>
                            <div id="rfc.section.8.4.1.p.6">
                                <p>例えば、サーバーが埋め込みリンクを含むドキュメントへのリクエストを受け取り、その追加イメージをクライアントにプッシュすることを選択する場合、イメージのリンクを含む <a
                                        href="#DATA" title="DATA">DATA</a> フレームの前に <a href="#PUSH_PROMISE"
                                        title="PUSH_PROMISE">PUSH_PROMISE</a>
                                    を送ることで、クライアントがリソースがプッシュされることを発見する前にそれらをリクエストしてしまう事態を避けられます。</p>
                            </div>
                            <div id="rfc.section.8.4.1.p.7">
                                <p><a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> フレームはクライアントによって送信しては
                                    <em class="bcp14">MUST NOT</em> なりません。
                                </p>
                            </div>
                            <div id="rfc.section.8.4.1.p.8">
                                <p><a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a>
                                    フレームはサーバーが任意のクライアント発行ストリーム上で送信できますが、そのストリームはサーバー側にとって "open" または "half-closed
                                    (remote)"
                                    でなければ <em class="bcp14">MUST</em> なりません。<a href="#PUSH_PROMISE"
                                        title="PUSH_PROMISE">PUSH_PROMISE</a>
                                    はレスポンスを構成するフレームと交錯することはありますが、単一のフィールドブロックを構成する
                                    <a href="#HEADERS" title="HEADERS">HEADERS</a> や <a href="#CONTINUATION"
                                        title="CONTINUATION">CONTINUATION</a> の間には挿入できません。
                                </p>
                            </div>
                            <div id="rfc.section.8.4.1.p.9">
                                <p><a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a>
                                    の送信は新しいストリームを作成し、サーバー側ではそのストリームを "reserved (local)"、クライアント側では "reserved (remote)"
                                    にします。
                                </p>
                            </div>
                        </section>
                        <section id="PushResponses">
                            <h4 id="rfc.section.8.4.2"><a href="#rfc.section.8.4.2">8.4.2.</a>&nbsp;<a
                                    href="#PushResponses">プッシュされたレスポンス</a></h4>
                            <div id="rfc.section.8.4.2.p.1">
                                <p><a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a>
                                    を送信した後、サーバーは約束されたストリーム識別子を用いてサーバー起点のストリーム上でプッシュされたレスポンスの送信を開始できます。サーバーはこのストリームで HTTP
                                    レスポンスを送信し、<a href="#HttpFraming" title="HTTP Message Framing">Section 8.1</a>
                                    に定義されたのと同じフレーム列を使用します。このストリームは最初の <a href="#HEADERS" title="HEADERS">HEADERS</a>
                                    フレームが送信されるとクライアントにとって "half-closed (local)" になります。</p>
                            </div>
                            <div id="rfc.section.8.4.2.p.2">
                                <p>クライアントが <a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a>
                                    を受け取り、プッシュされたレスポンスを受け取ることを選択した場合、クライアントは約束されたストリームが閉じられるまでそのレスポンスのためのリクエストを発行しては <em
                                        class="bcp14">SHOULD NOT</em> なりません。</p>
                            </div>
                            <div id="rfc.section.8.4.2.p.3">
                                <p>クライアントが何らかの理由でプッシュされたレスポンスを受け取りたくないと判断するか、サーバーが約束されたレスポンスの送信を開始するのに時間がかかりすぎる場合、クライアントは
                                    <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> を送信して、<a
                                        href="#CANCEL">CANCEL</a> または <a href="#REFUSED_STREAM">REFUSED_STREAM</a>
                                    のコードを使用してプッシュされたストリームを参照できます。
                                </p>
                            </div>
                            <div id="rfc.section.8.4.2.p.4">
                                <p>クライアントは <a
                                        href="#SETTINGS_MAX_CONCURRENT_STREAMS">SETTINGS_MAX_CONCURRENT_STREAMS</a>
                                    を用いてサーバーが同時にプッシュできるレスポンス数を制限できます。値を 0
                                    にするとサーバーがプッシュレスポンスのために必要なストリームを同時に開くことを防ぎます。ただし、予約されたストリームは同時ストリーム制限に含まれないため、PUSH_PROMISE
                                    による予約は妨げられません。プッシュされたリソースを受け取りたくないクライアントは不要な予約ストリームをリセットするか <a
                                        href="#SETTINGS_ENABLE_PUSH">SETTINGS_ENABLE_PUSH</a> を 0 に設定する必要があります。</p>
                            </div>
                            <div id="rfc.section.8.4.2.p.5">
                                <p>プッシュされたレスポンスを受け取るクライアントは、サーバーがそのレスポンスに対して権威があるか（<a href="#authority"
                                        title="Server Authority">Section 10.1</a>
                                    を参照）あるいはプッシュを提供したプロキシが対応するリクエストに対して構成されているかを検証しなければ <em class="bcp14">MUST</em>
                                    なりません。例えば、ある証明書が example.com の DNS-ID のみを提供する場合、そのサーバーは &lt;<span
                                        class="tt">https://www.example.org/doc</span>&gt; に対するプッシュを行えません。</p>
                            </div>
                            <div id="rfc.section.8.4.2.p.6">
                                <p><a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> ストリームのレスポンスは <a
                                        href="#HEADERS" title="HEADERS">HEADERS</a> フレームで始まり、これは直ちにストリームをサーバーにとって
                                    "half-closed (remote)"、クライアントにとって "half-closed (local)" にし、END_STREAM
                                    フラグを持つフレームで終わりストリームを "closed" にします。</p>
                            </div>
                            <div id="rfc.section.8.4.2.p.7">
                                <aside>
                                    <div id="rfc.section.8.4.2.p.7.1">
                                        <p>注：サーバープッシュに対してクライアントが END_STREAM を設定したフレームを送ることはありません。</p>
                                    </div>
                                </aside>
                            </div>
                        </section>
                    </section>
                    <section id="CONNECT">
                        <h3 id="rfc.section.8.5"><a href="#rfc.section.8.5">8.5.</a>&nbsp;<a href="#CONNECT">CONNECT
                                メソッド</a></h3>
                        <div id="rfc.section.8.5.p.1">
                            <p>CONNECT メソッド（RFC 9110 の Section 9.3.6）は、HTTP 接続をリモートホストへのトンネルに変換するために使用されます。CONNECT は主に
                                HTTP
                                プロキシと共に使用され、オリジンサーバーとの TLS セッションを確立して "<span class="tt">https</span>"
                                リソースとやり取りするために用いられます。
                            </p>
                        </div>
                        <div id="rfc.section.8.5.p.2" class="avoidbreakafter">
                            <p>HTTP/2 では、CONNECT メソッドは接続全体をトンネルに変換するのではなく、単一の HTTP/2 ストリーム上でリモートホストへのトンネルを確立します。CONNECT
                                ヘッダセクションは <a href="#HttpRequest" title="Request Pseudo-Header Fields">Section 8.3.1</a>
                                に定義されたように構築されますが、いくつかの相違があります。具体的には：</p>
                        </div>
                        <div id="rfc.section.8.5.p.3">
                            <ul>
                                <li>「<span class="tt">:method</span>」 擬似ヘッダーは <span class="tt">CONNECT</span> に設定されます。
                                </li>
                                <li>「<span class="tt">:scheme</span>」 および 「<span class="tt">:path</span>」
                                    擬似ヘッダーは省略されなければ
                                    <em class="bcp14">MUST</em> です。
                                </li>
                                <li>「<span class="tt">:authority</span>」 擬似ヘッダーには接続するホストとポートが含まれます（CONNECT リクエストの
                                    authority-form に相当します）。</li>
                            </ul>
                        </div>
                        <div id="rfc.section.8.5.p.4">
                            <p>これらの制約に従わない CONNECT リクエストは誤形成です（<a href="#malformed" title="Malformed Messages">Section
                                    8.1.1</a>）。</p>
                        </div>
                        <div id="rfc.section.8.5.p.5">
                            <p>CONNECT をサポートするプロキシは "<span class="tt">:authority</span>" に示されたホストとポートに対して TCP
                                接続を確立します。接続が成功すると、プロキシは 2xx 系ステータスコードを含む <a href="#HEADERS" title="HEADERS">HEADERS</a>
                                フレームをクライアントに送信します。</p>
                        </div>
                        <div id="rfc.section.8.5.p.6">
                            <p>各ピアが最初に送る HEADERS フレームの後、以降のすべての <a href="#DATA" title="DATA">DATA</a> フレームは TCP
                                接続上で送受信されるデータに対応します。クライアントが送る DATA フレームのフレームペイロードはプロキシにより TCP サーバーへ転送され、TCP
                                サーバーから受信したデータはプロキシにより DATA フレームとして組み立てられます。DATA
                                以外のフレームやストリーム管理フレーム（RST_STREAM、WINDOW_UPDATE、PRIORITY）以外のフレームは接続済みストリームで送信しては <em
                                    class="bcp14">MUST NOT</em> であり、受信した場合はストリームエラー（<a href="#StreamErrorHandler"
                                    title="Stream Error Handling">Section 5.4.2</a>）として扱わなければなりません。</p>
                        </div>
                        <div id="rfc.section.8.5.p.7">
                            <p>TCP 接続はどちらのピアでも閉じることができます。DATA フレームの END_STREAM フラグは TCP の FIN ビットと同等に扱われます。クライアントは
                                END_STREAM を受信した後に END_STREAM を設定した DATA フレームを送信することが期待されます。プロキシは END_STREAM を受け取ると、最後の
                                TCP
                                セグメントに対して FIN を設定してデータを送信します。TCP セグメントで FIN を受信したプロキシは END_STREAM を設定した DATA
                                フレームを送信します。最終の
                                TCP セグメントや DATA フレームは空であり得ることに注意してください。</p>
                        </div>
                        <div id="rfc.section.8.5.p.8">
                            <p>TCP 接続エラーは <a href="#RST_STREAM" title="RST_STREAM">RST_STREAM</a> で通知されます。プロキシは TCP
                                接続におけるエラー（RST ビットを含む TCP セグメントの受信など）を <a href="#StreamErrorHandler"
                                    title="Stream Error Handling">Section 5.4.2</a> の <a
                                    href="#CONNECT_ERROR">CONNECT_ERROR</a>
                                として扱い、対応してストリームエラーを送信しなければなりません。対応して、プロキシはストリームや
                                HTTP/2 接続にエラーを検出した場合に TCP セグメントに RST ビットを設定して送信することが <em class="bcp14">MUST</em> です。</p>
                        </div>
                    </section>
                    <section id="informational-responses">
                        <h3 id="rfc.section.8.6"><a href="#rfc.section.8.6">8.6.</a>&nbsp;<a
                                href="#informational-responses">Upgrade ヘッダフィールド</a></h3>
                        <div id="rfc.section.8.6.p.1">
                            <p>HTTP/2 は 101 (Switching Protocols) の情報的ステータスコードをサポートしません（RFC 9110 の Section 15.2.2 を参照）。
                            </p>
                        </div>
                        <div id="rfc.section.8.6.p.2">
                            <p>101 の意味は多重化プロトコルには適用されません。同様の機能は <a href="#RFC8441"><cite
                                        title="Bootstrapping WebSockets with HTTP/2">extended CONNECT</cite></a>（RFC
                                8441）や、HTTP/2 が使用するネゴシエーションメカニズムを利用することで実現できます（<a href="#starting"
                                    title="Starting HTTP/2">Section 3</a> を参照）。</p>
                        </div>
                    </section>
                    <section id="Reliability">
                        <h3 id="rfc.section.8.7"><a href="#rfc.section.8.7">8.7.</a>&nbsp;<a
                                href="#Reliability">リクエストの信頼性</a></h3>
                        <div id="rfc.section.8.7.p.1">
                            <p>一般に、HTTP
                                クライアントはエラー発生時に非冪等リクエストを再試行できません。なぜならエラーの性質を決定する手段がないためです。サーバーで一部処理が既に行われている可能性があり、再試行すると望ましくない影響をもたらすことがあります。
                            </p>
                        </div>
                        <div id="rfc.section.8.7.p.2" class="avoidbreakafter">
                            <p>HTTP/2 はクライアントに対してリクエストが処理されていないことを保証するために二つのメカニズムを提供します：</p>
                        </div>
                        <div id="rfc.section.8.7.p.3">
                            <ul>
                                <li><a href="#GOAWAY" title="GOAWAY">GOAWAY</a>
                                    フレームは処理された可能性のある最高のストリーム番号を示します。したがって、より高い番号のストリーム上のリクエストは再試行が安全であると保証されます。</li>
                                <li><a href="#REFUSED_STREAM">REFUSED_STREAM</a> エラーコードは <a href="#RST_STREAM"
                                        title="RST_STREAM">RST_STREAM</a>
                                    フレームに含められ、ストリームがいかなる処理も行われる前に閉じられたことを示すことができます。リセットされたストリーム上のリクエストは安全に再試行できます。</li>
                            </ul>
                        </div>
                        <div id="rfc.section.8.7.p.4">
                            <p>処理されていないリクエストは失敗していないため、クライアントは自動的にそれらを再試行してもよい（<em
                                    class="bcp14">MAY</em>）、非冪等メソッドのものも含みます。
                            </p>
                        </div>
                        <div id="rfc.section.8.7.p.5">
                            <p>サーバーはストリームが処理されていないと示す場合、その事実を保証できなければ <em class="bcp14">MUST NOT</em>
                                なりません。ストリーム上のフレームがアプリケーション層に渡された場合、そのストリームに対して <a
                                    href="#REFUSED_STREAM">REFUSED_STREAM</a>
                                を使用しては <em class="bcp14">MUST NOT</em> であり、<a href="#GOAWAY" title="GOAWAY">GOAWAY</a>
                                フレームは指定したストリーム識別子以上の値を含めなければ <em class="bcp14">MUST</em> なりません。</p>
                        </div>
                        <div id="rfc.section.8.7.p.6">
                            <p>これらのメカニズムに加えて、<a href="#PING" title="PING">PING</a>
                                フレームはクライアントが接続を簡単にテストする方法を提供します。アイドル状態の接続は一部のミドルボックスにより静かに破棄されることがあり得ます。<a href="#PING"
                                    title="PING">PING</a> フレームにより、クライアントはリクエストを送らずに接続がまだ有効か安全にテストできます。</p>
                        </div>
                    </section>
                    <section id="HttpExamples">
                        <h3 id="rfc.section.8.8"><a href="#rfc.section.8.8">8.8.</a>&nbsp;<a href="#HttpExamples">例</a>
                        </h3>
                        <div id="rfc.section.8.8.p.1">
                            <p>この節では HTTP/1.1 のリクエストとレスポンスを示し、それに相当する HTTP/2 のリクエストとレスポンスの図示を行います。</p>
                        </div>
                        <section id="n-simple-request">
                            <h4 id="rfc.section.8.8.1"><a href="#rfc.section.8.8.1">8.8.1.</a>&nbsp;<a
                                    href="#n-simple-request">単純なリクエスト</a></h4>
                            <div id="rfc.section.8.8.1.p.1">
                                <p>HTTP GET リクエストは制御データとメッセージ本文を持たないリクエストヘッダを含むため、単一の <a href="#HEADERS"
                                        title="HEADERS">HEADERS</a> フレームとして送信され、続いてゼロ個以上の <a href="#CONTINUATION"
                                        title="CONTINUATION">CONTINUATION</a> フレームがヘッダブロックを含むことがあります。以下の HEADERS フレームは
                                    END_HEADERS と END_STREAM の両方が設定されています；CONTINUATION フレームは送信されません。</p>
                            </div>
                            <div id="rfc.section.8.8.1.p.2">
                                <pre class="inline">
  GET /resource HTTP/1.1           HEADERS
  Host: example.org          ==&gt;     + END_STREAM
  Accept: image/jpeg                 + END_HEADERS
                                       :method = GET
                                       :scheme = https
                                       :authority = example.org
                                       :path = /resource
                                       host = example.org
                                       accept = image/jpeg
</pre>
                            </div>
                        </section>
                        <section id="n-simple-response">
                            <h4 id="rfc.section.8.8.2"><a href="#rfc.section.8.8.2">8.8.2.</a>&nbsp;<a
                                    href="#n-simple-response">単純なレスポンス</a></h4>
                            <div id="rfc.section.8.8.2.p.1">
                                <p>同様に、制御データとレスポンスヘッダだけを含むレスポンスは、シリアライズされたレスポンスヘッダブロックを含む <a href="#HEADERS"
                                        title="HEADERS">HEADERS</a> フレームとして送信されます（必要なら CONTINUATION で続きます）。</p>
                            </div>
                            <div id="rfc.section.8.8.2.p.2">
                                <pre class="inline">
  HTTP/1.1 304 Not Modified        HEADERS
  ETag: "xyzzy"              ==&gt;     + END_STREAM
  Expires: Thu, 23 Jan ...           + END_HEADERS
                                       :status = 304
                                       etag = "xyzzy"
                                       expires = Thu, 23 Jan ...
</pre>
                            </div>
                        </section>
                        <section id="n-complex-request">
                            <h4 id="rfc.section.8.8.3"><a href="#rfc.section.8.8.3">8.8.3.</a>&nbsp;<a
                                    href="#n-complex-request">複雑なリクエスト</a></h4>
                            <div id="rfc.section.8.8.3.p.1" class="avoidbreakafter">
                                <p>メッセージ本文を含む HTTP POST リクエストは、1 個の <a href="#HEADERS" title="HEADERS">HEADERS</a>
                                    フレーム、続いてゼロ個以上の <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a>
                                    フレームでヘッダを送り、続いて 1 個以上の <a href="#DATA" title="DATA">DATA</a> フレームを送ります。最後の
                                    CONTINUATION（または HEADERS）フレームは END_HEADERS を持ち、最後の DATA フレームは END_STREAM を持ちます：</p>
                            </div>
                            <div id="rfc.section.8.8.3.p.2">
                                <pre class="inline">
  POST /resource HTTP/1.1          HEADERS
  Host: example.org          ==&gt;     - END_STREAM
  Content-Type: image/jpeg           - END_HEADERS
  Content-Length: 123                  :method = POST
                                       :authority = example.org
                                       :path = /resource
  {binary data}                        :scheme = https

                                   CONTINUATION
                                     + END_HEADERS
                                       content-type = image/jpeg
                                       host = example.org
                                       content-length = 123

                                   DATA
                                     + END_STREAM
                                   {binary data}
</pre>
                            </div>
                            <div id="rfc.section.8.8.3.p.3" class="avoidbreakbefore">
                                <p>フィールドラインに寄与するデータはフィールドブロック断片間で分散され得る点に注意してください。本例のフレームへの割当は説明のためのものであり例示的です。</p>
                            </div>
                        </section>
                        <section id="n-response-with-body">
                            <h4 id="rfc.section.8.8.4"><a href="#rfc.section.8.8.4">8.8.4.</a>&nbsp;<a
                                    href="#n-response-with-body">本文を伴うレスポンス</a></h4>
                            <div id="rfc.section.8.8.4.p.1" class="avoidbreakafter">
                                <p>メッセージ本文を含むレスポンスは <a href="#HEADERS" title="HEADERS">HEADERS</a>、続いてゼロ個以上の <a
                                        href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a>、続いて 1 個以上の <a
                                        href="#DATA" title="DATA">DATA</a> フレームとして送信され、最後の DATA フレームが END_STREAM を持ちます：
                                </p>
                            </div>
                            <div id="rfc.section.8.8.4.p.2">
                                <pre class="inline">
  HTTP/1.1 200 OK                  HEADERS
  Content-Type: image/jpeg   ==&gt;     - END_STREAM
  Content-Length: 123                + END_HEADERS
                                       :status = 200
  {binary data}                        content-type = image/jpeg
                                       content-length = 123

                                   DATA
                                     + END_STREAM
                                   {binary data}
</pre>
                            </div>
                        </section>
                        <section id="n-informational-responses">
                            <h4 id="rfc.section.8.8.5"><a href="#rfc.section.8.8.5">8.8.5.</a>&nbsp;<a
                                    href="#n-informational-responses">情報的レスポンス</a></h4>
                            <div id="rfc.section.8.8.5.p.1">
                                <p>101 を除く 1xx ステータスコードを使う情報的レスポンスは <a href="#HEADERS" title="HEADERS">HEADERS</a>
                                    フレームとして送信され、続いてゼロ個以上の <a href="#CONTINUATION" title="CONTINUATION">CONTINUATION</a>
                                    フレームが来ます。</p>
                            </div>
                            <div id="rfc.section.8.8.5.p.2">
                                <p>トレーラセクションはリクエスト／レスポンスのフィールドブロックおよびすべての DATA フレームの送信後にフィールドブロックとして送られます。トレーラを開始する
                                    HEADERS
                                    フレームは END_STREAM を持ちます。</p>
                            </div>
                            <div id="rfc.section.8.8.5.p.3" class="avoidbreakafter">
                                <p>次の例は 100 (Continue) ステータスコード（Expect ヘッダに "100-continue"
                                    トークンがあるリクエストに対するもの）とトレーラセクションの両方を含みます：</p>
                            </div>
                            <div id="rfc.section.8.8.5.p.4">
                                <pre class="inline">
  HTTP/1.1 100 Continue            HEADERS
  Extension-Field: bar       ==&gt;     - END_STREAM
                                     + END_HEADERS
                                       :status = 100
                                       extension-field = bar

  HTTP/1.1 200 OK                  HEADERS
  Content-Type: image/jpeg   ==&gt;     - END_STREAM
  Transfer-Encoding: chunked         + END_HEADERS
  Trailer: Foo                         :status = 200
                                       content-type = image/jpeg
  123                                  trailer = Foo
  {binary data}
  0                                DATA
  Foo: bar                           - END_STREAM
                                   {binary data}

                                   HEADERS
                                     + END_STREAM
                                     + END_HEADERS
                                       foo = bar
</pre>
                            </div>
                        </section>
                    </section>
                </section>
                <hr class="hidden-print">
                <section id="HttpExtra">
                    <h2 id="rfc.section.9" class="np"><a href="#rfc.section.9">9.</a>&nbsp;<a href="#HttpExtra">HTTP/2
                            接続</a></h2>
                    <div id="rfc.section.9.p.1">
                        <p>本節は、相互運用性を改善し、既知のセキュリティ脆弱性への露出を低減し、また実装差異の可能性を減らす HTTP の属性について概説します。</p>
                    </div>
                    <section id="n-connection-management">
                        <h3 id="rfc.section.9.1"><a href="#rfc.section.9.1">9.1.</a>&nbsp;<a
                                href="#n-connection-management">接続管理</a></h3>
                        <div id="rfc.section.9.1.p.1">
                            <p>HTTP/2
                                接続は永続的です。最高のパフォーマンスを得るために、クライアントはサーバーとのさらなる通信が不要であると判断されるまで（例えば、ユーザーが特定のウェブページから離れたとき）またはサーバーが接続を閉じるまで、接続を閉じないことが期待されます。
                            </p>
                        </div>
                        <div id="rfc.section.9.1.p.2">
                            <p>クライアントは、ホストが URI、選択された <a href="#RFC7838"><cite
                                        title="HTTP Alternative Services">alternative
                                        service</cite></a> <cite
                                    title="HTTP Alternative Services">[ALT-SVC]</cite>、または設定されたプロキシから導出される場合において、特定のホストとポートの組に対して複数の
                                HTTP/2 接続を開いては <em class="bcp14">MUST NOT</em> というわけではありませんが、通常は複数を開くべきではありません（<em
                                    class="bcp14">SHOULD NOT</em>）。</p>
                        </div>
                        <div id="rfc.section.9.1.p.3">
                            <p>クライアントは、ストリーム識別子空間の枯渇が近い接続を置き換えるため（<a href="#StreamIdentifiers"
                                    title="Stream Identifiers">Section 5.1.1</a>）、TLS
                                接続の鍵素材を更新するため、あるいはエラーが発生した接続を置き換えるため（<a href="#ConnectionErrorHandler"
                                    title="Connection Error Handling">Section 5.4.1</a>）に追加の接続を作成することができます。</p>
                        </div>
                        <div id="rfc.section.9.1.p.4">
                            <p>クライアントは異なる <a href="#RFC6066"><cite
                                        title="Transport Layer Security (TLS) Extensions: Extension Definitions">Server
                                        Name
                                        Indication</cite></a> <cite
                                    title="Transport Layer Security (TLS) Extensions: Extension Definitions">[TLS-EXT]</cite>
                                値を使用したり、異なる TLS クライアント証明書を提供したりするために、同じ IP アドレスと TCP ポートに対して複数の接続を開くことが <em
                                    class="bcp14">MAY</em> ありますが、同一の構成で複数の接続を作成することは <em class="bcp14">SHOULD</em>
                                避けるべきです。
                            </p>
                        </div>
                        <div id="rfc.section.9.1.p.5">
                            <p>サーバーは可能な限り接続を開いたままにすることが推奨されますが、必要に応じてアイドル接続を終了することが許容されます。いずれかのエンドポイントがトランスポート層の TCP
                                接続を閉じることを選択した場合、終了するエンドポイントはまず <a href="#GOAWAY" title="GOAWAY">GOAWAY</a>（<a
                                    href="#GOAWAY" title="GOAWAY">Section 6.8</a>）フレームを送信することが <em
                                    class="bcp14">SHOULD</em>
                                推奨されます。これにより両端点が以前に送信されたフレームが処理されたかどうかを確実に判断し、必要な残作業を優雅に完了または終了できます。</p>
                        </div>
                        <section id="reuse">
                            <h4 id="rfc.section.9.1.1"><a href="#rfc.section.9.1.1">9.1.1.</a>&nbsp;<a
                                    href="#reuse">接続の再利用</a></h4>
                            <div id="rfc.section.9.1.1.p.1">
                                <p>CONNECT メソッド（<a href="#CONNECT" title="The CONNECT Method">Section
                                        8.5</a>）を使用して作成されたトンネルを介して直接または間接的にオリジンサーバーに接続された接続は、複数の異なる URI authority
                                    コンポーネントを持つリクエストに対して <em class="bcp14">MAY</em>
                                    再利用できます。接続はオリジンサーバーが権威を持っている限り再利用可能です（<a href="#authority"
                                        title="Server Authority">Section 10.1</a>を参照）。TLS を使用しない TCP
                                    接続の場合、これはホストが同じ IP アドレスに解決されることに依存します。</p>
                            </div>
                            <div id="rfc.section.9.1.1.p.2">
                                <p>"<span class="tt">https</span>" リソースの場合、接続の再利用はさらに URI
                                    のホストに対して有効な証明書を持っていることに依存します。サーバーが提示する証明書は、クライアントがそのホストのために新しい TLS
                                    接続を形成する際に実行するチェックを満たさなければ <em class="bcp14">MUST</em>
                                    なりませんが、実際にはクライアントはそれらのチェックを満たすことを要求します。単一の証明書は複数のオリジンに対して権威を確立するために使用できます。どのようにクライアントがサーバーが
                                    URI に対して権威を持つかを判断するかについては、<a
                                        href="https://www.rfc-editor.org/rfc/rfc9110.html#section-4.3">RFC9110 の Section
                                        4.3</a> を参照してください。</p>
                            </div>
                            <div id="rfc.section.9.1.1.p.3">
                                <p>一部の展開では、複数のオリジンに対して接続を再利用すると、リクエストが誤ったオリジンサーバーに送られてしまう可能性があります。例えば、TLS
                                    終端がミドルボックスによって行われ、その際に TLS の <a href="#RFC6066"><cite
                                            title="Transport Layer Security (TLS) Extensions: Extension Definitions">Server
                                            Name Indication</cite></a>
                                    拡張がオリジンサーバーの選択に用いられる場合があります。これにより、クライアントが意図したターゲットではないサーバーにリクエストを送ってしまう可能性が残りますが、サーバー自体は他の点では権威を持っていることがあります。
                                </p>
                            </div>
                            <div id="rfc.section.9.1.1.p.4">
                                <p>接続の再利用をクライアントに望まないサーバーは、リクエストに対して 421 (Misdirected Request)
                                    ステータスコードを返すことで、そのリクエストに対して権威を持たないことを示すことができます（詳細は <a
                                        href="https://www.rfc-editor.org/rfc/rfc9110.html#section-15.5.20">RFC9110 の
                                        Section
                                        15.5.20</a> を参照）。</p>
                            </div>
                            <div id="rfc.section.9.1.1.p.5">
                                <p>プロキシを使用するように構成されたクライアントは、そのプロキシへの単一の接続を通じてリクエストを送信します。つまり、プロキシ経由で送信されるすべてのリクエストはそのプロキシへの接続を再利用します。
                                </p>
                            </div>
                        </section>
                    </section>
                    <section id="TLSUsage">
                        <h3 id="rfc.section.9.2"><a href="#rfc.section.9.2">9.2.</a>&nbsp;<a href="#TLSUsage">TLS
                                機能の使用</a>
                        </h3>
                        <div id="rfc.section.9.2.p.1">
                            <p>HTTP/2 の実装は、TLS 経由の HTTP/2 に対して <a href="#RFC5246"><cite
                                        title="The Transport Layer Security (TLS) Protocol Version 1.2">TLS version
                                        1.2</cite></a> <cite
                                    title="The Transport Layer Security (TLS) Protocol Version 1.2">[TLS12]</cite>
                                以上を使用しなければ <em class="bcp14">MUST</em> なりません。一般的な TLS 使用の指針は <a href="#RFC7525"><cite
                                        title="Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)">[TLSBCP]</cite></a>
                                に従うことが <em class="bcp14">SHOULD</em> とされますが、HTTP/2 固有の追加制約がいくつかあります。</p>
                        </div>
                        <div id="rfc.section.9.2.p.2">
                            <p>TLS 実装は <a href="#RFC6066"><cite
                                        title="Transport Layer Security (TLS) Extensions: Extension Definitions">Server
                                        Name
                                        Indication (SNI)</cite></a> <cite
                                    title="Transport Layer Security (TLS) Extensions: Extension Definitions">[TLS-EXT]</cite>
                                拡張をサポートしなければ <em class="bcp14">MUST</em> なりません。サーバーが <a href="#RFC8499"><cite
                                        title="DNS Terminology">domain name</cite></a> <cite
                                    title="DNS Terminology">[DNS-TERMS]</cite>
                                によって識別される場合、クライアントはターゲットホストを示す代替メカニズムが使用されていない限り、server_name TLS 拡張を送信しなければ <em
                                    class="bcp14">MUST</em> です。</p>
                        </div>
                        <div id="rfc.section.9.2.p.3">
                            <p>TLS 1.3 をネゴシエートする HTTP/2 展開に関する要件は <a href="#tls13features"
                                    title="TLS 1.3 Features">Section
                                    9.2.3</a> に含まれます。TLS 1.2 の展開は <a href="#tls12features"
                                    title="TLS 1.2 Features">9.2.1</a> および <a href="#tls12ciphers"
                                    title="TLS 1.2 Cipher Suites">9.2.2</a>
                                の要件に従います。実装は準拠するデフォルトを提供することが推奨されますが、最終的なコンプライアンスは展開に依存することが認識されています。</p>
                        </div>
                        <section id="tls12features">
                            <h4 id="rfc.section.9.2.1"><a href="#rfc.section.9.2.1">9.2.1.</a>&nbsp;<a
                                    href="#tls12features">TLS 1.2 の機能</a></h4>
                            <div id="rfc.section.9.2.1.p.1">
                                <p>本節は HTTP/2 と共に使用できる TLS 1.2 の機能セットに関する制約を記述します。展開上の制限のため、これらの制約が満たされない場合に TLS
                                    ネゴシエーションを失敗させることが不可能な場合があります。これらの TLS 要件を満たさない HTTP/2 接続をエンドポイントが即座に終了させてもよい（<em
                                        class="bcp14">MAY</em>）ことを示し、その際の接続エラーは <a href="#ConnectionErrorHandler"
                                        title="Connection Error Handling">Section 5.4.1</a> の <a
                                        href="#INADEQUATE_SECURITY">INADEQUATE_SECURITY</a> 型とします。</p>
                            </div>
                            <div id="rfc.section.9.2.1.p.2">
                                <p>TLS 1.2 上の HTTP/2 展開は圧縮を無効にしなければ <em class="bcp14">MUST</em> なりません。TLS
                                    圧縮は本来明らかにならない情報を露出させる可能性があります（<a href="#RFC3749"><cite
                                            title="Transport Layer Security Protocol Compression Methods">[RFC3749]</cite></a>）。一般的な圧縮は不要であり、HTTP/2
                                    はよりコンテキストに敏感な圧縮機能を提供しているため、性能やセキュリティの観点からそちらがより適切である可能性があります。</p>
                            </div>
                            <div id="rfc.section.9.2.1.p.3">
                                <p>TLS 1.2 上の HTTP/2 展開は再ネゴシエーションを無効にしなければ <em class="bcp14">MUST</em> なりません。エンドポイントは
                                    TLS
                                    の再ネゴシエーションを <a href="#ConnectionErrorHandler"
                                        title="Connection Error Handling">Section
                                        5.4.1</a> の種類の接続エラー（<a
                                        href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a>）として扱わなければなりません。再ネゴシエーションを無効にすると、基盤となる暗号スイートが暗号化できるメッセージ数の制限により長時間接続が使用不能になる可能性があります。
                                </p>
                            </div>
                            <div id="rfc.section.9.2.1.p.4">
                                <p>エンドポイントは、ハンドシェイクで提示されたクライアント資格情報の機密性保護のために再ネゴシエーションを使用することが <em
                                        class="bcp14">MAY</em>
                                    ありますが、いかなる再ネゴシエーションも接続プレフェースの送信前に行われなければ <em class="bcp14">MUST</em>
                                    なりません。サーバーは接続を確立した直後に再ネゴシエーション要求を見た場合、クライアント証明書を要求することを <em
                                        class="bcp14">SHOULD</em>
                                    します。</p>
                            </div>
                            <div id="rfc.section.9.2.1.p.5">
                                <p>これは特定の保護されたリソースに対する再ネゴシエーションの使用を実質的に防ぎます。将来の仕様ではこのユースケースをサポートする方法が提供される可能性があります。あるいは、サーバーは
                                    <a href="#ErrorHandler" title="Error Handling">Section 5.4</a> の種類のエラー、例えば <a
                                        href="#HTTP_1_1_REQUIRED">HTTP_1_1_REQUIRED</a>
                                    を用いて、クライアントに再ネゴシエーションをサポートするプロトコルの使用を要求することができます。
                                </p>
                            </div>
                            <div id="rfc.section.9.2.1.p.6">
                                <p>実装は、DHE（ephemeral finite field Diffie-Hellman）を使用する暗号スイートに対して少なくとも 2048
                                    ビットのエフェメラル鍵交換サイズ、ならびに ECDHE（ephemeral elliptic curve Diffie-Hellman）を使用する暗号スイートに対して
                                    224
                                    ビットをサポートしなければ <em class="bcp14">MUST</em> です。クライアントは DHE サイズとして最大 4096 ビットを受け入れなければ
                                    <em class="bcp14">MUST</em> です。エンドポイントは、これらの下限より小さい鍵サイズのネゴシエーションを <a
                                        href="#ConnectionErrorHandler" title="Connection Error Handling">Section
                                        5.4.1</a>
                                    の種類の接続エラー（<a href="#INADEQUATE_SECURITY">INADEQUATE_SECURITY</a>）として扱っても <em
                                        class="bcp14">MAY</em> です。
                                </p>
                            </div>
                        </section>
                        <section id="tls12ciphers">
                            <h4 id="rfc.section.9.2.2"><a href="#rfc.section.9.2.2">9.2.2.</a>&nbsp;<a
                                    href="#tls12ciphers">TLS 1.2 暗号スイート</a></h4>
                            <div id="rfc.section.9.2.2.p.1">
                                <p>TLS 1.2 上の HTTP/2 展開は、付録 A（<a href="#BadCipherSuites"
                                        title="Prohibited TLS 1.2 Cipher Suites">Prohibited TLS 1.2 Cipher
                                        Suites</a>）に列挙された禁止された暗号スイートのいずれかを使用しては <em class="bcp14">SHOULD NOT</em> です。
                                </p>
                            </div>
                            <div id="rfc.section.9.2.2.p.2">
                                <p>エンドポイントは、禁止された暗号スイートのいずれかがネゴシエートされた場合、接続エラー（<a href="#ConnectionErrorHandler"
                                        title="Connection Error Handling">Section 5.4.1</a>）の <a
                                        href="#INADEQUATE_SECURITY">INADEQUATE_SECURITY</a> 型を生成することを選択しても <em
                                        class="bcp14">MAY</em>
                                    ます。禁止された暗号スイートを使用する展開は、その暗号スイートを受け入れる可能性のあるピアの集合が既知でない限り接続エラーを引き起こすリスクがあります。</p>
                            </div>
                            <div id="rfc.section.9.2.2.p.3">
                                <p>実装は、禁止されていない暗号スイートのネゴシエーションに反応してこのエラーを生成しては <em class="bcp14">MUST NOT</em>
                                    です。したがって、クライアントが禁止されていない暗号スイートを提示した場合、HTTP/2 を用いるにあたりその暗号スイートを使用する準備をしておかなければなりません。
                                </p>
                            </div>
                            <div id="rfc.section.9.2.2.p.4">
                                <p>禁止された暗号スイートのリストには TLS 1.2 が必須とする暗号スイートも含まれているため、TLS 1.2
                                    展開は許可される暗号スイートの集合が交差しない可能性があります。この問題を避けるため、TLS 1.2 を使用する HTTP/2 展開は <a
                                        href="#RFC5289"><cite
                                            title="TLS Elliptic Curve Cipher Suites with SHA-256/384 and AES Galois Counter Mode (GCM)">TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</cite></a>
                                    を P-256 楕円曲線と共にサポートしなければ <em class="bcp14">MUST</em> です。</p>
                            </div>
                            <div id="rfc.section.9.2.2.p.5">
                                <p>クライアントは、HTTP/2
                                    をサポートしていないサーバーへの接続を許容するために、禁止された暗号スイートのサポートを広告することがあります。これによりサーバーは禁止された暗号スイートを用いて
                                    HTTP/1.1 を選択することができます。しかし、アプリケーションプロトコルと暗号スイートが独立して選択される場合、禁止された暗号スイートで HTTP/2
                                    がネゴシエートされてしまう可能性があります。</p>
                            </div>
                        </section>
                        <section id="tls13features">
                            <h4 id="rfc.section.9.2.3"><a href="#rfc.section.9.2.3">9.2.3.</a>&nbsp;<a
                                    href="#tls13features">TLS 1.3 の機能</a></h4>
                            <div id="rfc.section.9.2.3.p.1">
                                <p>TLS 1.3 には以前のバージョンでは利用できなかった多くの機能があります。本節ではこれらの機能の使用について議論します。</p>
                            </div>
                            <div id="rfc.section.9.2.3.p.2">
                                <p>HTTP/2 サーバーは TLS 1.3 のハンドシェイク後の CertificateRequest メッセージを送信しては <em class="bcp14">MUST
                                        NOT</em> です。HTTP/2 クライアントは TLS のハンドシェイク後の CertificateRequest
                                    メッセージを受信した場合、それを接続エラー（<a href="#ConnectionErrorHandler"
                                        title="Connection Error Handling">Section 5.4.1</a>）の <a
                                        href="#PROTOCOL_ERROR">PROTOCOL_ERROR</a> として扱わなければ <em class="bcp14">MUST</em>
                                    です。
                                </p>
                            </div>
                            <div id="rfc.section.9.2.3.p.3">
                                <p>ハンドシェイク後認証に対する禁止は、クライアントが "post_handshake_auth" TLS
                                    拡張を提示していた場合でも適用されます。ハンドシェイク後認証のサポートは
                                    <a href="#RFC7301"><cite
                                            title="Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension">ALPN</cite></a>
                                    とは独立に広告され得ます。クライアントは他のプロトコルで使用するためにその能力を提示するかもしれませんが、その拡張の包含は HTTP/2
                                    内でのサポートを意味するものではありません。
                                </p>
                            </div>
                            <div id="rfc.section.9.2.3.p.4">
                                <p><a href="#RFC8446"><cite
                                            title="The Transport Layer Security (TLS) Protocol Version 1.3">[TLS13]</cite></a>
                                    は NewSessionTicket や KeyUpdate のような他のハンドシェイク後メッセージを定義しており、これらは HTTP/2
                                    と直接的な相互作用を持たないため使用可能です。アプリケーション層プロトコルとの相互作用に依存しない限り、これらの TLS
                                    メッセージはハンドシェイク完了後に送信できます。
                                </p>
                            </div>
                            <div id="rfc.section.9.2.3.p.5">
                                <p>TLS early data はリクエストを送信するために <em class="bcp14">MAY</em> 使用できますが、その際は <a
                                        href="#RFC8470"><cite title="Using Early Data in HTTP">[RFC8470]</cite></a>
                                    の指針に従う必要があります。クライアントはすべてのサーバ設定に対して初期値を仮定して early data 内でリクエストを送信します。</p>
                            </div>
                        </section>
                    </section>
                </section>
                <hr class="hidden-print">
                <section id="security">
                    <h2 id="rfc.section.10" class="np"><a href="#rfc.section.10">10.</a>&nbsp;<a
                            href="#security">セキュリティ考慮事項</a></h2>
                    <div id="rfc.section.10.p.1">
                        <p>TLS の使用は本プロトコルの多くのセキュリティ特性を提供するために必要です。本節の多くの主張は、<a href="#TLSUsage"
                                title="Use of TLS Features">Section 9.2</a> に記載されているように TLS が使用されない限り当てはまりません。</p>
                    </div>
                    <section id="authority">
                        <h3 id="rfc.section.10.1"><a href="#rfc.section.10.1">10.1.</a>&nbsp;<a
                                href="#authority">サーバーの権威</a></h3>
                        <div id="rfc.section.10.1.p.1">
                            <p>HTTP/2 は、ある応答の提供においてサーバーが権威を持つかどうかを判断するために HTTP の authority の定義に依存します（<a
                                    href="https://www.rfc-editor.org/rfc/rfc9110.html#section-4.3">RFC9110 の Section
                                    4.3</a>
                                を参照）。これは "<span class="tt">http</span>" URI スキームについてはローカルな名前解決に、"<span
                                    class="tt">https</span>" スキームについては認証されたサーバー識別に依存します。</p>
                        </div>
                    </section>
                    <section id="n-cross-protocol-attacks">
                        <h3 id="rfc.section.10.2"><a href="#rfc.section.10.2">10.2.</a>&nbsp;<a
                                href="#n-cross-protocol-attacks">クロスプロトコル攻撃</a></h3>
                        <div id="rfc.section.10.2.p.1">
                            <p>クロスプロトコル攻撃とは、攻撃者がクライアントにあるプロトコルでトランザクションを開始させ、そのトランザクションを別のプロトコルを理解するサーバーに向けさせるものです。攻撃者はトランザクションを第二のプロトコルで有効なものに見せかけることができる可能性があります。ウェブコンテキストの能力と組み合わせると、これはプライベートネットワーク内の保護が不十分なサーバーと相互作用するために利用され得ます。
                            </p>
                        </div>
                        <div id="rfc.section.10.2.p.2">
                            <p>ALPN 識別子として HTTP/2 を用いた TLS ハンドシェイクを完了することは、クロスプロトコル攻撃に対する十分な保護と見なせます。ALPN はサーバーが HTTP/2
                                で続行する意思があることを肯定的に示すため、他の TLS ベースのプロトコルへの攻撃を防ぎます。</p>
                        </div>
                        <div id="rfc.section.10.2.p.3">
                            <p>TLS による暗号化は、攻撃者が明文プロトコルに対するクロスプロトコル攻撃で利用するデータを制御することを困難にします。</p>
                        </div>
                        <div id="rfc.section.10.2.p.4">
                            <p>HTTP/2 の平文バージョンはクロスプロトコル攻撃に対する保護が最小限です。接続プレフェース（<a href="#preface"
                                    title="HTTP/2 Connection Preface">Section 3.4</a>）には HTTP/1.1
                                サーバーを混乱させるための文字列が含まれていますが、他のプロトコルに対する特別な保護は提供されていません。</p>
                        </div>
                    </section>
                    <section id="n-intermediary-encapsulation-attacks">
                        <h3 id="rfc.section.10.3"><a href="#rfc.section.10.3">10.3.</a>&nbsp;<a
                                href="#n-intermediary-encapsulation-attacks">インターミディアリによるカプセル化攻撃</a></h3>
                        <div id="rfc.section.10.3.p.1">
                            <p>HPACK は他の HTTP バージョンで区切り文字として扱われる可能性のあるフィールド名や値のエンコーディングを許可します。HTTP/2
                                のリクエストやレスポンスを変換するインターミディアリは、別の HTTP バージョンにメッセージを翻訳する前に <a href="#HttpHeaders"
                                    title="HTTP Fields">Section 8.2</a> の規則に従ってフィールドを検証しなければ <em class="bcp14">MUST</em>
                                なりません。無効な区切り文字を含むフィールドを翻訳すると、受信者がメッセージを誤って解釈するようになり、攻撃者に悪用される可能性があります。</p>
                        </div>
                        <div id="rfc.section.10.3.p.2">
                            <p><a href="#HttpHeaders" title="HTTP Fields">Section 8.2</a>
                                は擬似ヘッダーフィールドの検証に関する特定の規則を含んでいません。これらのフィールドの値が使用される場合、追加の検証が必要です。これは特に "<span
                                    class="tt">:scheme</span>", "<span class="tt">:authority</span>", "<span
                                    class="tt">:path</span>" を結合して単一の URI 文字列を形成する場合に重要です（<a href="#RFC3986"><cite
                                        title="Uniform Resource Identifier (URI): Generic Syntax">[RFC3986]</cite></a>）。類似の問題は、その
                                URI や単に "<span class="tt">:path</span>" を "<span class="tt">:method</span>"
                                と組み合わせてリクエスト行を構築する際にも発生する可能性があります。単純な連結は、入力値が完全に検証されない限り安全ではありません。</p>
                        </div>
                        <div id="rfc.section.10.3.p.3">
                            <p>インターミディアリは、無効なフィールド名や値を含むフィールドを他の理由で却下することができます。特に、<a
                                    href="https://www.rfc-editor.org/rfc/rfc9110.html#section-5">RFC9110 の Section 5</a>
                                に基づく HTTP ABNF 文法に準拠しないフィールドが該当します。<a href="#HttpHeaders" title="HTTP Fields">Section
                                    8.2</a> の最小限の検証以外を行わないインターミディアリは、無効なフィールド名や値を含むメッセージを転送してしまう可能性があります。</p>
                        </div>
                        <div id="rfc.section.10.3.p.4">
                            <p>インターミディアリが転送前に削除する必要のあるフィールドを受け取った場合（RFC9110 の Section 7.6.1
                                を参照）、それらのヘッダーフィールドを削除または置換して転送しなければ <em class="bcp14">MUST</em> です。加えて、インターミディアリは <span
                                    class="tt">Content-Length</span> フィールドを含むメッセージを転送する際にメッセージが正しく形成されるよう注意を払うべきです（<a
                                    href="#malformed" title="Malformed Messages">Section 8.1.1</a>）。これにより、メッセージが
                                HTTP/1.1
                                に翻訳される場合でもフレーミングが正しく保たれます。</p>
                        </div>
                    </section>
                    <section id="n-cacheability-of-pushed-responses">
                        <h3 id="rfc.section.10.4"><a href="#rfc.section.10.4">10.4.</a>&nbsp;<a
                                href="#n-cacheability-of-pushed-responses">プッシュされたレスポンスのキャッシュ可能性</a></h3>
                        <div id="rfc.section.10.4.p.1">
                            <p>プッシュされたレスポンスにはクライアントからの明示的なリクエストがありません。リクエストはサーバーが <a href="#PUSH_PROMISE"
                                    title="PUSH_PROMISE">PUSH_PROMISE</a> フレームで提供します。</p>
                        </div>
                        <div id="rfc.section.10.4.p.2">
                            <p>プッシュされたレスポンスのキャッシュは、オリジンサーバーが Cache-Control
                                ヘッダフィールドで示す指針に基づいて可能です。しかし、単一のサーバーが複数のテナントをホストする場合は問題が生じる可能性があります。例えば、サーバーが複数のユーザーにそれぞれ小さな
                                URI スペースを提供している場合などです。</p>
                        </div>
                        <div id="rfc.section.10.4.p.3">
                            <p>複数のテナントが同一サーバー上でスペースを共有する場合、そのサーバーはテナントが自分に権限のないリソースの表現をプッシュできないように <em
                                    class="bcp14">MUST</em>
                                確保しなければなりません。これを強制しないと、テナントがキャッシュから提供される表現を上書きする表現を提供できてしまいます。
                            </p>
                        </div>
                        <div id="rfc.section.10.4.p.4">
                            <p>オリジンサーバーが権威を持たないプッシュされたレスポンス（<a href="#authority" title="Server Authority">Section
                                    10.1</a>
                                を参照）を使用またはキャッシュしては <em class="bcp14">MUST NOT</em> です。</p>
                        </div>
                    </section>
                    <section id="dos">
                        <h3 id="rfc.section.10.5"><a href="#rfc.section.10.5">10.5.</a>&nbsp;<a
                                href="#dos">サービス拒否に関する考慮事項</a></h3>
                        <div id="rfc.section.10.5.p.1">
                            <p>HTTP/2 接続は HTTP/1.1
                                接続よりも動作させるためにより多くのリソースのコミットを要求する可能性があります。フィールドセクション圧縮やフロー制御はより多くの状態のコミットに依存します。これらの機能の設定は、これらの機能に対するメモリのコミットを厳密に境界付けることを保証します。
                            </p>
                        </div>
                        <div id="rfc.section.10.5.p.2">
                            <p><a href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a>
                                フレームの数は同様の方法で制約されていません。サーバープッシュを受け入れるクライアントは、"reserved (remote)" 状態にあるストリーム数を制限することが <em
                                    class="bcp14">SHOULD</em> です。過剰な数のサーバープッシュストリームは、<a href="#StreamErrorHandler"
                                    title="Stream Error Handling">Section 5.4.2</a> の <a
                                    href="#ENHANCE_YOUR_CALM">ENHANCE_YOUR_CALM</a> 型のストリームエラーとして扱うことができます。</p>
                        </div>
                        <div id="rfc.section.10.5.p.3" class="avoidbreakafter">
                            <p>いくつかの HTTP/2 実装はサービス拒否の脆弱性があることが発見されました（<a href="#NFLX-2019-002"><cite
                                        title="HTTP/2 Denial of Service Advisory">[NFLX-2019-002]</cite></a>）。以下は実装がサービス拒否攻撃にさらされる可能性のある既知の方法の一覧です：
                            </p>
                        </div>
                        <div id="rfc.section.10.5.p.4">
                            <ul>
                                <li>
                                    <div class="avoidbreakafter">
                                        <p>未送信の送信待ちフレームを非効率的に追跡すると、攻撃者が大量のフレームを送信キューに入れさせることにより過負荷を引き起こす可能性があります。ピアが大量のフレームを生成させるために使用し得るいくつかの手法があります：
                                        </p>
                                    </div>
                                    <div>
                                        <ul>
                                            <li>小さなフロー制御増分を <a href="#WINDOW_UPDATE"
                                                    title="WINDOW_UPDATE">WINDOW_UPDATE</a>
                                                フレームで提供することで、送信者が大量の <a href="#DATA" title="DATA">DATA</a>
                                                フレームを生成させられる可能性があります。</li>
                                            <li>エンドポイントは <a href="#PING" title="PING">PING</a> フレームに応答する必要があります。</li>
                                            <li>各 <a href="#SETTINGS" title="SETTINGS">SETTINGS</a> フレームは確認応答を必要とします。
                                            </li>
                                            <li>無効なリクエスト（またはサーバープッシュ）は、ピアに <a href="#RST_STREAM"
                                                    title="RST_STREAM">RST_STREAM</a> フレームを生成させる可能性があります。</li>
                                        </ul>
                                    </div>
                                </li>
                                <li>攻撃者が HTTP/2 レイヤーで大量のフロー制御クレジットを提供しつつ TCP 層でクレジットを抑制すると、フレームの送信が妨げられます。TCP
                                    の限界を考慮せずにフレームを構築し記憶するエンドポイントはリソース枯渇にさらされる可能性があります。</li>
                                <li>大量の小さいまたは空のフレームは、ピアにフレームヘッダの処理時間を浪費させるために悪用され得ます。ここでは注意が必要です。なぜなら、一部の小さなフレームの使用（例えば、ストリームの終端での空の
                                    <a href="#DATA" title="DATA">DATA</a> や <a href="#CONTINUATION"
                                        title="CONTINUATION">CONTINUATION</a> フレームの送信）は完全に正当な用途だからです。
                                </li>
                                <li><a href="#SETTINGS" title="SETTINGS">SETTINGS</a>
                                    フレームは、設定を無意味に変更したり、未定義の設定を多数送信したり、同じ設定を同じフレーム内で何度も変更したりすることでピアに余分な処理時間を費やさせるために悪用され得ます。
                                </li>
                                <li><a href="#PRIORITY" title="PRIORITY">PRIORITY</a>
                                    フレームによる再優先付けの処理は大きな処理時間を要することがあり、多数の
                                    <a href="#PRIORITY" title="PRIORITY">PRIORITY</a> フレームが送信されると過負荷を招く可能性があります。
                                </li>
                                <li>フィールドセクション圧縮も攻撃者が処理リソースを浪費させる機会を提供します。詳細は <a
                                        href="https://www.rfc-editor.org/rfc/rfc7541.html#section-7">RFC7541 の Section
                                        7</a>
                                    を参照してください。</li>
                                <li><a href="#SETTINGS" title="SETTINGS">SETTINGS</a>
                                    による制限は即座に縮小できないため、エンドポイントはピアの振る舞いに露出する可能性があります。特に接続確立直後、サーバーによって設定された制限はクライアントには知られておらず、明白なプロトコル違反でない限り超過され得ます。
                                </li>
                            </ul>
                        </div>
                        <div id="rfc.section.10.5.p.5">
                            <p>サービス拒否に悪用され得る機能の多く（<a href="#SETTINGS" title="SETTINGS">SETTINGS</a>
                                の変更、小さなフレーム、フィールドセクション圧縮など）は正当な用途があります。これらの機能は不必要または過度に使用されると負担になります。</p>
                        </div>
                        <div id="rfc.section.10.5.p.6">
                            <p>これらの機能の使用を監視しないエンドポイントはサービス拒否のリスクにさらされます。実装はこれらの機能の使用を追跡し、その使用に上限を設定することを <em
                                    class="bcp14">SHOULD</em> です。エンドポイントは疑わしい活動を <a href="#ConnectionErrorHandler"
                                    title="Connection Error Handling">Section 5.4.1</a> の種類の接続エラー（<a
                                    href="#ENHANCE_YOUR_CALM">ENHANCE_YOUR_CALM</a>）として扱っても <em class="bcp14">MAY</em>
                                です。
                            </p>
                        </div>
                        <section id="MaxFieldBlock">
                            <h4 id="rfc.section.10.5.1"><a href="#rfc.section.10.5.1">10.5.1.</a>&nbsp;<a
                                    href="#MaxFieldBlock">フィールドブロックサイズの制限</a></h4>
                            <div id="rfc.section.10.5.1.p.1">
                                <p>大きなフィールドブロック（<a href="#FieldBlock"
                                        title="Field Section Compression and Decompression">Section
                                        4.3</a>）は実装に大量の状態をコミットさせる可能性があります。ルーティングに重要なフィールド行がフィールドブロックの終わり近くに現れることがあり、これによりフィールドを最終的な宛先にストリーミングできなくなります。この並び順やキャッシュの正確性を確保するなどの理由により、エンドポイントはフィールドブロック全体をバッファリングする必要が生じることがあります。フィールドブロックのサイズには厳密な上限がないため、一部のエンドポイントはフィールドブロックのために大量のメモリをコミットさせられる可能性があります。
                                </p>
                            </div>
                            <div id="rfc.section.10.5.1.p.2">
                                <p>エンドポイントは <a href="#SETTINGS_MAX_HEADER_LIST_SIZE">SETTINGS_MAX_HEADER_LIST_SIZE</a>
                                    を使用して、非圧縮フィールドブロックのサイズに適用され得る制限をピアに助言することができます。この設定は助言的なものであるため、エンドポイントはこの制限を超えるフィールドブロックを送信することを
                                    <em class="bcp14">MAY</em>
                                    選択し、リクエストまたはレスポンスが誤形成として扱われるリスクを負うことができます。この設定は接続固有であるため、任意のリクエストまたはレスポンスがより低い未知の上限を持つホップに遭遇する可能性があります。インターミディアリは異なるピアが提示した値を渡すことでこの問題を回避しようと試みることができますが、そうする義務はありません。
                                </p>
                            </div>
                            <div id="rfc.section.10.5.1.p.3">
                                <p>サーバーが処理可能なより大きなフィールドブロックを受信した場合、HTTP 431 (Request Header Fields Too Large)
                                    ステータスコードを送信することができます（参考：<a href="#RFC6585"><cite
                                            title="Additional HTTP Status Codes">[RFC6585]</cite></a>）。クライアントは処理できないレスポンスを破棄することができます。フィールドブロックは一貫した接続状態を確保するために処理されなければ
                                    <em class="bcp14">MUST</em> なく、接続が閉じられる場合を除きます。
                                </p>
                            </div>
                        </section>
                        <section id="connectDos">
                            <h4 id="rfc.section.10.5.2"><a href="#rfc.section.10.5.2">10.5.2.</a>&nbsp;<a
                                    href="#connectDos">CONNECT に関する問題</a></h4>
                            <div id="rfc.section.10.5.2.p.1">
                                <p>CONNECT メソッドは、ストリームの作成が TCP
                                    接続の作成および維持と比較して比較的安価であるため、プロキシに対して不均衡な負荷を作り出すのに使用され得ます。プロキシは
                                    CONNECT リクエストを運ぶストリームの終了後も一部の TCP 接続リソースを維持する場合があり、これには送信側の TCP 接続が TIME_WAIT
                                    状態に残ることが含まれます。したがって、プロキシは <a
                                        href="#SETTINGS_MAX_CONCURRENT_STREAMS">SETTINGS_MAX_CONCURRENT_STREAMS</a> のみで
                                    CONNECT リクエストが消費するリソースを制限できるとは限りません。</p>
                            </div>
                        </section>
                    </section>
                    <section id="n-use-of-compression">
                        <h3 id="rfc.section.10.6"><a href="#rfc.section.10.6">10.6.</a>&nbsp;<a
                                href="#n-use-of-compression">圧縮の使用</a></h3>
                        <div id="rfc.section.10.6.p.1">
                            <p>圧縮は、機密データが攻撃者制御下のデータと同じコンテキストで圧縮されるときに攻撃者がその秘密を回復できるようにする可能性があります。HTTP/2 はフィールド行の圧縮（<a
                                    href="#FieldBlock" title="Field Section Compression and Decompression">Section
                                    4.3</a>）を可能にしますが、以下の懸念は HTTP 圧縮コンテンツ符号化の使用にも適用されます（RFC9110 の <a
                                    href="https://www.rfc-editor.org/rfc/rfc9110.html#section-8.4.1">Section 8.4.1</a>
                                を参照）。
                            </p>
                        </div>
                        <div id="rfc.section.10.6.p.2">
                            <p>Web の特性を悪用する圧縮に関する攻撃が実証されています（例：<a href="#BREACH"><cite
                                        title="BREACH: Reviving the CRIME Attack">[BREACH]</cite></a>）。攻撃者は異なる平文を含む複数のリクエストを誘導し、それぞれの結果の暗号文の長さを観察します。秘密に対する推測が正しいときに暗号文の長さが短くなることを見つけ出します。
                            </p>
                        </div>
                        <div id="rfc.section.10.6.p.3">
                            <p>安全なチャネルで通信する実装は、機密データと攻撃者制御のデータの両方を含むコンテンツを、別々の圧縮辞書を使用しない限り圧縮しては <em class="bcp14">MUST
                                    NOT</em> です。データのソースを確実に判別できない場合、圧縮は <em class="bcp14">MUST NOT</em> 使用されてはなりません。TLS
                                が提供するような汎用的なストリーム圧縮は、HTTP/2 では使用しては <em class="bcp14">MUST NOT</em> です（<a
                                    href="#TLSUsage" title="Use of TLS Features">Section 9.2</a> を参照）。</p>
                        </div>
                        <div id="rfc.section.10.6.p.4">
                            <p>ヘッダーフィールドの圧縮に関する追加の考慮事項は <a href="#RFC7541"><cite
                                        title="HPACK: Header Compression for HTTP/2">[COMPRESSION]</cite></a> に記載されています。
                            </p>
                        </div>
                    </section>
                    <section id="padding">
                        <h3 id="rfc.section.10.7"><a href="#rfc.section.10.7">10.7.</a>&nbsp;<a
                                href="#padding">パディングの使用</a>
                        </h3>
                        <div id="rfc.section.10.7.p.1">
                            <p>HTTP/2 内のパディングは、TLS（<a href="#RFC8446"><cite
                                        title="The Transport Layer Security (TLS) Protocol Version 1.3">TLS</cite></a>
                                <cite
                                    title="The Transport Layer Security (TLS) Protocol Version 1.3">[TLS13]</cite>）などが提供する一般目的のパディングの代替を意図したものではありません。冗長なパディングは逆効果になることさえあります。正しく適用するには、パディングされるデータに関する具体的な知識が必要な場合があります。
                            </p>
                        </div>
                        <div id="rfc.section.10.7.p.2">
                            <p>圧縮に依存する攻撃を軽減するために、パディングより圧縮の無効化や制限の方が好ましい場合があります。</p>
                        </div>
                        <div id="rfc.section.10.7.p.3">
                            <p>パディングはフレーム内容の正確なサイズを覆い隠すために使用でき、攻撃の緩和を目的として提供されています。例えば、攻撃者制御の平文と秘密データの両方を含む圧縮コンテンツに対する攻撃（<a
                                    href="#BREACH"><cite
                                        title="BREACH: Reviving the CRIME Attack">[BREACH]</cite></a>）のようなケースです。</p>
                        </div>
                        <div id="rfc.section.10.7.p.4">
                            <p>パディングの使用は一見したほどの保護をもたらさない場合があります。最良でも、パディングは攻撃者が観測しなければならないフレームの数を増やすことで長さ情報の推測を難しくするにすぎません。不適切に実装されたパディング方式は容易に破られます。特に、予測可能な分布のランダム化パディングはほとんど保護を提供しません。同様に、フレームペイロードを固定サイズにパディングすることは、フレームのペイロードサイズが固定境界を越えると情報を露出するため、攻撃者が平文を制御できる場合には問題を引き起こします。
                            </p>
                        </div>
                        <div id="rfc.section.10.7.p.5">
                            <p>インターミディアリは <a href="#DATA" title="DATA">DATA</a> フレームのパディングを保持することを <em
                                    class="bcp14">SHOULD</em> ますが、<a href="#HEADERS" title="HEADERS">HEADERS</a> および <a
                                    href="#PUSH_PROMISE" title="PUSH_PROMISE">PUSH_PROMISE</a> フレームのパディングは省略しても <em
                                    class="bcp14">MAY</em>
                                です。インターミディアリがフレームのパディング量を変更する正当な理由としては、パディングが提供する保護を改善するためのものがあります。</p>
                        </div>
                    </section>
                    <section id="n-privacy-considerations">
                        <h3 id="rfc.section.10.8"><a href="#rfc.section.10.8">10.8.</a>&nbsp;<a
                                href="#n-privacy-considerations">プライバシーに関する考慮事項</a></h3>
                        <div id="rfc.section.10.8.p.1">
                            <p>HTTP/2
                                のいくつかの特性は、観測者が単一のクライアントまたはサーバーの行動を時間を通じて相関付ける機会を提供します。これには設定の値、フロー制御ウィンドウの管理方法、ストリームへの優先度割り当ての方法、刺激に対する反応のタイミング、設定で制御される機能の取り扱いなどが含まれます。
                            </p>
                        </div>
                        <div id="rfc.section.10.8.p.2">
                            <p>これらが挙動の観測可能な違いを生む範囲では、それらは <a
                                    href="https://www.rfc-editor.org/rfc/rfc6973.html#section-3.2">RFC6973 の Section
                                    3.2</a>
                                に定義されたように特定のクライアントのフィンガープリンティングの基礎として利用され得ます（参照：<a href="#RFC6973"><cite
                                        title="Privacy Considerations for Internet Protocols">[PRIVACY]</cite></a>）。</p>
                        </div>
                        <div id="rfc.section.10.8.p.3">
                            <p>HTTP/2 が単一の TCP
                                接続を使用することを好む点は、サイト上でのユーザーの活動の相関を可能にします。異なるオリジンに対して接続を再利用することは、それらのオリジン間での追跡を許すことになります。
                            </p>
                        </div>
                        <div id="rfc.section.10.8.p.4">
                            <p>PING および SETTINGS
                                フレームは即時の応答を要求するため、これらはエンドポイントがピアまでのレイテンシを測定するために使用され得ます。特定のシナリオではこれはプライバシーへの影響を持つ可能性があります。
                            </p>
                        </div>
                    </section>
                    <section id="n-remote-timing-attacks">
                        <h3 id="rfc.section.10.9"><a href="#rfc.section.10.9">10.9.</a>&nbsp;<a
                                href="#n-remote-timing-attacks">リモートタイミング攻撃</a></h3>
                        <div id="rfc.section.10.9.p.1">
                            <p>リモートタイミング攻撃は、サーバーが秘密を使用するリクエストを処理する際の処理時間の変動を観測することで秘密を抽出します。HTTP/2
                                は同時のリクエスト作成と処理を可能にするため、攻撃者に対していつリクエスト処理が開始されるかについてより良い制御を与える可能性があります。複数の HTTP/2
                                リクエストが同一の IP
                                パケットや TLS レコードに含まれることがあり得ます。したがって、HTTP/2
                                はリクエスト配信の可変性を排除してリモートタイミング攻撃を効率化し得ます。残る時間的変動の要因はリクエストの順序とレスポンスの配信だけになります。</p>
                        </div>
                        <div id="rfc.section.10.9.p.2">
                            <p>処理時間が秘密の値に依存しないようにすることが、あらゆる形態のタイミング攻撃に対する最良の防御です。</p>
                        </div>
                    </section>
                </section>
                <hr class="hidden-print">
                <section id="iana">
                    <h2 id="rfc.section.11" class="np"><a href="#rfc.section.11">11.</a>&nbsp;<a
                            href="#iana">IANAに関する考慮事項</a></h2>
                    <div id="rfc.section.11.p.1">
                        <p>この改訂版のHTTP/2では、<span class="tt">HTTP2-Settings</span> ヘッダーフィールドと、
                            <span class="tt">h2c</span> アップグレードトークン（いずれも <a href="#RFC7540"><cite
                                    title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a> で定義）
                            を廃止済みとしています。
                        </p>
                    </div>
                    <div id="rfc.section.11.p.2">
                        <p><a href="https://www.rfc-editor.org/rfc/rfc7540.html#section-11">Section 11</a> は <a
                                href="#RFC7540"><cite
                                    title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a> において
                            <span class="tt">h2</span> および <span class="tt">h2c</span> の ALPN 識別子と
                            <span class="tt">PRI</span> HTTP メソッドを登録しました。RFC 7540 はまたフレームタイプ、
                            設定、およびエラーコードのためのレジストリを確立しました。これらの登録とレジストリは
                            HTTP/2 に適用され、本書では再定義していません。
                        </p>
                    </div>
                    <div id="rfc.section.11.p.3">
                        <p>IANA は次のレジストリにおける RFC 7540 への参照を本書を参照するよう更新しました：
                            "TLS Application-Layer Protocol Negotiation (ALPN) Protocol IDs"、"HTTP/2 Frame Type"、
                            "HTTP/2 Settings"、"HTTP/2 Error Code"、および "HTTP Method Registry"。<span class="tt">PRI</span>
                            メソッドの登録は <a href="#preface" title="HTTP/2 Connection Preface">Section 3.4</a> を参照するよう
                            更新されました；その他の節番号は変更されていません。</p>
                    </div>
                    <div id="rfc.section.11.p.4">
                        <p>IANA は RFC 7540 で実験的使用のために予約されていた "HTTP/2 Frame Type" および
                            "HTTP/2 Settings" レジストリの当該部分のポリシーを変更しました。これらのレジストリの部分は、
                            各レジストリの残りと同じポリシーで運用されます。</p>
                    </div>
                    <section id="HTTP2-Settings">
                        <h3 id="rfc.section.11.1"><a href="#rfc.section.11.1">11.1.</a>&nbsp;<a
                                href="#HTTP2-Settings">HTTP2-Settings ヘッダーフィールド登録</a></h3>
                        <div id="rfc.section.11.1.p.1" class="avoidbreakafter">
                            <p>本節では、<a href="https://www.rfc-editor.org/rfc/rfc7540.html#section-11.5">Section 11.5</a>
                                によって登録された
                                <span class="tt">HTTP2-Settings</span> ヘッダーフィールドを "Hypertext Transfer Protocol (HTTP)
                                Field
                                Name Registry"
                                で廃止済みとして扱うことを記します。この機能は削除されました：参照 <a href="#versioning"
                                    title="HTTP/2 Version Identification">Section 3.1</a>。登録は <a
                                    href="https://www.rfc-editor.org/rfc/rfc9110.html#section-18.4">Section 18.4</a> of
                                <a href="#RFC9110"><cite title="HTTP Semantics">[HTTP]</cite></a> が要求する詳細を含むように更新されています：
                            </p>
                        </div>
                        <div id="rfc.section.11.1.p.2">
                            <dl>
                                <dt>Field Name:</dt>
                                <dd style="margin-left: 1.5em">HTTP2-Settings</dd>
                                <dt>Status:</dt>
                                <dd style="margin-left: 1.5em">廃止済み</dd>
                                <dt>Reference:</dt>
                                <dd style="margin-left: 1.5em"><a
                                        href="https://www.rfc-editor.org/rfc/rfc7540.html#section-3.2.1">Section
                                        3.2.1</a> of <a href="#RFC7540"><cite
                                            title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>&nbsp;
                                </dd>
                                <dt>Comments:</dt>
                                <dd style="margin-left: 1.5em">廃止済み；本書の <a href="#HTTP2-Settings"
                                        title="HTTP2-Settings Header Field Registration">Section 11.1</a> を参照。</dd>
                            </dl>
                        </div>
                    </section>
                    <section id="iana-h2c">
                        <h3 id="rfc.section.11.2"><a href="#rfc.section.11.2">11.2.</a>&nbsp;<a href="#iana-h2c">h2c
                                アップグレードトークン</a></h3>
                        <div id="rfc.section.11.2.p.1" class="avoidbreakafter">
                            <p>本節は、<a href="https://www.rfc-editor.org/rfc/rfc7540.html#section-11.8">Section 11.8</a>
                                によって登録された
                                <span class="tt">h2c</span> アップグレードトークンを "Hypertext Transfer Protocol (HTTP) Upgrade
                                Token
                                Registry"
                                で廃止済みとして記録します。この機能は削除されました：参照 <a href="#versioning"
                                    title="HTTP/2 Version Identification">Section 3.1</a>。登録は次のように更新されます：
                            </p>
                        </div>
                        <div id="rfc.section.11.2.p.2">
                            <dl>
                                <dt>Value:</dt>
                                <dd style="margin-left: 1.5em">h2c</dd>
                                <dt>Description:</dt>
                                <dd style="margin-left: 1.5em">(OBSOLETE) Hypertext Transfer Protocol version 2 (HTTP/2)
                                </dd>
                                <dt>Expected Version Tokens:</dt>
                                <dd style="margin-left: 1.5em">なし</dd>
                                <dt>Reference:</dt>
                                <dd style="margin-left: 1.5em"><a href="#versioning"
                                        title="HTTP/2 Version Identification">Section 3.1</a> of this document</dd>
                            </dl>
                        </div>
                    </section>
                </section>
                <section class="np">
                    <div id="rfc.references">
                        <h2 id="rfc.section.12"><a href="#rfc.section.12">12.</a> 参考文献</h2>
                        <section>
                            <div id="rfc.references.2">
                                <h3 id="rfc.section.12.1"><a href="#rfc.section.12.1">12.1.</a> ノルマティブ参考文献
                                </h3>
                                <dl class="dl-horizontal">
                                    <dt id="RFC9111">[<a href="#RFC9111" class="smpl">CACHING</a>]</dt>
                                    <dd>Fielding, R., 編, Nottingham, M., 編, および J. Reschke, 編, “<a
                                            href="https://www.rfc-editor.org/rfc/rfc9111.html">HTTP Caching</a>”, <a
                                            href="https://www.rfc-editor.org/info/std98">STD 98</a>, RFC 9111, <a
                                            href="https://dx.doi.org/10.17487/RFC9111">DOI 10.17487/RFC9111</a>,
                                        2022年6月,
                                        &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc9111">https://www.rfc-editor.org/info/rfc9111</a>&gt;。
                                    </dd>
                                    <dt id="RFC7541">[<a href="#RFC7541" class="smpl">COMPRESSION</a>]</dt>
                                    <dd>Peon, R. および H. Ruellan, “<a
                                            href="https://www.rfc-editor.org/rfc/rfc7541.html">HPACK: Header Compression
                                            for HTTP/2</a>”, RFC 7541, <a href="https://dx.doi.org/10.17487/RFC7541">DOI
                                            10.17487/RFC7541</a>, 2015年5月, &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc7541">https://www.rfc-editor.org/info/rfc7541</a>&gt;。
                                    </dd>
                                    <dt id="RFC6265">[<a href="#RFC6265" class="smpl">COOKIE</a>]</dt>
                                    <dd>Barth, A., “<a href="https://www.rfc-editor.org/rfc/rfc6265.html">HTTP State
                                            Management Mechanism</a>”, RFC 6265, <a
                                            href="https://dx.doi.org/10.17487/RFC6265">DOI 10.17487/RFC6265</a>,
                                        2011年4月,
                                        &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc6265">https://www.rfc-editor.org/info/rfc6265</a>&gt;。
                                    </dd>
                                    <dt id="RFC9110">[<a href="#RFC9110" class="smpl">HTTP</a>]</dt>
                                    <dd>Fielding, R., 編, Nottingham, M., 編, および J. Reschke, 編, “<a
                                            href="https://www.rfc-editor.org/rfc/rfc9110.html">HTTP Semantics</a>”, <a
                                            href="https://www.rfc-editor.org/info/std97">STD 97</a>, RFC 9110, <a
                                            href="https://dx.doi.org/10.17487/RFC9110">DOI 10.17487/RFC9110</a>,
                                        2022年6月,
                                        &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc9110">https://www.rfc-editor.org/info/rfc9110</a>&gt;。
                                    </dd>
                                    <dt id="RFC9000">[<a href="#RFC9000" class="smpl">QUIC</a>]</dt>
                                    <dd>Iyengar, J., 編および M. Thomson, 編, “<a
                                            href="https://www.rfc-editor.org/rfc/rfc9000.html">QUIC: A UDP-Based
                                            Multiplexed and Secure Transport</a>”, RFC 9000, <a
                                            href="https://dx.doi.org/10.17487/RFC9000">DOI 10.17487/RFC9000</a>,
                                        2021年5月,
                                        &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc9000">https://www.rfc-editor.org/info/rfc9000</a>&gt;。
                                    </dd>
                                    <dt id="RFC2119">[<a href="#RFC2119" class="smpl">RFC2119</a>]</dt>
                                    <dd>Bradner, S., “<a href="https://www.rfc-editor.org/rfc/rfc2119.html">Key words
                                            for use in RFCs to Indicate Requirement Levels</a>”, <a
                                            href="https://www.rfc-editor.org/info/bcp14">BCP 14</a>, RFC 2119, <a
                                            href="https://dx.doi.org/10.17487/RFC2119">DOI 10.17487/RFC2119</a>,
                                        1997年3月,
                                        &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;。
                                    </dd>
                                    <dt id="RFC3986">[<a href="#RFC3986" class="smpl">RFC3986</a>]</dt>
                                    <dd>Berners-Lee, T., Fielding, R., および L. Masinter, “<a
                                            href="https://www.rfc-editor.org/rfc/rfc3986.html">Uniform Resource
                                            Identifier (URI): Generic Syntax</a>”, <a
                                            href="https://www.rfc-editor.org/info/std66">STD 66</a>, RFC 3986, <a
                                            href="https://dx.doi.org/10.17487/RFC3986">DOI 10.17487/RFC3986</a>,
                                        2005年1月,
                                        &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc3986">https://www.rfc-editor.org/info/rfc3986</a>&gt;。
                                    </dd>
                                    <dt id="RFC8174">[<a href="#RFC8174" class="smpl">RFC8174</a>]</dt>
                                    <dd>Leiba, B., “<a href="https://www.rfc-editor.org/rfc/rfc8174.html">Ambiguity of
                                            Uppercase vs Lowercase in RFC 2119 Key Words</a>”, <a
                                            href="https://www.rfc-editor.org/info/bcp14">BCP 14</a>, RFC 8174, <a
                                            href="https://dx.doi.org/10.17487/RFC8174">DOI 10.17487/RFC8174</a>,
                                        2017年5月,
                                        &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;。
                                    </dd>
                                    <dt id="RFC8422">[<a href="#RFC8422" class="smpl">RFC8422</a>]</dt>
                                    <dd>Nir, Y., Josefsson, S., および M. Pegourie-Gonnard, “<a
                                            href="https://www.rfc-editor.org/rfc/rfc8422.html">Elliptic Curve
                                            Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS) Versions
                                            1.2 and Earlier</a>”, RFC 8422, <a
                                            href="https://dx.doi.org/10.17487/RFC8422">DOI 10.17487/RFC8422</a>,
                                        2018年8月,
                                        &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc8422">https://www.rfc-editor.org/info/rfc8422</a>&gt;。
                                    </dd>
                                    <dt id="RFC8470">[<a href="#RFC8470" class="smpl">RFC8470</a>]</dt>
                                    <dd>Thomson, M., Nottingham, M., および W. Tarreau, “<a
                                            href="https://www.rfc-editor.org/rfc/rfc8470.html">Using Early Data in
                                            HTTP</a>”, RFC 8470, <a href="https://dx.doi.org/10.17487/RFC8470">DOI
                                            10.17487/RFC8470</a>, 2018年9月, &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc8470">https://www.rfc-editor.org/info/rfc8470</a>&gt;。
                                    </dd>
                                    <dt id="RFC0793">[<a href="#RFC0793" class="smpl">TCP</a>]</dt>
                                    <dd>Postel, J., “<a href="https://www.rfc-editor.org/rfc/rfc793.html">Transmission
                                            Control Protocol</a>”, <a href="https://www.rfc-editor.org/info/std7">STD
                                            7</a>, RFC 793, <a href="https://dx.doi.org/10.17487/RFC0793">DOI
                                            10.17487/RFC0793</a>, 1981年9月, &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc793">https://www.rfc-editor.org/info/rfc793</a>&gt;。
                                    </dd>
                                    <dt id="RFC7301">[<a href="#RFC7301" class="smpl">TLS-ALPN</a>]</dt>
                                    <dd>Friedl, S., Popov, A., Langley, A., および E. Stephan, “<a
                                            href="https://www.rfc-editor.org/rfc/rfc7301.html">Transport Layer Security
                                            (TLS) Application-Layer Protocol Negotiation Extension</a>”, RFC 7301, <a
                                            href="https://dx.doi.org/10.17487/RFC7301">DOI 10.17487/RFC7301</a>,
                                        2014年7月,
                                        &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc7301">https://www.rfc-editor.org/info/rfc7301</a>&gt;。
                                    </dd>
                                    <dt id="RFC5289">[<a href="#RFC5289" class="smpl">TLS-ECDHE</a>]</dt>
                                    <dd>Rescorla, E., “<a href="https://www.rfc-editor.org/rfc/rfc5289.html">TLS
                                            Elliptic Curve Cipher Suites with SHA-256/384 and AES Galois Counter Mode
                                            (GCM)</a>”, RFC 5289, <a href="https://dx.doi.org/10.17487/RFC5289">DOI
                                            10.17487/RFC5289</a>, 2008年8月, &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc5289">https://www.rfc-editor.org/info/rfc5289</a>&gt;。
                                    </dd>
                                    <dt id="RFC6066">[<a href="#RFC6066" class="smpl">TLS-EXT</a>]</dt>
                                    <dd>Eastlake 3rd, D., “<a
                                            href="https://www.rfc-editor.org/rfc/rfc6066.html">Transport
                                            Layer Security
                                            (TLS) Extensions: Extension Definitions</a>”, RFC 6066, <a
                                            href="https://dx.doi.org/10.17487/RFC6066">DOI 10.17487/RFC6066</a>,
                                        2011年1月,
                                        &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc6066">https://www.rfc-editor.org/info/rfc6066</a>&gt;。
                                    </dd>
                                    <dt id="RFC5246">[<a href="#RFC5246" class="smpl">TLS12</a>]</dt>
                                    <dd>Dierks, T. および E. Rescorla, “<a
                                            href="https://www.rfc-editor.org/rfc/rfc5246.html">The Transport Layer
                                            Security (TLS) Protocol Version 1.2</a>”, RFC 5246, <a
                                            href="https://dx.doi.org/10.17487/RFC5246">DOI 10.17487/RFC5246</a>,
                                        2008年8月,
                                        &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc5246">https://www.rfc-editor.org/info/rfc5246</a>&gt;。
                                    </dd>
                                    <dt id="RFC8446">[<a href="#RFC8446" class="smpl">TLS13</a>]</dt>
                                    <dd>Rescorla, E., “<a href="https://www.rfc-editor.org/rfc/rfc8446.html">The
                                            Transport Layer Security (TLS) Protocol Version 1.3</a>”, RFC 8446, <a
                                            href="https://dx.doi.org/10.17487/RFC8446">DOI 10.17487/RFC8446</a>,
                                        2018年8月,
                                        &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc8446">https://www.rfc-editor.org/info/rfc8446</a>&gt;。
                                    </dd>
                                    <dt id="RFC7525">[<a href="#RFC7525" class="smpl">TLSBCP</a>]</dt>
                                    <dd>Sheffer, Y., Holz, R., および P. Saint-Andre, “<a
                                            href="https://www.rfc-editor.org/rfc/rfc7525.html">Recommendations for
                                            Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer
                                            Security (DTLS)</a>”, <a href="https://www.rfc-editor.org/info/bcp195">BCP
                                            195</a>, RFC 7525, <a href="https://dx.doi.org/10.17487/RFC7525">DOI
                                            10.17487/RFC7525</a>, 2015年5月, &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc7525">https://www.rfc-editor.org/info/rfc7525</a>&gt;。
                                    </dd>
                                </dl>
                            </div>
                        </section>
                        <section>
                            <div id="rfc.references.3">
                                <h3 id="rfc.section.12.2"><a href="#rfc.section.12.2">12.2.</a> 参考資料（情報提供）
                                </h3>
                                <dl class="dl-horizontal">
                                    <dt id="RFC7838">[<a href="#RFC7838" class="smpl">ALT-SVC</a>]</dt>
                                    <dd>Nottingham, M., McManus, P., および J. Reschke, “<a
                                            href="https://www.rfc-editor.org/rfc/rfc7838.html">HTTP Alternative
                                            Services</a>”, RFC 7838, <a href="https://dx.doi.org/10.17487/RFC7838">DOI
                                            10.17487/RFC7838</a>, 2016年4月, &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc7838">https://www.rfc-editor.org/info/rfc7838</a>&gt;。
                                    </dd>
                                    <dt id="BREACH">[<a href="#BREACH" class="smpl">BREACH</a>]</dt>
                                    <dd>Gluck, Y., Harris, N., および A. Prado, “<a
                                            href="https://breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf">BREACH:
                                            Reviving the CRIME Attack</a>”, 2013年7月, &lt;<a
                                            href="https://breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf">https://breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf</a>&gt;。
                                    </dd>
                                    <dt id="RFC8499">[<a href="#RFC8499" class="smpl">DNS-TERMS</a>]</dt>
                                    <dd>Hoffman, P., Sullivan, A., および K. Fujiwara, “<a
                                            href="https://www.rfc-editor.org/rfc/rfc8499.html">DNS Terminology</a>”, <a
                                            href="https://www.rfc-editor.org/info/bcp219">BCP 219</a>, RFC 8499, <a
                                            href="https://dx.doi.org/10.17487/RFC8499">DOI 10.17487/RFC8499</a>,
                                        2019年1月,
                                        &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc8499">https://www.rfc-editor.org/info/rfc8499</a>&gt;。
                                    </dd>
                                    <dt id="RFC9218">[<a href="#RFC9218" class="smpl">HTTP-PRIORITY</a>]</dt>
                                    <dd>Oku, K. および L. Pardue, “<a
                                            href="https://www.rfc-editor.org/rfc/rfc9218.html">Extensible Prioritization
                                            Scheme for HTTP</a>”, RFC 9218, <a
                                            href="https://dx.doi.org/10.17487/RFC9218">DOI 10.17487/RFC9218</a>,
                                        2022年6月,
                                        &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc9218">https://www.rfc-editor.org/info/rfc9218</a>&gt;。
                                    </dd>
                                    <dt id="RFC9112">[<a href="#RFC9112" class="smpl">HTTP/1.1</a>]</dt>
                                    <dd>Fielding, R., 編, Nottingham, M., 編, および J. Reschke, 編, “<a
                                            href="https://www.rfc-editor.org/rfc/rfc9112.html">HTTP/1.1</a>”, <a
                                            href="https://www.rfc-editor.org/info/std99">STD 99</a>, RFC 9112, <a
                                            href="https://dx.doi.org/10.17487/RFC9112">DOI 10.17487/RFC9112</a>,
                                        2022年6月,
                                        &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc9112">https://www.rfc-editor.org/info/rfc9112</a>&gt;。
                                    </dd>
                                    <dt id="NFLX-2019-002">[<a href="#NFLX-2019-002" class="smpl">NFLX-2019-002</a>]
                                    </dt>
                                    <dd>Netflix, “<a
                                            href="https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md">HTTP/2
                                            Denial of Service Advisory</a>”, 2019年8月, &lt;<a
                                            href="https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md">https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md</a>&gt;。
                                    </dd>
                                    <dt id="RFC6973">[<a href="#RFC6973" class="smpl">PRIVACY</a>]</dt>
                                    <dd>Cooper, A., Tschofenig, H., Aboba, B., Peterson, J., Morris, J., Hansen, M., および
                                        R. Smith, “<a href="https://www.rfc-editor.org/rfc/rfc6973.html">Privacy
                                            Considerations for Internet Protocols</a>”, RFC 6973, <a
                                            href="https://dx.doi.org/10.17487/RFC6973">DOI 10.17487/RFC6973</a>,
                                        2013年7月,
                                        &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc6973">https://www.rfc-editor.org/info/rfc6973</a>&gt;。
                                    </dd>
                                    <dt id="RFC1122">[<a href="#RFC1122" class="smpl">RFC1122</a>]</dt>
                                    <dd>Braden, R., 編, “<a
                                            href="https://www.rfc-editor.org/rfc/rfc1122.html">Requirements
                                            for Internet
                                            Hosts - Communication Layers</a>”, <a
                                            href="https://www.rfc-editor.org/info/std3">STD 3</a>, RFC 1122, <a
                                            href="https://dx.doi.org/10.17487/RFC1122">DOI 10.17487/RFC1122</a>,
                                        1989年10月,
                                        &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc1122">https://www.rfc-editor.org/info/rfc1122</a>&gt;。
                                    </dd>
                                    <dt id="RFC3749">[<a href="#RFC3749" class="smpl">RFC3749</a>]</dt>
                                    <dd>Hollenbeck, S., “<a href="https://www.rfc-editor.org/rfc/rfc3749.html">Transport
                                            Layer Security Protocol Compression Methods</a>”, RFC 3749, <a
                                            href="https://dx.doi.org/10.17487/RFC3749">DOI 10.17487/RFC3749</a>,
                                        2004年5月,
                                        &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc3749">https://www.rfc-editor.org/info/rfc3749</a>&gt;。
                                    </dd>
                                    <dt id="RFC6125">[<a href="#RFC6125" class="smpl">RFC6125</a>]</dt>
                                    <dd>Saint-Andre, P. および J. Hodges, “<a
                                            href="https://www.rfc-editor.org/rfc/rfc6125.html">Representation and
                                            Verification of Domain-Based Application Service Identity within Internet
                                            Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of
                                            Transport Layer Security (TLS)</a>”, RFC 6125, <a
                                            href="https://dx.doi.org/10.17487/RFC6125">DOI 10.17487/RFC6125</a>,
                                        2011年3月,
                                        &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc6125">https://www.rfc-editor.org/info/rfc6125</a>&gt;。
                                    </dd>
                                    <dt id="RFC6585">[<a href="#RFC6585" class="smpl">RFC6585</a>]</dt>
                                    <dd>Nottingham, M. および R. Fielding, “<a
                                            href="https://www.rfc-editor.org/rfc/rfc6585.html">Additional HTTP Status
                                            Codes</a>”, RFC 6585, <a href="https://dx.doi.org/10.17487/RFC6585">DOI
                                            10.17487/RFC6585</a>, 2012年4月, &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc6585">https://www.rfc-editor.org/info/rfc6585</a>&gt;。
                                    </dd>
                                    <dt id="RFC7323">[<a href="#RFC7323" class="smpl">RFC7323</a>]</dt>
                                    <dd>Borman, D., Braden, B., Jacobson, V., および R. Scheffenegger, 編, “<a
                                            href="https://www.rfc-editor.org/rfc/rfc7323.html">TCP Extensions for High
                                            Performance</a>”, RFC 7323, <a
                                            href="https://dx.doi.org/10.17487/RFC7323">DOI
                                            10.17487/RFC7323</a>, 2014年9月, &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc7323">https://www.rfc-editor.org/info/rfc7323</a>&gt;。
                                    </dd>
                                    <dt id="RFC7540">[<a href="#RFC7540" class="smpl">RFC7540</a>]</dt>
                                    <dd>Belshe, M., Peon, R., および M. Thomson, 編, “<a
                                            href="https://www.rfc-editor.org/rfc/rfc7540.html">Hypertext Transfer
                                            Protocol Version 2 (HTTP/2)</a>”, RFC 7540, <a
                                            href="https://dx.doi.org/10.17487/RFC7540">DOI 10.17487/RFC7540</a>,
                                        2015年5月,
                                        &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc7540">https://www.rfc-editor.org/info/rfc7540</a>&gt;。
                                    </dd>
                                    <dt id="RFC8441">[<a href="#RFC8441" class="smpl">RFC8441</a>]</dt>
                                    <dd>McManus, P., “<a
                                            href="https://www.rfc-editor.org/rfc/rfc8441.html">Bootstrapping
                                            WebSockets
                                            with HTTP/2</a>”, RFC 8441, <a
                                            href="https://dx.doi.org/10.17487/RFC8441">DOI
                                            10.17487/RFC8441</a>, 2018年9月, &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc8441">https://www.rfc-editor.org/info/rfc8441</a>&gt;。
                                    </dd>
                                    <dt id="RFC8740">[<a href="#RFC8740" class="smpl">RFC8740</a>]</dt>
                                    <dd>Benjamin, D., “<a href="https://www.rfc-editor.org/rfc/rfc8740.html">Using TLS
                                            1.3 with HTTP/2</a>”, RFC 8740, <a
                                            href="https://dx.doi.org/10.17487/RFC8740">DOI 10.17487/RFC8740</a>,
                                        2020年2月,
                                        &lt;<a
                                            href="https://www.rfc-editor.org/info/rfc8740">https://www.rfc-editor.org/info/rfc8740</a>&gt;。
                                    </dd>
                                    <dt id="TALKING">[<a href="#TALKING" class="smpl">TALKING</a>]</dt>
                                    <dd>Huang, L., Chen, E., Barth, A., Rescorla, E., および C. Jackson, “<a
                                            href="https://www.adambarth.com/papers/2011/huang-chen-barth-rescorla-jackson.pdf">Talking
                                            to Yourself for Fun and Profit</a>”, 2011年, &lt;<a
                                            href="https://www.adambarth.com/papers/2011/huang-chen-barth-rescorla-jackson.pdf">https://www.adambarth.com/papers/2011/huang-chen-barth-rescorla-jackson.pdf</a>&gt;。
                                    </dd>
                                </dl>
                            </div>
                        </section>
                    </div>
                </section>
                <hr class="hidden-print">
                <section id="BadCipherSuites">
                    <h2 id="rfc.section.A" class="np"><a href="#rfc.section.A">付録 A.</a>&nbsp;<a
                            href="#BadCipherSuites">禁止された TLS 1.2 暗号スイート</a></h2>
                    <div id="rfc.section.A.p.1" class="avoidbreakafter">
                        <p>HTTP/2 実装は、次のいずれかの暗号スイートが TLS 1.2 によって交渉された場合を、
                            接続エラー（<a href="#ConnectionErrorHandler" title="Connection Error Handling">Section 5.4.1</a>）
                            タイプ <a href="#INADEQUATE_SECURITY">INADEQUATE_SECURITY</a> として扱うことが <em
                                class="bcp14">MAY</em>
                            です：</p>
                    </div>
                    <div id="rfc.section.A.p.2">
                        <ul>
                            <li>TLS_NULL_WITH_NULL_NULL</li>
                            <li>TLS_RSA_WITH_NULL_MD5</li>
                            <li>TLS_RSA_WITH_NULL_SHA</li>
                            <li>TLS_RSA_EXPORT_WITH_RC4_40_MD5</li>
                            <li>TLS_RSA_WITH_RC4_128_MD5</li>
                            <li>TLS_RSA_WITH_RC4_128_SHA</li>
                            <li>TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5</li>
                            <li>TLS_RSA_WITH_IDEA_CBC_SHA</li>
                            <li>TLS_RSA_EXPORT_WITH_DES40_CBC_SHA</li>
                            <li>TLS_RSA_WITH_DES_CBC_SHA</li>
                            <li>TLS_RSA_WITH_3DES_EDE_CBC_SHA</li>
                            <li>TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA</li>
                            <li>TLS_DH_DSS_WITH_DES_CBC_SHA</li>
                            <li>TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA</li>
                            <li>TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA</li>
                            <li>TLS_DH_RSA_WITH_DES_CBC_SHA</li>
                            <li>TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA</li>
                            <li>TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA</li>
                            <li>TLS_DHE_DSS_WITH_DES_CBC_SHA</li>
                            <li>TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA</li>
                            <li>TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA</li>
                            <li>TLS_DHE_RSA_WITH_DES_CBC_SHA</li>
                            <li>TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA</li>
                            <li>TLS_DH_anon_EXPORT_WITH_RC4_40_MD5</li>
                            <li>TLS_DH_anon_WITH_RC4_128_MD5</li>
                            <li>TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA</li>
                            <li>TLS_DH_anon_WITH_DES_CBC_SHA</li>
                            <li>TLS_DH_anon_WITH_3DES_EDE_CBC_SHA</li>
                            <li>TLS_KRB5_WITH_DES_CBC_SHA</li>
                            <li>TLS_KRB5_WITH_3DES_EDE_CBC_SHA</li>
                            <li>TLS_KRB5_WITH_RC4_128_SHA</li>
                            <li>TLS_KRB5_WITH_IDEA_CBC_SHA</li>
                            <li>TLS_KRB5_WITH_DES_CBC_MD5</li>
                            <li>TLS_KRB5_WITH_3DES_EDE_CBC_MD5</li>
                            <li>TLS_KRB5_WITH_RC4_128_MD5</li>
                            <li>TLS_KRB5_WITH_IDEA_CBC_MD5</li>
                            <li>TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA</li>
                            <li>TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA</li>
                            <li>TLS_KRB5_EXPORT_WITH_RC4_40_SHA</li>
                            <li>TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5</li>
                            <li>TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5</li>
                            <li>TLS_KRB5_EXPORT_WITH_RC4_40_MD5</li>
                            <li>TLS_PSK_WITH_NULL_SHA</li>
                            <li>TLS_DHE_PSK_WITH_NULL_SHA</li>
                            <li>TLS_RSA_PSK_WITH_NULL_SHA</li>
                            <li>TLS_RSA_WITH_AES_128_CBC_SHA</li>
                            <li>TLS_DH_DSS_WITH_AES_128_CBC_SHA</li>
                            <li>TLS_DH_RSA_WITH_AES_128_CBC_SHA</li>
                            <li>TLS_DHE_DSS_WITH_AES_128_CBC_SHA</li>
                            <li>TLS_DHE_RSA_WITH_AES_128_CBC_SHA</li>
                            <li>TLS_DH_anon_WITH_AES_128_CBC_SHA</li>
                            <li>TLS_RSA_WITH_AES_256_CBC_SHA</li>
                            <li>TLS_DH_DSS_WITH_AES_256_CBC_SHA</li>
                            <li>TLS_DH_RSA_WITH_AES_256_CBC_SHA</li>
                            <li>TLS_DHE_DSS_WITH_AES_256_CBC_SHA</li>
                            <li>TLS_DHE_RSA_WITH_AES_256_CBC_SHA</li>
                            <li>TLS_DH_anon_WITH_AES_256_CBC_SHA</li>
                            <li>TLS_RSA_WITH_NULL_SHA256</li>
                            <li>TLS_RSA_WITH_AES_128_CBC_SHA256</li>
                            <li>TLS_RSA_WITH_AES_256_CBC_SHA256</li>
                            <li>TLS_DH_DSS_WITH_AES_128_CBC_SHA256</li>
                            <li>TLS_DH_RSA_WITH_AES_128_CBC_SHA256</li>
                            <li>TLS_DHE_DSS_WITH_AES_128_CBC_SHA256</li>
                            <li>TLS_RSA_WITH_CAMELLIA_128_CBC_SHA</li>
                            <li>TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA</li>
                            <li>TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA</li>
                            <li>TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA</li>
                            <li>TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA</li>
                            <li>TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA</li>
                            <li>TLS_DHE_RSA_WITH_AES_128_CBC_SHA256</li>
                            <li>TLS_DH_DSS_WITH_AES_256_CBC_SHA256</li>
                            <li>TLS_DH_RSA_WITH_AES_256_CBC_SHA256</li>
                            <li>TLS_DHE_DSS_WITH_AES_256_CBC_SHA256</li>
                            <li>TLS_DHE_RSA_WITH_AES_256_CBC_SHA256</li>
                            <li>TLS_DH_anon_WITH_AES_128_CBC_SHA256</li>
                            <li>TLS_DH_anon_WITH_AES_256_CBC_SHA256</li>
                            <li>TLS_RSA_WITH_CAMELLIA_256_CBC_SHA</li>
                            <li>TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA</li>
                            <li>TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA</li>
                            <li>TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA</li>
                            <li>TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA</li>
                            <li>TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA</li>
                            <li>TLS_PSK_WITH_RC4_128_SHA</li>
                            <li>TLS_PSK_WITH_3DES_EDE_CBC_SHA</li>
                            <li>TLS_PSK_WITH_AES_128_CBC_SHA</li>
                            <li>TLS_PSK_WITH_AES_256_CBC_SHA</li>
                            <li>TLS_DHE_PSK_WITH_RC4_128_SHA</li>
                            <li>TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA</li>
                            <li>TLS_DHE_PSK_WITH_AES_128_CBC_SHA</li>
                            <li>TLS_DHE_PSK_WITH_AES_256_CBC_SHA</li>
                            <li>TLS_RSA_PSK_WITH_RC4_128_SHA</li>
                            <li>TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA</li>
                            <li>TLS_RSA_PSK_WITH_AES_128_CBC_SHA</li>
                            <li>TLS_RSA_PSK_WITH_AES_256_CBC_SHA</li>
                            <li>TLS_RSA_WITH_SEED_CBC_SHA</li>
                            <li>TLS_DH_DSS_WITH_SEED_CBC_SHA</li>
                            <li>TLS_DH_RSA_WITH_SEED_CBC_SHA</li>
                            <li>TLS_DHE_DSS_WITH_SEED_CBC_SHA</li>
                            <li>TLS_DHE_RSA_WITH_SEED_CBC_SHA</li>
                            <li>TLS_DH_anon_WITH_SEED_CBC_SHA</li>
                            <li>TLS_RSA_WITH_AES_128_GCM_SHA256</li>
                            <li>TLS_RSA_WITH_AES_256_GCM_SHA384</li>
                            <li>TLS_DH_RSA_WITH_AES_128_GCM_SHA256</li>
                            <li>TLS_DH_RSA_WITH_AES_256_GCM_SHA384</li>
                            <li>TLS_DH_DSS_WITH_AES_128_GCM_SHA256</li>
                            <li>TLS_DH_DSS_WITH_AES_256_GCM_SHA384</li>
                            <li>TLS_DH_anon_WITH_AES_128_GCM_SHA256</li>
                            <li>TLS_DH_anon_WITH_AES_256_GCM_SHA384</li>
                            <li>TLS_PSK_WITH_AES_128_GCM_SHA256</li>
                            <li>TLS_PSK_WITH_AES_256_GCM_SHA384</li>
                            <li>TLS_RSA_PSK_WITH_AES_128_GCM_SHA256</li>
                            <li>TLS_RSA_PSK_WITH_AES_256_GCM_SHA384</li>
                            <li>TLS_PSK_WITH_AES_128_CBC_SHA256</li>
                            <li>TLS_PSK_WITH_AES_256_CBC_SHA384</li>
                            <li>TLS_PSK_WITH_NULL_SHA256</li>
                            <li>TLS_PSK_WITH_NULL_SHA384</li>
                            <li>TLS_DHE_PSK_WITH_AES_128_CBC_SHA256</li>
                            <li>TLS_DHE_PSK_WITH_AES_256_CBC_SHA384</li>
                            <li>TLS_DHE_PSK_WITH_NULL_SHA256</li>
                            <li>TLS_DHE_PSK_WITH_NULL_SHA384</li>
                            <li>TLS_RSA_PSK_WITH_AES_128_CBC_SHA256</li>
                            <li>TLS_RSA_PSK_WITH_AES_256_CBC_SHA384</li>
                            <li>TLS_RSA_PSK_WITH_NULL_SHA256</li>
                            <li>TLS_RSA_PSK_WITH_NULL_SHA384</li>
                            <li>TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256</li>
                            <li>TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256</li>
                            <li>TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256</li>
                            <li>TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256</li>
                            <li>TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256</li>
                            <li>TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256</li>
                            <li>TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256</li>
                            <li>TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256</li>
                            <li>TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256</li>
                            <li>TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256</li>
                            <li>TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256</li>
                            <li>TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256</li>
                            <li>TLS_EMPTY_RENEGOTIATION_INFO_SCSV</li>
                            <li>TLS_ECDH_ECDSA_WITH_NULL_SHA</li>
                            <li>TLS_ECDH_ECDSA_WITH_RC4_128_SHA</li>
                            <li>TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA</li>
                            <li>TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA</li>
                            <li>TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA</li>
                            <li>TLS_ECDHE_ECDSA_WITH_NULL_SHA</li>
                            <li>TLS_ECDHE_ECDSA_WITH_RC4_128_SHA</li>
                            <li>TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA</li>
                            <li>TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA</li>
                            <li>TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA</li>
                            <li>TLS_ECDH_RSA_WITH_NULL_SHA</li>
                            <li>TLS_ECDH_RSA_WITH_RC4_128_SHA</li>
                            <li>TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA</li>
                            <li>TLS_ECDH_RSA_WITH_AES_128_CBC_SHA</li>
                            <li>TLS_ECDH_RSA_WITH_AES_256_CBC_SHA</li>
                            <li>TLS_ECDHE_RSA_WITH_NULL_SHA</li>
                            <li>TLS_ECDHE_RSA_WITH_RC4_128_SHA</li>
                            <li>TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA</li>
                            <li>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA</li>
                            <li>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA</li>
                            <li>TLS_ECDH_anon_WITH_NULL_SHA</li>
                            <li>TLS_ECDH_anon_WITH_RC4_128_SHA</li>
                            <li>TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA</li>
                            <li>TLS_ECDH_anon_WITH_AES_128_CBC_SHA</li>
                            <li>TLS_ECDH_anon_WITH_AES_256_CBC_SHA</li>
                            <li>TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA</li>
                            <li>TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA</li>
                            <li>TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA</li>
                            <li>TLS_SRP_SHA_WITH_AES_128_CBC_SHA</li>
                            <li>TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA</li>
                            <li>TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA</li>
                            <li>TLS_SRP_SHA_WITH_AES_256_CBC_SHA</li>
                            <li>TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA</li>
                            <li>TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA</li>
                            <li>TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256</li>
                            <li>TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384</li>
                            <li>TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256</li>
                            <li>TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384</li>
                            <li>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256</li>
                            <li>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384</li>
                            <li>TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256</li>
                            <li>TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384</li>
                            <li>TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256</li>
                            <li>TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384</li>
                            <li>TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256</li>
                            <li>TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384</li>
                            <li>TLS_ECDHE_PSK_WITH_RC4_128_SHA</li>
                            <li>TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA</li>
                            <li>TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA</li>
                            <li>TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA</li>
                            <li>TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256</li>
                            <li>TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384</li>
                            <li>TLS_ECDHE_PSK_WITH_NULL_SHA</li>
                            <li>TLS_ECDHE_PSK_WITH_NULL_SHA256</li>
                            <li>TLS_ECDHE_PSK_WITH_NULL_SHA384</li>
                            <li>TLS_RSA_WITH_ARIA_128_CBC_SHA256</li>
                            <li>TLS_RSA_WITH_ARIA_256_CBC_SHA384</li>
                            <li>TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256</li>
                            <li>TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384</li>
                            <li>TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256</li>
                            <li>TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384</li>
                            <li>TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256</li>
                            <li>TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384</li>
                            <li>TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256</li>
                            <li>TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384</li>
                            <li>TLS_DH_anon_WITH_ARIA_128_CBC_SHA256</li>
                            <li>TLS_DH_anon_WITH_ARIA_256_CBC_SHA384</li>
                            <li>TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256</li>
                            <li>TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384</li>
                            <li>TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256</li>
                            <li>TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384</li>
                            <li>TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256</li>
                            <li>TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384</li>
                            <li>TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256</li>
                            <li>TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384</li>
                            <li>TLS_RSA_WITH_ARIA_128_GCM_SHA256</li>
                            <li>TLS_RSA_WITH_ARIA_256_GCM_SHA384</li>
                            <li>TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256</li>
                            <li>TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384</li>
                            <li>TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256</li>
                            <li>TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384</li>
                            <li>TLS_DH_anon_WITH_ARIA_128_GCM_SHA256</li>
                            <li>TLS_DH_anon_WITH_ARIA_256_GCM_SHA384</li>
                            <li>TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256</li>
                            <li>TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384</li>
                            <li>TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256</li>
                            <li>TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384</li>
                            <li>TLS_PSK_WITH_ARIA_128_CBC_SHA256</li>
                            <li>TLS_PSK_WITH_ARIA_256_CBC_SHA384</li>
                            <li>TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256</li>
                            <li>TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384</li>
                            <li>TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256</li>
                            <li>TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384</li>
                            <li>TLS_PSK_WITH_ARIA_128_GCM_SHA256</li>
                            <li>TLS_PSK_WITH_ARIA_256_GCM_SHA384</li>
                            <li>TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256</li>
                            <li>TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384</li>
                            <li>TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256</li>
                            <li>TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384</li>
                            <li>TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256</li>
                            <li>TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384</li>
                            <li>TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256</li>
                            <li>TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384</li>
                            <li>TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256</li>
                            <li>TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384</li>
                            <li>TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256</li>
                            <li>TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384</li>
                            <li>TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256</li>
                            <li>TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384</li>
                            <li>TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256</li>
                            <li>TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384</li>
                            <li>TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256</li>
                            <li>TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384</li>
                            <li>TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256</li>
                            <li>TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384</li>
                            <li>TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256</li>
                            <li>TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384</li>
                            <li>TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256</li>
                            <li>TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384</li>
                            <li>TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256</li>
                            <li>TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384</li>
                            <li>TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256</li>
                            <li>TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384</li>
                            <li>TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256</li>
                            <li>TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384</li>
                            <li>TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256</li>
                            <li>TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384</li>
                            <li>TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256</li>
                            <li>TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384</li>
                            <li>TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256</li>
                            <li>TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384</li>
                            <li>TLS_RSA_WITH_AES_128_CCM</li>
                            <li>TLS_RSA_WITH_AES_256_CCM</li>
                            <li>TLS_RSA_WITH_AES_128_CCM_8</li>
                            <li>TLS_RSA_WITH_AES_256_CCM_8</li>
                            <li>TLS_PSK_WITH_AES_128_CCM</li>
                            <li>TLS_PSK_WITH_AES_256_CCM</li>
                            <li>TLS_PSK_WITH_AES_128_CCM_8</li>
                            <li>TLS_PSK_WITH_AES_256_CCM_8</li>
                        </ul>
                    </div>
                    <div id="rfc.section.A.p.3">
                        <aside>
                            <div id="rfc.section.A.p.3.1">
                                <p>注：この一覧は、<a href="#RFC7540"><cite
                                            title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>
                                    が作成された時点の登録済み TLS 暗号スイートの集合から作成されました。この一覧には、エフェメラルな鍵交換を提供しない暗号スイートや、
                                    TLS の null、ストリーム、またはブロック暗号タイプに基づく暗号スイート（<a
                                        href="https://www.rfc-editor.org/rfc/rfc5246.html#section-6.2.3">Section
                                        6.2.3</a>
                                    of <a href="#RFC5246"><cite
                                            title="The Transport Layer Security (TLS) Protocol Version 1.2">[TLS12]</cite></a>
                                    に定義）を含みます。
                                    これらの特性を持つ追加の暗号スイートが定義される可能性がありますが、それらは明示的に禁止されるものではありません。</p>
                            </div>
                        </aside>
                    </div>
                    <div id="rfc.section.A.p.4">
                        <p>詳細については、<a href="#tls12ciphers" title="TLS 1.2 Cipher Suites">Section 9.2.2</a> を参照してください。
                        </p>
                    </div>
                </section>
                <hr class="hidden-print">
                <section id="revision-updates">
                    <h2 id="rfc.section.B" class="np"><a href="#rfc.section.B">付録 B.</a>&nbsp;<a
                            href="#revision-updates">RFC 7540 からの変更点</a></h2>
                    <div id="rfc.section.B.p.1" class="avoidbreakafter">
                        <p>この改訂には、次の実質的な変更が含まれます：</p>
                    </div>
                    <div id="rfc.section.B.p.2">
                        <ul>
                            <li>TLS 1.3 の使用は <a href="#RFC8740"><cite
                                        title="Using TLS 1.3 with HTTP/2">[RFC8740]</cite></a>
                                に基づき定義されており、本書はそれを廃止します。</li>
                            <li>RFC 7540 で定義された優先度スキームは廃止予定です。PRIORITY フレームの形式および HEADERS
                                フレーム内の優先度フィールドの定義は保持され、PRIORITY
                                フレームの送受信が許される条件に関する規則も保持されますが、これらのフィールドの意味論は RFC 7540 にのみ記述されています。RFC 7540
                                の優先度シグナリングスキームは成功しませんでした。より単純なシグナリングである <a href="#RFC9218"><cite
                                        title="Extensible Prioritization Scheme for HTTP">[HTTP-PRIORITY]</cite></a>
                                の使用が推奨されます。</li>
                            <li>HTTP/1.1 の Upgrade 機構は廃止予定であり、本書ではもはや規定されません。これは広く配備されることはなく、プレーンテキストの HTTP/2 利用者は代わりに
                                prior-knowledge 実装を選択しました。</li>
                            <li>フィールド名と値の検証が狭められました。中継者に対して必須となる検証は正確に定義され、リクエストに対するエラー報告は 400
                                系のステータスコードを送ることを奨励するように修正されました。</li>
                            <li>実験的使用のために予約されていた設定値およびフレームタイプのコードポイントの範囲は、一般利用可能になりました。</li>
                            <li>禁止された接続固有のヘッダーフィールドは、より正確かつ包括的に特定されました。</li>
                            <li><span class="tt">Host</span> と "<span class="tt">:authority</span>" が異なることはもはや許可されません。
                            </li>
                            <li>settings の変更後に Dynamic Table Size Update 命令を送信するための規則は、<a href="#dynamic-table"
                                    title="Compression State">Section 4.3.1</a> で明確化されました。</li>
                        </ul>
                    </div>
                    <div id="rfc.section.B.p.3">
                        <p>編集上の変更も含まれます。特に用語と文書構成の変更は、<a href="#RFC9110"><cite title="HTTP Semantics">コア HTTP
                                    セマンティクス</cite></a>（<cite title="HTTP Semantics">[HTTP]</cite>）の更新への対応です。これらの文書には、RFC
                            7540 で最初に定義された概念（421 ステータスコードやコネクションの合流など）が含まれるようになりました。</p>
                    </div>
                </section>
                <hr class="hidden-print">
                <section id="n-acknowledgments">
                    <h2 id="rfc.section.unnumbered-4" class="np"><a href="#n-acknowledgments">謝辞</a></h2>
                    <div id="rfc.section.unnumbered-4.p.1">
                        <p>この文書への重要な入力に対するクレジットは、長年にわたり HTTP ワーキンググループに貢献した多数の人々に帰するものです。<a href="#RFC7540"><cite
                                    title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>
                            には、貢献に対して謝意を表すべきより包括的な人物一覧が含まれています。</p>
                    </div>
                </section>
                <hr class="hidden-print">
                <section id="n-contributors">
                    <h2 id="rfc.section.unnumbered-5" class="np"><a href="#n-contributors">貢献者</a></h2>
                    <div id="rfc.section.unnumbered-5.p.1">
                        <p>Mike Belshe と Roberto Peon が本書の元になった文章を作成しました。</p>
                    </div>
                </section>
                <hr class="hidden-print">
                <section id="rfc.authors" class="np">
                    <h2><a href="#rfc.authors">著者の連絡先</a></h2>
                    <address><b>Martin Thomson</b> (編集者)<br>Mozilla<br>Australia<br>EMail: <a
                            href="mailto:mt@lowentropy.net">mt@lowentropy.net</a></address>
                    <address><b>Cory Benfield</b> (編集者)<br>Apple Inc.<br>EMail: <a
                            href="mailto:cbenfield@apple.com">cbenfield@apple.com</a></address>
                </section>
            </div>
        </div>
    </div>
    <script src="https://httpwg.org/assets/node_modules/jquery/dist/jquery.min.js"></script>
    <script src="https://httpwg.org/assets/node_modules/bootstrap/dist/js/bootstrap.min.js"></script>
    <script src="https://htmlspecs.com/dropdown.js"></script>
</body>

</html>