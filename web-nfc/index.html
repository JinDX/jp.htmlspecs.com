<!DOCTYPE html>
<html>

<head>
    <title>Web NFC</title>
    <meta charset="UTF-8">
    <link rel="icon" type="image/png" href="https://w3c.github.io/web-nfc/images/webnfc-favicon-simple.png">
    <script type="module" src="https://w3c.github.io/web-nfc/ndef-record.js"></script>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
    <script class="remove">
        var respecConfig = {
            shortName: "web-nfc",
            group: "cg/web-nfc",
            specStatus: "CG-DRAFT",
            editors: [
                {
                    name: "Kenneth Rohde Christiansen",
                    company: "Intel",
                    companyURL: "https://intel.com/",
                },
                {
                    name: "François Beaufort",
                    company: "Google LLC",
                    companyURL: "https://google.com/"
                },
            ],
            formerEditors: [
                {
                    name: "Zoltan Kis",
                    company: "Intel",
                    companyURL: "https://intel.com/"
                },
                {
                    name: "Alexander Shalamov",
                    company: "Intel",
                    companyURL: "https://intel.com/",
                },
            ],
            logos: [
                {
                    src: 'images/webnfc-logo.svg',
                    url: "https://w3c.github.io/web-nfc/",
                    alt: "Web NFC logo",
                    width: 95,
                    height: 68,
                    id: 'webnfc-logo'
                }
            ],
            testSuiteURI: "https://wpt.fyi/web-nfc/",
            github: "w3c/web-nfc",
            xref: "web-platform",
            localBiblio: {
                "NFC-SECURITY": {
                    href: "https://w3c.github.io/web-nfc/archive/security-privacy.html",
                    title: "Web NFC Security and Privacy",
                    publisher: "W3C",
                    date: "25 April 2015",
                },
                "NFC-USECASES": {
                    href: "https://w3c.github.io/web-nfc/use-cases.html",
                    title: "Web NFC Use Cases",
                    publisher: "W3C",
                    date: "25 April 2015",
                },
                "NFC-STANDARDS": {
                    href: "http://members.nfc-forum.org/specs/spec_list/",
                    title: "NFC Forum Technical Specifications",
                    publisher: "NFC Forum",
                    date: "24 July 2006",
                },
                "NFC-NDEF": {
                    href: "http://members.nfc-forum.org/specs/spec_list/",
                    title: "NFC Data Exchange Format (NDEF) Technical Specification",
                    publisher: "NFC Forum",
                    date: "24 July 2006",
                },
                "NFC-RTD": {
                    href: "http://members.nfc-forum.org/specs/spec_list/",
                    title: "NFC Record Type Definition (RTD) Technical Specification",
                    publisher: "NFC Forum",
                    date: "24 July 2006",
                },
                "NDEF-TEXT": {
                    href: "http://members.nfc-forum.org/specs/spec_list/",
                    title: "NFC Forum Text Record Type Definition",
                    publisher: "NFC Forum",
                    date: "14 August 2013",
                },
                "NDEF-URI": {
                    href: "http://members.nfc-forum.org/specs/spec_list/",
                    title: "NFC Forum URI Record Type Definition",
                    publisher: "NFC Forum",
                    date: "24 July 2006",
                },
                "NDEF-SMARTPOSTER": {
                    href: "http://members.nfc-forum.org/specs/spec_list/",
                    title: "NFC Forum Smart Poster Record Type Definition",
                    publisher: "NFC Forum",
                    date: "24 July 2006",
                },
                "NDEF-SIGNATURE": {
                    href: "http://members.nfc-forum.org/specs/spec_list/",
                    title: "NFC Forum Signature Record Type Definition",
                    publisher: "NFC Forum",
                    date: "18 November 2010",
                },
                "NFC-HANDOVER": {
                    href: "http://members.nfc-forum.org/specs/spec_list/",
                    title: "NFC Forum Connection Handover Technical Specification",
                    publisher: "NFC Forum",
                    date: "16 January 2014",
                },
                "ISO-639.2": {
                    href: "https://www.loc.gov/standards/iso639-2/php/code_list.php",
                    title: "Codes for the Representation of Names of Languages",
                    publisher: "ISO",
                    date: "18 March 2014",
                },
            },
            lint: { "no-unused-dfns": false },
        };
    </script>
    <style>
        table.simple {
            border: 1px solid #000;
        }

        table.simple td {
            border-right: 1px solid #000;
        }

        img.illustration {
            width: 100%;
            height: auto
        }

        body {
            background-repeat: no-repeat !important;
        }
    </style>
</head>

<body data-cite="MIMESNIFF SECURE-CONTEXTS PERMISSIONS ENCODING">

    <!-- - - - - - - - - - - - - - - - Abstract - - - - - - - - - - - - - - - - -->
    <section id="abstract">
        <p>
            近距離無線通信（NFC）は、通常数センチ未満の近接距離で2台の
            デバイス間の無線通信を可能にします。
            NFCは国際標準（ISO/IEC 18092）で、13.56 MHzで動作する近接結合デバイスの
            簡易な無線相互接続のためのインターフェースとプロトコルを定義します。
        </p>
        <p>
            ハードウェア標準は [[[NFC-STANDARDS]]] に定義されています。
        </p>
        <p>
            本文書は、NFC技術に基づく特定のユースケースを可能にするAPIを定義します。
            本仕様の現在の範囲は <a>NDEF</a> です。
        </p>
        <p class="advisement">
            低レベルの I/O 操作（例：ISO-DEP、NFC-A/B、NFC-F）およびホストベースのカード
            エミュレーション（HCE）は、現在の範囲では<b>サポートされていません</b>。
        </p>
    </section>

    <!-- - - - - - - - - - - - Status of this document  - - - - - - - - - - - - -->
    <section id="sotd">
        <p>
            実装者は本仕様が不安定であると見なされていることに注意する必要があります。
            議論に参加していない実装者は、互換性のない方法で仕様が変更されることに
            気づくでしょう。最終的に候補勧告（Candidate Recommendation）段階に到達する前に
            本仕様を実装することに関心のあるベンダーは、GitHub上のリポジトリを購読し、
            議論に参加するべきです。
        </p>
    </section>

    <!-- - - - - - - - - - - - - - -  Conformance  - - - - - - - - - - - - - - - -->
    <section id="conformance">
        <p>
            本文書は、含まれるインターフェースを実装する単一製品に適用される適合基準を定義します：
            <dfn>UA</dfn>（ユーザーエージェント）。
        </p>
    </section>

    <!-- - - - - - - - - - - - - - -  Introduction  - - - - - - - - - - - - - - -->
    <section class="informative">
        <h2>導入</h2>
        <p>
            Web NFC のユーザーシナリオは次のとおりです：デバイスを受動的に給電される NFC タグ（プラスチックカードやステッカーなど）
            に近づけて、データを読み書きします。
        </p>
        <p>
            NFCは磁気誘導を利用して動作します。つまり、リーダー（能動的な給電デバイス）は小さな電荷を発生させ、それが磁場を生成します。
            この磁場が受動デバイスに電力を供給し、それを電気的インパルスに変換してデータを通信します。したがって、
            デバイスが範囲内にあるときは常に読み取りが行われます（NFC Analog Specification および NFC Digital Protocol, NFC Forum, 2006 を参照）。
            ピアツーピア接続も同様に機能し、デバイスが周期的にイニシエータモードに切り替わってターゲットをスキャンし、
            後にターゲットモードに戻ることで動作します。ターゲットが見つかると、データはタグの場合と同様に読み取られます。
        </p>
        <p>
            NFCは既存のRFID標準に基づいているため、多くのNFCチップセットはRFIDタグの読み取りをサポートしますが、
            これらのうちいくつかは単一ベンダーのみがサポートし、NFC標準の一部ではない場合があります。
            そのため、本ドキュメントではNFCデータ交換フォーマット（NDEF）とやり取りする方法を規定しています。
        </p>
    </section> <!-- Introduction -->

    <!-- - - - - - - - - - - - - - -  Terminology - - - - - - - - - - - - - - - -->
    <section>
        <h2>用語と慣習</h2>
        <p>
            使用される拡張バッカス・ノア形式（ABNF）表記は [[RFC5234]] に規定されています。
        </p>
        <p>
            <b>NFC</b> は Near Field Communications の略で、13.56 MHzで動作する短距離無線技術を指し、
            10 cm 未満の距離でデバイス間の通信を可能にします。NFCの通信プロトコルおよびデータ交換フォーマットは、
            ISO/IEC 14443 や FeliCa を含む既存の無線周波数識別（RFID）標準に基づいています。
            NFC標準には ISO/IEC 18092[5] や NFC Forum が定義するものが含まれます。完全な一覧は
            <a href="https://www.nfc-forum.org/specs/spec_list/">NFC Forum Technical Specifications</a> を参照してください。
        </p>
        <p>
            <dfn>NFC adapter</dfn> は、特定のハードウェア要素（NFCチップ）で実装された NFC 機能へのアクセスを提供する基盤プラットフォーム上のソフトウェア実体です。
            デバイスは組み込みのものやUSB経由で接続された複数の NFC アダプタを持つ場合があります。
        </p>
        <div>
            <dfn>NFC tag</dfn> は受動的なNFCデバイスで、<a>blocklisted</a>ではありません。
            <a>NFC tag</a> は能動的な NFC デバイスが近接しているときに磁気誘導で給電されます。<a>NDEF</a> をサポートする
            <a>NFC tag</a> は単一の <a>NDEF message</a> を含みます。
            <p class="note">
                メッセージの読み取り方法は、リーダーとタグが同一メーカーであることを要求する
                独自技術を通じて行われる場合があります。それらはまた <a>NDEF</a> メッセージを公開することがあります。
            </p>
        </div>
        <div>
            <dfn>NFC peer</dfn> は他のデバイスと相互作用して NFC を用いてデータを交換できる能動的な給電デバイスです。
            <p class="issue" data-number="529">
                現在の仕様では、ピアツーピアはサポートされていません。
            </p>
        </div>
        <p>
            <dfn>NFC device</dfn> は <a>NFC peer</a> または <a>NFC tag</a> のいずれかです。
        </p>
        <p>
            <dfn>NDEF</dfn> は NFC Forum Data Exchange Format の略で、[[!NFC-NDEF]] に標準化された
            軽量のバイナリメッセージ形式です。
        </p>
        <p>
            <dfn>NDEF message</dfn> は1つ以上のアプリケーション定義の <a>NDEF record</a> をカプセル化します。
            NDEF メッセージは <a>NFC tag</a> に保存されたり、NFC対応デバイス間で交換されたりします。
        </p>
        <p>
            用語 <dfn>NFC content</dfn> は <a>NFC tag</a> へ送信または受信される全てのバイトを指します。
            現在の API ではこれは <a>NDEF message</a> と同義です。
        </p>
    </section> <!-- Terminology -->


    <section class="informative">
        <h2>NFC 標準</h2>
        <p>
            NFC は NFC Forum により標準化されており、[[NFC-STANDARDS]] に記述されています。
        </p>
        <section class="informative">
            <h3>NDEF 互換のタグタイプ</h3>
            <p>
                NFC Forum は、NFC デバイスで操作可能にするために 5 種類の異なるタグタイプのサポートを義務付けています。
                同様の要件は Android のようなオペレーティングシステムにも求められます。
            </p>
            <p>
                それに加えて、<a>MIFARE Standard</a> は古い <a>MIFARE Standard</a> 上で NDEF を動作させる方法を規定しており、
                実装者によってはオプションでサポートされることがあります。
            </p>
            <p>
                NDEF マッピングに関する注記は次にあります：
                <a href="https://www.nxp.com/docs/en/application-note/AN1305.pdf">MIFARE Classic as NFC Type MIFARE
                    Classic Tag</a>.
            </p>
            <div>
                <ol>
                    <li>
                        <dfn>NFC Forum Type 1</dfn>: このタグは ISO/IEC 14443-3A (NFC-A) に基づきます。タグは書き換え可能で
                        読み取り専用に設定することができます。メモリサイズは `96` バイトから `2` Kbytes の間です。
                        通信速度は `106` kbit/s です。他の全てのタイプとは対照的に、これらのタグは
                        NFC フィールド内の複数タグを扱うためのアンチコリジョン保護を持ちません。
                    </li>
                    <li>
                        <dfn>NFC Forum Type 2</dfn>: このタグは ISO/IEC 14443-3A (NFC-A) に基づきます。タグは書き換え可能で
                        読み取り専用に設定することができます。メモリサイズは `48` バイトから `2` Kbytes の間です。
                        通信速度は `106` kbit/s です。
                    </li>
                    <li>
                        <dfn>NFC Forum Type 3</dfn>: このタグは日本工業規格（JIS）X 6319-4（ISO/IEC 18092）に基づき、
                        一般に FeliCa として知られています。タグは書き換え可能または読み取り専用のいずれかに事前設定されています。
                        メモリは `2` kbytes です。通信速度は `212` kbit/s または `424` kbit/s です。
                    </li>
                    <li>
                        <dfn>NFC Forum Type 4</dfn>: このタグは ISO/IEC 14443-4 A/B (NFC A, NFC B) に基づき、
                        通信に対して NFC-A または NFC-B のいずれかをサポートします。さらにタグはオプションで ISO-DEP
                        （ISO/IEC 14443（ISO/IEC 14443-4:2008 第4部：伝送プロトコル）で定義されたデータ交換プロトコル）をサポートする場合があります。
                        タグは書き換え可能または読み取り専用に事前設定されています。可変メモリで最大 `32` kbytes。
                        通信速度は `106`、`212`、または `424` kbit/s のいずれかをサポートします。
                    </li>
                    <li>
                        <dfn>NFC Forum Type 5</dfn>: このタグは ISO/IEC 15693 (NFC-V) に基づき、ISO/IEC 15693 の RF タグ上で
                        NDEF メッセージの読み書きを可能にします。これらのタグは長距離 RFID リーダーからもアクセス可能です。
                        NFC 通信は短距離に制限され、送信側ピアがフィールドを生成する ISO/IEC 18092 の <i>アクティブ通信モード</i> を
                        使用する場合があります。これにより電力消費のバランスがとれ、リンクの安定性が向上します。可変メモリで最大 `64` kbytes。
                        通信速度は `26.48` kbit/s です。
                    </li>
                    <li>
                        <dfn>MIFARE Standard</dfn>: このタグは、しばしば MIFARE Classic や MIFARE Mini のブランド名で販売され、
                        ISO/IEC 14443-3A（NFC-Aとしても知られる、ISO/IEC 14443-3:2011 第3部：初期化とアンチコリジョンに定義）に基づきます。
                        タグは書き換え可能で読み取り専用に設定できます。メモリサイズは `320` から `4` kbytes の間です。
                        通信速度は `106` kbit/s です。
                        <p class="note">
                            <a>MIFARE Standard</a> は NFC Forum のタイプではなく、NXP ハードウェアを使用するデバイスのみが読み取り可能です。
                            <a>MIFARE Standard</a> に基づくタグの読み書きのサポートは非標準的ですが、普及とレガシーシステムでの使用のために
                            タイプに含まれています。
                        </p>
                    </li>
                </ol>
            </div>
            <p>
                NFC Forum によって <a>NDEF record</a> 用に標準化されたデータタイプに加えて、バスカードやドアオープナーのような多くの商用製品は
                <a>MIFARE Standard</a> に基づいており、動作のために特定の NFC チップ（カードとリーダーが同じベンダーであること）を要求する場合があります。
            </p>
        </section>

        <section>
            <h3>
                NDEF レコードとフィールド
            </h3>
            <p>
                <dfn>NDEF record</dfn> は <a>NDEF message</a> の一部です。各レコードはデータペイロードと関連する
                型情報を含むバイナリ構造です。加えて、ペイロードサイズやデータが複数レコードに分割されているか等の
                データ構造に関する情報も含みます。
            </p>
            <div>
                一般的なレコードは次のようになります：
                <ndef-record class="ndef" header="*,*,*,*,*,*"
                    content="*,PAYLOAD LENGTH - 1 (SR) to 4 bytes,ID LENGTH (optional),TYPE (optional),ID (optional),PAYLOAD (optional)">
                </ndef-record>
            </div>
            <p>
                最初の3バイト（図の行）が必須です。最初にヘッダバイト、その後に <a>TYPE LENGTH field</a> と <a>PAYLOAD
                    LENGTH field</a> が続き、どちらもゼロである場合があります。
            </p>
            <div>
                <dfn>TNF field</dfn>（ビット `0-2`、type name format）は型名の形式を示し、ネイティブな NFC ソフトウェアスタックで露出されることが多いです。
                このフィールドは以下の NDEF レコードペイロードタイプを表す二進値を取り得ます：
                <table class="simple">
                    <tr>
                        <th><strong>TNF value</strong></th>
                        <th><strong>説明</strong></th>
                    </tr>
                    <tr>
                        <td>0</td>
                        <td><a>Empty record</a></td>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>NFC Forum [=well-known type record=]</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td><a>MIME type record</a></td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td><a>Absolute-URL record</a></td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>NFC Forum <a>external type record</a></td>
                    </tr>
                    <tr>
                        <td>5</td>
                        <td><a>Unknown record</a></td>
                    </tr>
                    <tr>
                        <td>6</td>
                        <td><a>Unchanged record</a></td>
                    </tr>
                    <tr>
                        <td>7</td>
                        <td>将来の使用のために予約</td>
                    </tr>
                </table>
            </div>
            <p>
                <dfn>IL field</dfn>（ビット `3`、id length）は <a>ID LENGTH field</a> が存在するかを示します。
                <a>IL field</a> が `0` の場合、<a>ID field</a> は存在しません。
            </p>
            <p>
                <dfn>SR field</dfn>（ビット `4`、short record）は短いレコードを示し、
                ペイロード長が `255` バイト以下のものです。通常のレコードは `255` バイトを超え得て、
                最大で `4` GB まで可能です。短レコードは長さを示すのに1バイトのみを使用しますが、
                通常のレコードは長さを示すのに4バイトを使用します（`2`<sup>`32`</sup>`-1` バイト）。
            </p>
            <p>
                <dfn>CF field</dfn>（ビット `5`、chunk flag）はペイロードが複数レコードにわたって
                <a>chunked</a> されているかを示します。
            </p>
            <p class="note">
                Web NFC は受信したチャンク化されたレコードをすべて論理レコードに変換し、
                送信時に必要であれば透過的にペイロードをチャンク化します。
            </p>
            <p>
                <dfn>ME field</dfn>（ビット `6`、message end）はこのレコードが
                <a>NDEF message</a> の最後であるかを示します。
            </p>
            <p>
                <dfn>MB field</dfn>（ビット `7`、message begin）はこのレコードが
                <a>NDEF message</a> の最初であるかを示します。
            </p>
            <p>
                <dfn>TYPE LENGTH field</dfn> は <a>TYPE field</a> のバイト長を表す符号なし8ビット整数です。
            </p>
            <p>
                <dfn>TYPE field</dfn> は <a>PAYLOAD field</a> の構造、エンコーディング、および形式を記述する
                グローバルに一意で管理された識別子であり、<a>TNF field</a> の値によって決定されます。
            </p>
            <p class="note">
                [[[!NFC-RTD]]] は <a>TYPE field</a> の名前を大文字小文字を区別せずに比較することを要求しています。
            </p>
            <p>
                <dfn>ID LENGTH field</dfn> は <a>ID field</a> のバイト長を表す符号なし8ビット整数です。
            </p>
            <p>
                <dfn>ID field</dfn> は URI 参照（[[RFC3986]]）の形式の識別子で、一意であり絶対または相対にすることができます
                （後者の場合、アプリケーションはベースURIを提供しなければなりません）。中間および終端のチャンクレコードは
                <a>ID field</a> を持つべきではなく、他のレコードは持つことができます。
            </p>
            <p>
                <dfn>PAYLOAD LENGTH field</dfn> は <a>PAYLOAD field</a> のバイト長を示します。
                <a>SR field</a> が `1` の場合、そのサイズは1バイトで、そうでなければ4バイトであり、
                それぞれ8ビットまたは32ビットの符号なし整数を表します。
            </p>
            <p>
                <dfn>PAYLOAD field</dfn> はアプリケーションのバイトを運びます。データの内部構造は NDEF にとって不透明です。
                後述の特定のケースでは、このフィールドがデータとして <a>NDEF message</a> を含む場合があります。
            </p>
        </section>

        <section>
            <h3>
                NDEF レコードの種類
            </h3>
            <section>
                <h4>空の NDEF レコード（TNF 0）</h4>
                <p>
                    <dfn>empty record</dfn> の <a>TYPE LENGTH field</a>、
                    <a>ID LENGTH field</a>、および <a>PAYLOAD LENGTH field</a> は `0` でなければならず、
                    したがって <a>TYPE field</a>、<a>ID field</a>、および <a>PAYLOAD field</a> は存在してはなりません。
                </p>
                <ndef-record header="1,1,0,1,0,0 (EMPTY)" content="0,0,_,_,_,_" short>
                </ndef-record>
            </section>

            <section>
                <h4>
                    Well-known type records（TNF 1）
                </h4>
                <p>
                    NFC Forum は [[NFC-RTD]]（Resource Type Definition 仕様）で、テキスト、URL、メディア等の
                    有用なサブレコードタイプの小さなセットを標準化しています。これらを <dfn>well-known type record</dfn> と呼びます。
                    さらに、スマートポスター（オプションで埋め込まれた URL、テキスト、署名、アクション用のレコードを含む）やハンドオーバーレコードのような
                    より複雑な相互作用のために設計されたレコードタイプもあります。
                </p>
                <p>
                    <a>well-known type records</a> の <a>TYPE field</a> に格納される型情報は二種類あります：
                    <a href="#well-known-local-types">ローカル型</a> と <a href="#well-known-global-types">グローバル型</a>。
                </p>

                <section>
                    <h4>Well-known ローカル型</h4>
                    <p>
                        NFC Forum の <dfn>local type</dfn> は NFC Forum またはアプリケーションによって定義され、
                        常に小文字の文字または数字で始まります。これらは通常、包含するレコードのローカルコンテキスト内でのみ一意な短い文字列です。
                        型の意味が包含するレコードのローカルコンテキストの外で重要でない場合や、ストレージ使用量が厳しい制約である場合に使用されます。
                        <a>Smart poster</a> はローカル型の使用例です。
                    </p>
                    <p class="note">
                        [=local type=] は包含レコードの型で定義されるため、ネームスペースを必要としません。
                        このため同じローカル型名が別のレコード型内で異なる意味や異なるペイロード型で使用されることがあります。
                    </p>
                </section>
            </section> <!-- Well-known (TNF 1) types -->

            <section>
                <h4>Well-known グローバル型</h4>
                <p>
                    NFC Forum の <dfn>global type</dfn> は NFC Forum によって定義・管理され、通常は大文字で始まります。
                    例：テキストのための "`T`"、URL のための "`U`"、スマートポスターの "`Sp`"、
                    署名の "`Sig`"、ハンドオーバーキャリアの "`Hc`"、ハンドオーバー要求の "`Hr`"、ハンドオーバー選択の "`Hs`" など。
                </p>

                <section>
                    <h5>テキストレコード</h5>
                    <div>
                        <dfn>Text record</dfn> は [[NDEF-TEXT]] で定義された [=well-known type record=] です。
                        <a>TNF field</a> は `1` で、<a>TYPE field</a> は "`T`"（`0x54`）です。
                        <a>PAYLOAD field</a> の最初のバイトはステータスバイトで、その次に US-ASCII エンコーディングの [=language tag=] が続きます。
                        残りのペイロードは実際のテキストで、ステータスバイトに従って UTF-8 または UTF-16 のいずれかでエンコードされます：
                        <ul>
                            <li>ビット0から5は [=language tag=] の長さを定義します。</li>
                            <li>ビット6は `0` です。</li>
                            <li>
                                ビット7が `0` の場合、ペイロードは UTF-8 でエンコードされ、ビット7が `1` の場合は UTF-16 でエンコードされます。
                            </li>
                        </ul>
                    </div>
                </section>

                <section>
                    <h5>URI レコード</h5>
                    <p>
                        <dfn>URI record</dfn> は [[NDEF-URI]] で定義されています。
                        <a>TNF field</a> は `1`、<a>TYPE field</a> は "`U`"（`0x55`）です。
                        <a>PAYLOAD field</a> の最初のバイトは URI 識別子コードで、略語表のインデックスになっており、
                        その値が残りのURIの前に付加されます。例えば値 `0` は何も付加しないことを示し、
                        `1` は "`http://www.`"、`0x04` は "`https://`" を表します。
                        残りのペイロードは UTF-8 文字列としての URI の残りを含みます（最初のバイトが `0` の場合は全体の URI を表します）。
                    </p>
                    <p>
                        URI は [[RFC3987]] で定義されており、実際には UTF-8 エンコードされた IRI で、URN や URL になり得ます。
                    </p>
                </section>

                <section>
                    <h5>スマートポスター（Smart poster）レコード</h5>
                    <div>
                        <dfn>Smart poster</dfn> は [[NDEF-SMARTPOSTER]] に定義されており、
                        ペイロードとして <a>NDEF message</a> を含む NDEF レコードとして指定の Web コンテンツを記述します。以下のレコードを含むことがあります：
                        <ul>
                            <li>
                                単一の必須 <a>URI record</a> が <a>smart poster</a> コンテンツを指します。
                                <p class="note">
                                    [[NDEF-SMARTPOSTER]] は、アプリケーションが <a>NDEF message</a> 内に存在する場合、
                                    他の <a>URI record</a> が同時に含まれていても、<a>smart poster</a> レコードのみを使用することを
                                    規定しています。
                                </p>
                            </li>
                            <li>
                                0 個以上の <a>Text records</a> がコンテンツに関連する <dfn>title record</dfn> として機能します。
                                複数のタイトルレコードが存在する場合、それらは異なる <a>language tags</a> でなければなりません。
                                アプリケーションはエンドユーザーに提示するために1つの <a>title record</a> を選択するべきです。
                            </li>
                            <li>
                                0 個以上の <a>MIME type records</a> がコンテンツに関連する <dfn>icon record</dfn> として機能します。
                                <a>MIME type</a> は通常 "`image/jpg`"、"`image/png`"、"`image/gif`"、あるいは "`video/mpeg`" などです。
                                アプリケーションはエンドユーザーに提示するために1つの <a>icon record</a> を選択するべきです。
                            </li>
                            <li>
                                1 つのオプションの <dfn>type record</dfn> があり、<a>smart poster</a> 固有の [=local type name=] "`t`"
                                を持ち、
                                <a>PAYLOAD field</a> は <a>URI record</a> が参照するコンテンツの MIME タイプ（UTF-8 エンコード）を含みます。
                            </li>
                            <li>
                                1 つのオプションの <dfn>size record</dfn> があり、<a>smart poster</a> 固有の [=local type name=] "`s`"
                                を持ち、
                                <a>PAYLOAD field</a> は URI レコードで参照されるオブジェクトのサイズを示す 4 バイトの 32 ビット符号なし整数を含みます。
                            </li>
                            <li>
                                1 つのオプションの <dfn>action record</dfn> があり、<a>smart poster</a> 固有の [=local type name=]
                                "`act`" を持ち、
                                <a>PAYLOAD field</a> は単一バイトを含み、その値は次の意味を持ちます：
                                <table class="simple">
                                    <tr>
                                        <th><strong>値</strong></th>
                                        <th><strong>説明</strong></th>
                                    </tr>
                                    <tr>
                                        <td>0</td>
                                        <td>アクションを実行する</td>
                                    </tr>
                                    <tr>
                                        <td>1</td>
                                        <td>後で保存する</td>
                                    </tr>
                                    <tr>
                                        <td>2</td>
                                        <td>編集のために開く</td>
                                    </tr>
                                    <tr>
                                        <td>3..0xFF</td>
                                        <td>将来の使用のために予約</td>
                                    </tr>
                                </table>
                                <p>
                                    <a>action record</a> が欠落している場合、<a>smart poster</a> コンテンツに対するデフォルトのアクションはありません。
                                </p>
                                <p class="note">
                                    NDEF 標準化時点では、値 `0`（"do the action"）は SMS 送信、通話、ブラウザ起動のようなユースケース向けを想定していました。
                                    同様に、値 `1`（"save the content for later processing"）は SMS を受信トレイに保存、URL をブックマークに保存、
                                    電話番号を連絡先に保存する等のユースケースを想定していました。値 `2`（"open for editing"）は
                                    スマートポスターコンテンツを編集のためにデフォルトアプリで開くことを意図していました。
                                </p>
                                <p>
                                    実装はここで定義されたアクションに対して標準化された挙動を実装する必要はありません。
                                    この API ではどのアクションをアプリケーションが定義するかはアプリ次第です（上記のユースケースを含め得ます）。
                                    Web NFC は値を提供するだけです。
                                </p>
                            </li>
                            <li>
                                <a>smart poster</a> は他のレコードを含む場合があり、これらはアプリケーション固有の方法で処理できます。
                            </li>
                        </ul>
                    </div>

                    <div>
                        以下の例は、テキストと URL レコードを埋め込んだスマートポスターのレコードを示します。
                        <ndef-record header="1,1,0,1,0,1 (WELL KNOWN)" content="*,*,_,'Sp' (0x53 0x70),_,*" short>
                            <ndef-record slot="payload" header="1,0,0,1,0,1 (WELL KNOWN)"
                                content="TYPE LENGTH (1 byte),*,_,'T' (0x54),_,*" short noindices>
                            </ndef-record>
                            <ndef-record slot="payload" header="0,1,0,1,0,1 (WELL KNOWN)"
                                content="TYPE LENGTH (1 byte),*,_,'U' (0x55),_,*" short noindices>
                            </ndef-record>
                        </ndef-record>
                    </div>
                </section>

                <section>
                    <h5>署名レコード</h5>
                    <p>
                        <dfn>NDEF Signature</dfn> は [[NDEF-SIGNATURE]] で定義されています。
                        その <a>TYPE field</a> は "`Sig`"（`0x53`, `0x69`, `0x67`）を含み、
                        <a>PAYLOAD field</a> はバージョン、署名、証明書チェーンを含みます。
                    </p>
                    <p class="issue" data-number="363">
                        現在の仕様では、これはサポートされていません。
                    </p>
                </section>

                <section>
                    <h5>ハンドオーバーレコード</h5>
                    <p>
                        <dfn>NFC handover</dfn> は [[NFC-HANDOVER]] で定義されており、
                        Bluetooth や WiFi のような代替通信キャリアのネゴシエーションと有効化を可能にする対応するメッセージ構造です。
                        ネゴシエートされた通信キャリアは、その後（別途）両デバイス間で写真送信、Bluetooth プリンタへの印刷、
                        テレビへのビデオストリーミングなどの特定のアクティビティを行うために使用されます。
                    </p>
                    <p class="issue" data-number="364">
                        現在の仕様では、これはサポートされていません。
                    </p>
                </section>
            </section> <!-- well-known global types -->

            <section>
                <h4>
                    MIME type records（TNF 2）
                </h4>
                <div>
                    <dfn>MIME type record</dfn> は関連付けられた <a>MIME type</a> を持つバイナリデータを格納するレコードです。
                    <ndef-record header="*,*,*,*,*,2 (MIME)" content="*,*,*,SERIALIZED MIME TYPE,*,MIME TYPE PAYLOAD"
                        short>
                    </ndef-record>
                </div>
            </section>

            <section>
                <h4>
                    Absolute-URL records（TNF 3）
                </h4>
                <p>
                    <dfn>absolute-URL record</dfn> では <a>TYPE field</a> が
                    <a>absolute-URL string</a> を含み、ペイロードではありません。
                </p>
                <p class=note>
                    注：Windows Phone のような一部プラットフォームはペイロードに追加データを格納していましたが、
                    これらのレコードの任意のペイロードデータは Android のような他のプラットフォームによって無視されます。
                    Android でそのようなレコードを読み取ると、Chrome で URL を読み込もうとし、クライアントアプリケーション向けには
                    意図されていません。
                </p>
                <div>
                    <ndef-record header="*,*,*,*,*,3 (ABSOLUTE URL)"
                        content="*,*,*,ABSOLUTE URL STRING,*,PAYLOAD (optional/ignored)" short>
                    </ndef-record>
                </div>
            </section>

            <section>
                <h4>
                    External type records（TNF 4）
                </h4>
                <p>
                    NFC Forum の <dfn data-no-export="">external type record</dfn> は
                    アプリケーション指定のデータタイプ用で、[[[NFC-RTD]]] に定義されています。
                </p>
                <p>
                    <dfn>external type</dfn> はプレフィックス `"urn:nfc:ext:"` に続けて所有者の [=domain=] 名、
                    その後に `U+003A`（`:`）を追加し、ゼロ以外のタイプ名を続ける URN です。例えば `"urn:nfc:ext:w3.org:atype"` は
                    <a>TYPE field</a> に `"w3.org:atype"` として格納されます。
                </p>
                <div>
                    <ndef-record header="*,*,*,*,*,4 (EXTERNAL)" content="*,*,*,EXTERNAL TYPE (eg. w3.org:member),*,*"
                        short>
                    </ndef-record>
                </div>
            </section>

            <section>
                <h4>
                    Unknown type records（TNF 5）
                </h4>
                <p>
                    <dfn>unknown record</dfn> は関連付けられた <a>MIME type</a> を持たない不透明なデータを格納するレコードであり、
                    `application/octet-stream` のデフォルト <a>MIME type</a> が想定され得ます。
                    [[NFC-NDEF]] 仕様は、<a>NDEF</a> パーサーがペイロードを処理せずに保存または転送することを推奨しています。
                </p>
                <div>
                    <ndef-record header="*,*,*,*,*,5 (UNKNOWN)" content="0,*,*,_,*,*" short>
                    </ndef-record>
                </div>
            </section>
            <section>
                <h4>
                    Unchanged type records（TNF 6）
                </h4>
                <div>
                    <dfn>unchanged record</dfn> はチャンク化されたデータセットのレコードチャンクであり、最初のレコードを除く任意のレコードに使用されます。
                    <dfn>chunked</dfn> ペイロードは複数の <a>NDEF record</a> に分散され、次のルールに従います：
                    <ul>
                        <li>
                            最初のチャンクレコードは <a>CF field</a> が設定され、全体のチャンク化ペイロードの型を示す <a>TYPE field</a> が設定され、
                            全体のチャンク化ペイロードで使用される識別子を示す <a>ID field</a> を持つことがあります。その <a>PAYLOAD LENGTH field</a> は
                            このレコード内のペイロードチャンクのサイズを示します。
                        </li>
                        <li>
                            中間チャンクレコードは <a>CF field</a> が設定され、最初のチャンクと同じ <a>ID field</a> を持ち、
                            <a>TYPE LENGTH field</a> と <a>IL field</a> は `0` でなければならず、<a>TNF field</a> は
                            `6`（unchanged）でなければなりません。
                        </li>
                        <li>
                            終端チャンクレコードはこのフラグがクリアされ、他は中間チャンクレコードと同じルールに従います。
                        </li>
                        <li>
                            チャンク化されたペイロードは単一の <a>NDEF message</a> に含まれなければならないため、
                            最初および中間のチャンクレコードは <a>ME field</a> を設定できません。
                        </li>
                    </ul>
                </div>
                <div>
                    最初のレコード：
                    <ndef-record header="1,0,1,1,0,*" content="0,PAYLOAD LENGTH FOR THIS RECORD,_,_,_,*" short>
                    </ndef-record>
                    <br>
                    中間レコード：
                    <ndef-record header="0,0,1,1,0,6 (UNCHANGED)" content="0,PAYLOAD LENGTH FOR THIS RECORD,_,_,_,*"
                        short>
                    </ndef-record>
                    <br>
                    最終レコード：
                    <ndef-record header="0,1,0,1,0,6 (UNCHANGED)" content="0,PAYLOAD LENGTH FOR THIS RECORD,_,_,_,*"
                        short>
                    </ndef-record>
                </div>
                <p>
                    Web NFC の任意の実装は、チャンク化されたレコードを単一の論理レコードとして透過的に公開しなければなりません。
                </p>
            </section>
        </section>
    </section> <!-- NFC Standard -->

    <section class="informative">
        <h3>ユースケース</h3>
        <p>
            いくつかの NFC ユーザーシナリオは
            <a
                href="http://www.w3.org/2009/dap/wiki/Near_field_communications_%28NFC%29#Use_cases_submitted_to_DAP_mailing_list">
                こちら</a> および
            <a href="https://w3c.github.io/web-nfc/use-cases.html">Web NFC Use Cases</a>
            ドキュメントに列挙されています。基本的な Web NFC の相互作用は以下の通りです。
        </p>

        <section>
            <h3><a>NFC tag</a> の読み取り</h3>
            <p>
                Web NFC を使用している <a>top-level browsing context</a> の {{Document}} が
                可視状態のときに、<a>NDEF message</a> を含む <a>NFC tag</a> を読み取ります。
                例えば、ウェブページがユーザーに NFC タグをタップするよう指示し、その後タグから情報を受け取る場合です。
            </p>
        </section>

        <section>
            <h3><a>NFC tag</a> への書き込み</h3>
            <div>
                ユーザーが <a>NFC tag</a> に書き込み可能なウェブページを開きます。書き込み操作には次のいずれかが含まれます：
                <ol>
                    <li>
                        フォーマットされていない <a>NFC tag</a> への書き込み。
                    </li>
                    <li>
                        フォーマット済みだが空の <a>NFC tag</a> への書き込み。
                    </li>
                    <li>
                        既に <a>NDEF message</a> を含む <a>NFC tag</a> への書き込み。
                    </li>
                    <li>
                        その他の書き込み可能な <a>NFC tag</a>（例：汎用タグの上書き）への書き込み。
                    </li>
                </ol>
            </div>
            <p class="note">
                注：<a>NFC tag</a> への書き込み操作は常に読み取り操作も伴う点に注意してください。
            </p>
        </section>

        <section>
            <h3><a>NFC tag</a> を読み取り専用にする</h3>
            <div>
                ユーザーが <a>NFC tag</a> を恒久的に読み取り専用にできるウェブページを開きます。操作には次のいずれかが含まれます：
                <ol>
                    <li>
                        フォーマットされていない <a>NFC tag</a> を恒久的に読み取り専用にする。
                    </li>
                    <li>
                        フォーマット済みだが空の <a>NFC tag</a> を恒久的に読み取り専用にする。
                    </li>
                    <li>
                        既に <a>NDEF message</a> を含む <a>NFC tag</a> を恒久的に読み取り専用にする。
                    </li>
                </ol>
            </div>
            <p class="note">
                注：<a>NFC tag</a> を恒久的に読み取り専用にする操作は常に読み取り操作を伴います。
            </p>
        </section>

        <section>
            <h3>複数の <a>NFC adapter</a> のサポート</h3>
            <p>
                ユーザーは内蔵アダプタに加えて、1 台以上の外部 <a>NFC adapter</a> をデバイスに接続する場合があります。ユーザーは任意の
                <a>NFC adapter</a> を使用できます。
            </p>
        </section>
    </section> <!-- Use Cases -->

    <section class="informative">
        <h3>機能</h3>
        <div>
            Web NFC 仕様のハイレベルな機能は次のとおりです：
            <ol>
                <li>
                    単一または複数の <a>NFC adapter</a> を持つデバイスをサポートする。
                    NFC 関数を呼び出した時点で複数のアダプタが存在する場合、UA は全ての <a>NFC adapter</a> を並列に動作させます。
                </li>
                <li>
                    受動的（スマートカード、タグなど）な NFC デバイスとの通信をサポートする。
                </li>
                <li>
                    ユーザーが発見した受動的 NFC デバイスに対して（例：読み取り、書き込み、トランシーブ）操作を行えるようにし、
                    その過程で読み取られたペイロードに <a>NDEF message</a> としてアクセスできるようにする。
                </li>
                <li>
                    書き込み可能なタグのような互換デバイスが範囲内に入ったときに、<a>NDEF record</a> を介してペイロードを
                    <a>NDEF message</a> として書き込めるようにする。
                </li>
            </ol>
        </div>
    </section> <!-- Features -->

    <!-- - - - - - - - - - - - - - Usage Examples - - - - - - - - - - - - - - -->
    <section class="informative">
        <h2>例</h2>
        <p>
            本セクションでは、開発者が本仕様のさまざまな機能をどのように利用できるかを示します。
        </p>

        <section>
            <h3>機能サポート</h3>
            <p>
                Web NFC がサポートされているかどうかの検出は {{NDEFReader}} オブジェクトをチェックすることで行えます。
                ただし、これは NFC ハードウェアが利用可能であることを保証するものではありません。
            </p>
            <pre class="example">
      if ("NDEFReader" in window) { /* Scan and write NDEF Tags */ }
    </pre>
        </section>

        <section>
            <h3>データ書き込みに関する一般情報</h3>
            <p>
                データの書き込みは概して簡単ですが、NFC での書き込みの仕組みに関していくつか注意点があります。
            </p>
            <p>
                NFC リーダーはポーリングで動作するため、タグに書き込んだり恒久的に読み取り専用にするには、
                まずタグが見つかって読み取られる必要があり、つまりポーリングを初期化する必要があります。
            </p>
            <p>
                既に `scan()` を呼んでポーリングが開始されていない場合、`write()` と `makeReadOnly()` メソッドは
                タグが見つかって読み取られ、操作が試行されるまで一時的にポーリングを開始します。
            </p>
            <p>
                つまり、フローは最初にタグが見つかったときに読み取りが行われ、その後に書き込み操作が続くということです。
            </p>
            <p>
                これにより、`scan()` が実行中で `reading` イベントのイベントリスナがある場合、
                `write()` や `makeReadOnly()` の操作中にそのイベントが一度発火する可能性があり、
                意図した挙動でない場合があります。
            </p>
            <p>
                以下のセクションではこの挙動に対処する方法を説明しますが、まずは簡単な例をいくつか示します。
            </p>
        </section>

        <section>
            <h3>テキスト文字列を書き込む</h3>
            <p>
                テキスト文字列を NFC タグに書き込むのは簡単です。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();
      ndef.write(
        "Hello World"
      ).then(() => {
        console.log("Message written.");
      }).catch(error => {
        console.log(`Write failed :-( try again: ${error}.`);
      });
    </pre>
        </section>

        <section>
            <h3>URL を書き込む</h3>
            <p>
                URL タイプの NDEF レコードを書き込むには、NDEFMessage を使用します。ここでは async/await を利用します。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();
      try {
        await ndef.write({
          records: [{ recordType: "url", data: "https://w3c.github.io/web-nfc/" }]
        });
      } catch {
        console.log("Write failed :-( try again.");
      };
    </pre>
        </section>

        <section>
            <h3>書き込み中の初期読み取りの扱い</h3>
            <p>
                書き込むにはタグが見つかって読み取られる必要があります。これにより、既存データやシリアル番号を確認して
                実際に書き込みたいタグかどうかを判断することができます。
            </p>
            <p>
                このため、`write()` は `reading` イベント内から呼び出すことが推奨されます。`makeReadOnly()` についても同様です。
            </p>
            <p>
                以下の例は共通の `reading` ハンドラと単独の書き込みのために特化したハンドラを調整する方法を示しています。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();
      let ignoreRead = false;

      ndef.onreading = (event) => {
        if (ignoreRead) {
          return; // write pending, ignore read.
        }

        console.log("We read a tag, but not during pending write!");
      };

      function write(data) {
        ignoreRead = true;
        return new Promise((resolve, reject) => {
          ndef.addEventListener("reading", event => {
            // Check if we want to write to this tag, or reject.
            ndef.write(data).then(resolve, reject).finally(() => ignoreRead = false);
          }, { once: true });
        });
      }

      await ndef.scan();
      try {
        await write("Hello World");
        console.log("We wrote to a tag!")
      } catch(err) {
        console.error("Something went wrong", err);
      }
    </pre>
        </section>

        <section>
            <h3>タイムアウト付きで書き込みをスケジュールする</h3>
            <p>
                書き込み操作に時間制限を設けることが有用な場合があります。例えばユーザーにタグをタッチするよう促し、
                一定時間内にタグが見つからなければタイムアウトする、という場合です。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();
      ndef.onreading = (event) => console.log("We read a tag!");

      function write(data, { timeout } = {}) {
        return new Promise((resolve, reject) => {
          const ctlr = new AbortController();
          ctlr.signal.onabort = () => reject("Time is up, bailing out!");
          setTimeout(() => ctlr.abort(), timeout);

          ndef.addEventListener("reading", event => {
            ndef.write(data, { signal: ctlr.signal }).then(resolve, reject);
          }, { once: true });
        });
      }

      await ndef.scan();
      try {
        // Let's wait for 5 seconds only.
        await write("Hello World", { timeout: 5_000 });
      } catch(err) {
        console.error("Something went wrong", err);
      } finally {
        console.log("We wrote to a tag!");
      }
    </pre>
        </section>

        <section>
            <h3>スキャンエラーの処理</h3>
            <p>
                この例は {{NDEFReader/scan}} のプロミスが拒否された場合や `readingerror` が発火した場合に何が起きるかを示します。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();
      ndef.scan().then(() => {
        console.log("Scan started successfully.");
        ndef.onreadingerror = (event) => {
          console.log("Error! Cannot read data from the NFC tag. Try a different one?");
        };
        ndef.onreading = (event) => {
          console.log("NDEF message read.");
        };
      }).catch(error => {
        console.log(`Error! Scan failed to start: ${error}.`);
      });
    </pre>
        </section>

        <section>
            <h3>単一タグを一度だけ読み取る</h3>
            <p>
                この例は単一のタグを読み取ってポーリングを停止する便利関数を簡単に作る方法を示し、
                不要な作業を減らしてバッテリ寿命を節約します。
            </p>
            <p>
                この例は指定ミリ秒後にタイムアウトするよう簡単に拡張できます。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();

      function read() {
        return new Promise((resolve, reject) => {
          const ctlr = new AbortController();
          ctlr.signal.onabort = reject;
          ndef.addEventListener("reading", event => {
            ctlr.abort();
            resolve(event);
          }, { once: true });
          ndef.scan({ signal: ctlr.signal }).catch(err => reject(err));
        });
      }

      read().then(({ serialNumber }) => {
        console.log(serialNumber);
      });
    </pre>
        </section>

        <section>
            <h3>タグからデータを読み、空のタグに書き込む</h3>
            <p>
                この例はタグ上に保存できるさまざまな種類のデータを読み取る方法を示します。タグが未フォーマットまたは空のレコードを含む場合、
                値 "Hello World" のテキストメッセージを書き込みます。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();
      await ndef.scan();
      ndef.onreading = async ({ message }) => {
        if (message.records.length == 0 ||               // unformatted tag
            message.records[0].recordType == "empty") {  // empty record
          await ndef.write({
            records: [{ recordType: "text", data: "Hello World" }]
          });
          return;
        }

        const decoder = new TextDecoder();
        for (const record of message.records) {
          switch (record.recordType) {
            case "text":
              const textDecoder = new TextDecoder(record.encoding);
              console.log(`Text: ${textDecoder.decode(record.data)} (${record.lang})`);
              break;
            case "url":
              console.log(`URL: ${decoder.decode(record.data)}`);
              break;
            case "mime":
              if (record.mediaType === "application/json") {
                console.log(`JSON: ${JSON.parse(decoder.decode(record.data))}`);
              }
              else if (record.mediaType.startsWith("image/")) {
                const blob = new Blob([record.data], { type: record.mediaType });

                const img = document.createElement("img");
                img.src = URL.createObjectURL(blob);
                img.onload = () => window.URL.revokeObjectURL(this.src);

                document.body.appendChild(img);
              }
              else {
                console.log(`Media not handled`);
              }
              break;
            default:
              console.log(`Record not handled`);
          }
        }
      };
    </pre>
        </section>

        <section>
            <h3>NFC タグでゲーム進捗を保存・復元する</h3>
            <p>
                関連するデータソースのフィルタリングはカスタムレコード識別子（この場合 "`/my-game-progress`"）を使用して行えます。
                データを読み取ると直ちにカスタム NDEF データレイアウトで書き込みを行いゲーム進捗を更新します。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();
      await ndef.scan();
      ndef.onreading = async ({ message }) => {
        if (message.records[0]?.id !== "/my-game-progress")
          return;
        console.log(`Game state: ${ JSON.stringify(message.records) }`);

        const encoder = new TextEncoder();
        const newMessage = {
          records: [{
            id: "/my-game-progress",
            recordType: "mime",
            mediaType: "application/json",
            data: encoder.encode(JSON.stringify({
              level: 3,
              points: 4500,
              lives: 3
            }))
          }]
        };
        await ndef.write(newMessage);
        console.log("Message written");
      };
    </pre>
        </section>

        <section>
            <h3>JSON を書き込み・読み取り（直列化・逆直列化）</h3>
            <p>
                JSON データの保存と受信は、直列化と逆直列化で簡単に行えます。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();
      await ndef.scan();
      ndef.onreading = (event) => {
        const decoder = new TextDecoder();
        for (const record of event.message.records) {
          if (record.mediaType === "application/json") {
            const json = JSON.parse(decoder.decode(record.data));
            const article =/^[aeio]/i.test(json.title) ? "an" : "a";
            console.log(`${json.name} is ${article} ${json.title}`);
          }
        }
      };

      const encoder = new TextEncoder();
      await ndef.write({
        records: [
          {
            recordType: "mime",
            mediaType: "application/json",
            data: encoder.encode(JSON.stringify({
              name: "Benny Jensen",
              title: "Banker"
            }))
          },
          {
            recordType: "mime",
            mediaType: "application/json",
            data: encoder.encode(JSON.stringify({
              name: "Zoey Braun",
              title: "Engineer"
            }))
          }]
      });
    </pre>
        </section>

        <section>
            <h3>データを書き込み既存データを出力する</h3>
            <p>
                データの書き込みには <a>NFC tag</a> をタップする必要があります。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();
      await ndef.scan();
      ndef.onreading = async (event) => {
        const decoder = new TextDecoder();
        for (const record of event.message.records) {
          console.log("Record type:  " + record.recordType);
          console.log("MIME type:    " + record.mediaType);
          console.log("=== data ===\n" + decoder.decode(record.data));
        }

        try {
          await ndef.write("Overriding data is fun!");
        } catch(error) {
          console.log(`Write failed :-( try again: ${error}.`);
        }
      };
    </pre>
        </section>

        <section>
            <h3>NDEF メッセージのリスニングを停止する</h3>
            <p>
                {{NDEFScanOptions/signal}} を使用して 3 秒間 NDEF メッセージを読み取ります。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();
      const ctrl = new AbortController();

      await ndef.scan({ signal: ctrl.signal });
      ndef.onreading = () => {
        console.log("NDEF message read.");
      };

      ctrl.signal.onabort = () => {
        console.log("We're done waiting for NDEF messages.");
      };

      // Stop listening to NDEF messages after 3s.
      setTimeout(() => ctrl.abort(), 3_000);
    </pre>
        </section>

        <section>
            <h3>スマートポスターメッセージを書き込む</h3>
            <pre class="example">
      const ndef = new NDEFReader();
      const encoder = new TextEncoder();
      await ndef.write({ records: [
        {
          recordType: "smart-poster",  // Sp
          data: { records: [
            {
              recordType: "url",  // URL record for the Sp content
              data: "https://my.org/content/19911"
            },
            {
              recordType: "text",  // title record for the Sp content
              data: "Funny dance"
            },
            {
              recordType: ":t",  // type record, a local type to Sp
              data: encoder.encode("image/gif") // MIME type of the Sp content
            },
            {
              recordType: ":s",  // size record, a local type to Sp
              data: new Uint32Array([4096]) // byte size of Sp content
            },
            {
              recordType: ":act",  // action record, a local type to Sp
              // do the action, in this case open in the browser
              data: new Uint8Array([0])
            },
            {
              recordType: "mime", // icon record, a MIME type record
              mediaType: "image/png",
              data: await (await fetch("icon1.png")).arrayBuffer()
            },
            {
              recordType: "mime", // another icon record
              mediaType: "image/jpg",
              data: await (await fetch("icon2.jpg")).arrayBuffer()
            }
          ]}
        }
      ]});
    </pre>
        </section>

        <section>
            <h3>NDEF メッセージをペイロードに含む外部レコードを読み取る</h3>
            <p>
                外部タイプレコードはアプリケーション定義のレコードを作成するために使用できます。
                これらのレコードはペイロードとして <a>NDEF message</a> を含むことがあり、
                アプリケーションのコンテキストで使用される <a>local types</a> を含む独自の <a>NDEF records</a> を持ちます。
            </p>
            <p>
                <a>smart poster</a> レコードタイプもペイロードとして <a>NDEF message</a> を含む点に注意してください。
            </p>
            <p>
                NDEF はレコードの順序を保証しないため、関連データをカプセル化する目的で
                <a>NDEF message</a> をペイロードに持つ外部タイプレコードを使うことは有用です。
            </p>
            <p>
                次の例は、テキストレコードと <a>local type</a> "act"（アクション）を含む <a>NDEF message</a> を
                ペイロードとして持つソーシャル投稿向けの外部レコードを読み取る方法を示しています。
                "act" の定義は <a>smart poster</a> から借用されていますが、ローカルアプリケーションの文脈で使用されます。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();
      await ndef.scan();
      ndef.onreading = (event) => {
        const externalRecord = event.message.records.find(
          record => record.type == "example.com:smart-poster"
        );

        let action, text;

        for (const record of externalRecord.toRecords()) {
          if (record.recordType == "text") {
            const decoder = new TextDecoder(record.encoding);
            text = decoder.decode(record.data);
          } else if (record.recordType == ":act") {
            action = record.data.getUint8(0);
          }
        }

        switch (action) {
          case 0: // do the action
            console.log(`Post "${text}" to timeline`);
            break;
          case 1: // save for later
            console.log(`Save "${text}" as a draft`);
            break;
          case 2: // open for editing
            console.log(`Show editable post with "${text}"`);
            break;
        }
      };
    </pre>
        </section>

        <section>
            <h3>NDEF メッセージをペイロードに含む外部レコードを書き込む</h3>
            <p>
                外部タイプレコードは、ペイロードとして <a>NDEF message</a> を含むようなアプリケーション定義レコードを作成するために使用できます。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();
      await ndef.write({ records: [
        {
          recordType: "example.game:a",
          data: {
            records: [
              {
                recordType: "url",
                data: "https://example.game/42"
              },
              {
                recordType: "text",
                data: "Game context given here"
              },
              {
                recordType: "mime",
                mediaType: "image/png",
                data: getImageBytes(fromURL)
              }
            ]
          }
        }
      ]});
    </pre>
        </section>

        <section>
            <h3>外部レコード内の不明レコードを読み書きする</h3>
            <p>
                不明タイプレコードは開発者がその意味を知っている場合、外部タイプレコード内で有用であり、
                そのため MIME タイプを指定する必要を避けられます。
            </p>
            <pre class="example">
      const encoder = new TextEncoder();
      const ndef = new NDEFReader();
      await ndef.write({ records: [
        {
          recordType: "example.com:shoppingItem", // External record
          data: {
            records: [
              {
                recordType: "unknown", // Shopping item name
                data: encoder.encode("Food")
              },
              {
                recordType: "unknown", // Shopping item description
                data: encoder.encode("Provide nutritional support for an organism.")
              }
            ]
          }
        }
      ]});
    </pre>
            <pre class="example">
      const ndef = new NDEFReader();
      await ndef.scan();
      ndef.onreading = (event) => {
        const shoppingItemRecord = event.message.records[0];
        if (shoppingItemRecord?.recordType !== "example.com:shoppingItem")
          return;

        const [nameRecord, descriptionRecord] = shoppingItemRecord.toRecords();

        const decoder = new TextDecoder();
        console.log("Item name: " + decoder.decode(nameRecord.data));
        console.log("Item description: " + decoder.decode(descriptionRecord.data));
      };
    </pre>
        </section>

        <section>
            <h3>NFC タグを恒久的に読み取り専用にする</h3>
            <p>
                NFC タグを恒久的に読み取り専用にすることは簡単です。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();
      ndef.makeReadOnly().then(() => {
        console.log("NFC tag has been made permanently read-only.");
      }).catch(error => {
        console.log(`Operation failed: ${error}`);
      });
    </pre>
            <pre class="example">
      const ndef = new NDEFReader();
      try {
        await ndef.write("Hello world");
        console.log("Message written.");
        await ndef.makeReadOnly();
        console.log("NFC tag has been made permanently read-only after writing to it.");
      } catch (error) {
        console.log(`Operation failed: ${error}`);
      }
    </pre>
        </section>
    </section> <!-- Usage examples -->

    <!-- - - - - - - - - - - - - Data representation - - - - - - - - - - - - - -->
    <section>
        <h2>データ表現</h2>
        <section>
            <h3>The <dfn>NDEFMessage</dfn> interface</h3>
            <p>
                任意の <a>NDEF message</a> の内容は
                <a>NDEFMessage</a> インターフェイスによって公開されます：
            </p>
            <pre class="idl">
      [SecureContext, Exposed=Window]
      interface NDEFMessage {
        constructor(NDEFMessageInit messageInit);
        readonly attribute FrozenArray&lt;NDEFRecord&gt; records;
      };

      dictionary NDEFMessageInit {
        required sequence&lt;NDEFRecordInit&gt; records;
      };
    </pre>
            <p>
                <dfn data-dfn-for="NDEFMessage">records</dfn>
                プロパティは <a>list</a> の <a>NDEF record</a> を表し、
                <a>NDEF message</a> を定義します。
            </p>
            <p data-dfn-for="NDEFMessageInit">
                <dfn>NDEFMessageInit</dfn> 辞書は <a>NDEF message</a> を初期化するために使用されます。
            </p>
        </section>

        <section data-dfn-for="NDEFRecord">
            <h3>The <dfn>NDEFRecord</dfn> interface</h3>
            <p>
                任意の <a>NDEF record</a> の内容は
                <a>NDEFRecord</a> インターフェイスによって公開されます：
            </p>
            <pre class="idl">
      [SecureContext, Exposed=Window]
      interface NDEFRecord {
        constructor(NDEFRecordInit recordInit);

        readonly attribute USVString recordType;
        readonly attribute USVString? mediaType;
        readonly attribute USVString? id;
        readonly attribute DataView? data;

        readonly attribute USVString? encoding;
        readonly attribute USVString? lang;

        sequence&lt;NDEFRecord&gt;? toRecords();
      };

      dictionary NDEFRecordInit {
        required USVString recordType;
        USVString mediaType;
        USVString id;

        USVString encoding;
        USVString lang;

        any data; // DOMString or BufferSource or NDEFMessageInit
      };
    </pre>
            <p>
                <dfn>mediaType</dfn> プロパティは <a>MIME type</a> を表し、
                <a>NDEF record</a> のペイロードの MIME タイプを示します。
            </p>
            <p>
                <dfn>recordType</dfn> プロパティは <a>NDEF record</a> の種類を表します。
            </p>
            <div>
                <dfn>id</dfn> プロパティは <dfn>record identifier</dfn> を表し、
                これは絶対または相対の URL です。識別子の一意性は本仕様ではなく生成者によって保証されます。
                <p class=note>
                    NFC NDEF 仕様では <a>record identifier</a> の代わりに "message identifier" と "payload identifier" の用語が使われますが、
                    識別子はメッセージ（レコードの集合）ではなく各レコードに紐付いており、ペイロードが存在しない場合でも含まれる可能性があります。
                </p>
            </div>
            <p>
                <dfn>encoding</dfn> 属性は、ペイロードがテキストデータである場合に使用される
                エンコーディング名（encoding name）を表します。
            </p>
            <p>
                <dfn>lang</dfn> 属性は、エンコードされた場合のペイロードの言語タグ（language tag）を表します。
            </p>
            <p>
                <dfn>language tag</dfn> は [[BCP47]] 仕様で定義された <code>Language-Tag</code> の生成規則に一致する <a>string</a> です
                （可能な値の正式な一覧は <a href="https://www.iana.org/assignments/language-subtag-registry">IANA Language Subtag
                    Registry</a> を参照してください）。
                言語範囲は U+002D ハイフンマイナス ("-") で区切られた 1 つ以上の <dfn>subtags</dfn> で構成されます。
                例えば '<code>en-AU</code>' はオーストラリアで話される英語を表し、'<code>fr-CA</code>' はカナダで話されるフランス語を表します。
                [[RFC5646]] セクション2.2.9 の有効性基準を満たし、IANA レジストリへの参照なしに検証可能な言語タグは構造的に有効と見なされます。
            </p>
            <p>
                <dfn>data</dfn> プロパティは <a>PAYLOAD field</a> のデータを表します。
            </p>
            <p>
                <dfn>toRecords()</dfn> メソッドは呼び出されたとき、<a>NDEF Record</a> に対して
                <a>convert NDEFRecord.data bytes</a> を実行した結果を返さなければなりません。
            </p>
            <p data-dfn-for="NDEFRecordInit">
                <dfn>NDEFRecordInit</dfn> 辞書は、<a>record type</a> である <dfn>recordType</dfn> と、
                任意の <a>record identifier</a> <dfn>id</dfn> およびペイロードデータ <dfn>data</dfn> で
                <a>NDEF record</a> を初期化するために使用されます。
            </p>
            <div data-dfn-for="NDEFRecordInit">
                さらに、特定の <a>record types</a> にのみ適用される追加のオプションフィールドがあります：
                <ul>
                    <li data-dfn-for="NDEFRecordInit">
                        "<a>mime</a>": オプションの <a>MIME type</a> <dfn>mediaType</dfn>。
                    </li>
                    <li data-dfn-for="NDEFRecordInit">
                        "<a>text</a>": オプションのエンコーディングラベル <dfn>encoding</dfn> と言語タグ <dfn>lang</dfn>。
                    </li>
                </ul>
            </div>
            <p>
                <a>NDEFRecordInit</a> のデータ型から <a>NDEF record</a> 型へのマッピングは、
                アルゴリズム的な手順で示されており、[[[#steps-receiving]]] および [[[#writing-content]]] セクションで説明されています。
            </p>
            <p>
                <dfn>convert NDEFRecord.data bytes</dfn> を実行するには、
                |record:NDEFRecord| が与えられたとき、次の手順を実行してください：
            </p>
            <ol class=algorithm data-link-for="NDEFRecord">
                <li>
                    |bytes:byte sequence| を record の <a>data</a> 属性の値とします。
                </li>
                <li>
                    |recordType:record type| を |record| の <a>recordType</a> 属性の値とします。
                </li>
                <li>
                    |recordType| が "`smart-poster`" の場合、|bytes| と `"smart-poster"` を与えて
                    <a>parse records from bytes</a> を実行した結果を返します。
                </li>
                <li>
                    |recordType| に対して <a>validate external type</a> を実行して true が返る場合、|bytes| と `"external"` を与えて
                    <a>parse records from bytes</a> を実行した結果を返します。
                </li>
                <li>
                    それ以外の場合、{ "NotSupportedError" } を [= exception/throw =] します。
                </li>
            </ol>
        </section> <!-- NDEFRecord dictionary -->

        <section>
            <h2>The <dfn>record type</dfn> string</h2>
            <p>
                この文字列は <a>NDEFRecord</a> に許可される record types を定義します。
                [[[#data-mapping]]] セクションはそれが <a>NDEF record</a> 型にどのようにマッピングされるかを説明します。
            </p>
            <p>
                標準化された <dfn>well known type name</dfn> は次のいずれかです：
            </p>
            <dl>
                <dt>The "<dfn>empty</dfn>" string</dt>
                <dd>
                    <a href="#empty-ndef-record-tnf-0">empty</a> な <a>NDEFRecord</a> を表す値。
                </dd>
                <dt>The "<dfn>text</dfn>" string</dt>
                <dd>
                    Text record を表す値。
                </dd>
                <dt>The "<dfn>url</dfn>" string</dt>
                <dd>
                    URI record を表す値。
                </dd>
                <dt>The "<dfn>smart-poster</dfn>" string</dt>
                <dd>
                    Smart poster レコードを表す値。
                </dd>
                <dt>The "<dfn>absolute-url</dfn>" string</dt>
                <dd>
                    absolute-URL record を表す値。
                </dd>
                <dt>The "<dfn>mime</dfn>" string</dt>
                <dd>
                    MIME type record を表す値。
                </dd>
                <dt>The "<dfn>unknown</dfn>" string</dt>
                <dd>
                    unknown record を表す値。
                </dd>
            </dl>
            <p>
                [=well known type names=] に加えて、組織がカスタムの <dfn>external type name</dfn> を作成することも可能です。
                これはドメイン名とカスタムタイプ名をコロン `U+003A` (`:`) で区切った文字列です。
            </p>
            <p>
                アプリケーションは <dfn>local type name</dfn> を使用することもできます。これは小文字または数字で始まらなければならない文字列で、
                NFC Forum の [=local type=] を表します。通常、親レコードのペイロードである <a>NDEFMessage</a> のレコード内で使用されます（例：smart poster）。
                <a>local type</a> のコンテキストは、このレコードが属する <a>NDEFMessage</a> のペイロードである親レコードであり、
                <a>local type name</a> はそのコンテキストで他の型名と競合しないようにするべきです。
            </p>
            <p>
                Web NFC の任意の実装はチャンク化されたレコードを単一の論理レコードとして透過的に公開しなければならないため、
                <a>unchanged record</a> は明示的に表現されません。
            </p>
            <p>
                2 つの <a>well-known type records</a>（NFC Forum の <a>local type</a> および <a>global type</a> を含む）は、
                文字ごとに大文字小文字を区別して比較しなければなりません。
            </p>
            <p>
                2 つの external types は文字ごとに小文字・大文字を区別せずに比較しなければなりません。
            </p>
            <p>
                任意の <a>well-known type record</a> と <a>external type</a> のバイナリ表現は相対 URI（RFC 3986）として書かれなければならず、
                それぞれ名前空間識別子 (NID) "`nfc`" と名前空間固有文字列 (NSS) "`wkt`" および "`ext`" を省略します。つまり、
                "`urn:nfc:wkt:`" および "`urn:nfc:ext:`" プレフィックスを省略します。
                例えば "`urn:nfc:ext:company.com:a`" は "`company.com:a`" として格納され、
                Text record の <a>well-known type records</a> は "`urn:nfc:wkt:T`" ですが、"`T`" として格納されます。
            </p>

        </section>

        <section id="data-mapping">
            <h3>データマッピング</h3>
            <p>
                [[[#writing-content]]] セクションで使用されるように、<a>NDEFRecordInit</a> のデータ型から
                <a>NDEF record</a> 型へのマッピングは次の通りです：
            </p>
            <table class="simple" data-link-for="NDEFRecordInit">
                <tr>
                    <th>{{recordType}}</th>
                    <th>{{mediaType}}</th>
                    <th>{{data}}</th>
                    <th nowrap><a href="#ndef-record-types">record type</a></th>
                    <th nowrap>[=TNF field=]</th>
                    <th nowrap>[=TYPE field=]</th>
                </tr>
                <tr>
                    <td><dfn>"`empty`"</dfn></td>
                    <td><i>unused</i></td>
                    <td><i>unused</i></td>
                    <td><a>Empty record</a></td>
                    <td>0</td>
                    <td><i>unused</i></td>
                </tr>
                <tr>
                    <td><dfn>"`text`"</dfn></td>
                    <td><i>unused</i></td>
                    <td>
                        {{BufferSource}} or<br>
                        {{DOMString}}
                    </td>
                    <td>[=Well-known type record=]</td>
                    <td>1</td>
                    <td>"`T`"</td>
                </tr>
                <tr>
                    <td><dfn>"`url`"</dfn></td>
                    <td><i>unused</i></td>
                    <td>{{DOMString}}</td>
                    <td>[=Well-known type record=]</td>
                    <td>1</td>
                    <td>"`U`"</td>
                </tr>
                <tr>
                    <td nowrap><dfn>"`smart-poster`"</dfn></td>
                    <td><i>unused</i></td>
                    <td>{{NDEFMessageInit}}</td>
                    <td>[=Well-known type record=]</td>
                    <td>1</td>
                    <td>"`Sp`"</td>
                </tr>
                <tr>
                    <td>[=local type name=] prefixed by a colon `U+003A` (`:`), e.g., "`:act`", "`:s`", and "`:t`"</td>
                    <td><i>unused</i></td>
                    <td>
                        {{BufferSource}} or {{NDEFMessageInit}}
                    </td>
                    <td>[=Local type=] record*</td>
                    <td>1</td>
                    <td>[=local type name=], e.g., "`act`", "`s`", and "`t`"</td>
                </tr>
                <tr>
                    <td><dfn>"`mime`"</dfn></td>
                    <td>[= MIME type =]</a></td>
                    <td>{{BufferSource}}</td>
                    <td><a>MIME type record</a></td>
                    <td>2</td>
                    <td>[= MIME type =]</td>
                </tr>
                <tr>
                    <td nowrap><dfn>"`absolute-url`"</dfn></td>
                    <td><i>unused</i></td>
                    <td>{{DOMString}} <i>url</i></td>
                    <td><a>Absolute-URL record</a></td>
                    <td>3</td>
                    <td>[=Absolute-URL=]</td>
                </tr>
                <tr>
                    <td><i>[=external type name=]</i></td>
                    <td><i>unused</i></td>
                    <td>
                        {{BufferSource}} or<br>
                        {{NDEFMessageInit}}
                    </td>
                    <td><a>External type record</a></td>
                    <td>4</td>
                    <td>[=external type name=]</td>
                </tr>
                <tr>
                    <td><dfn>"`unknown`"</dfn></td>
                    <td><i>unused</i></td>
                    <td>{{BufferSource}}</td>
                    <td>[=Unknown record=]</td>
                    <td>5</td>
                    <td><i>unused</i></td>
                </tr>
            </table>
            <p>
                * [=local type=] レコードは別のレコードの <a>NDEFMessage</a> ペイロード内に埋め込まれている必要があります。
            </p>
            <p>
                受信した <a>NDEF message</a> に対して使用されるように、<a>NDEF record</a> 型から <a>NDEFRecord</a> へのマッピングは次の通りです。
            </p>
            <table class="simple" data-link-for="NDEFRecord">
                <tr>
                    <th><a href="#ndef-record-types">record type</a></th>
                    <th nowrap>[=TNF field=]<br></th>
                    <th nowrap>[=TYPE field=]</th>
                    <th>{{recordType}}</th>
                    <th>{{mediaType}}</th>
                </tr>
                <tr>
                    <td>[=Empty record=]</td>
                    <td>0</td>
                    <td><i>unused</i></td>
                    <td>"`empty`"</td>
                    <td>null</td>
                </tr>
                <tr>
                    <td>[=Well-known type record=]</td>
                    <td>1</td>
                    <td>"`T`"</td>
                    <td>"`text`"</td>
                    <td>null</td>
                </tr>
                <tr>
                    <td>[=Well-known type record=]</td>
                    <td>1</td>
                    <td>"`U`"</td>
                    <td>"`url`"</td>
                    <td>null</td>
                </tr>
                <tr>
                    <td>[=Well-known type record=]</td>
                    <td>1</td>
                    <td>"`Sp`"</td>
                    <td nowrap>"`smart-poster`"</td>
                    <td>null</td>
                </tr>
                <tr>
                    <td>[=Local type=] record*</td>
                    <td>1</td>
                    <td>[=local type name=], e.g., "`act`", "`s`", and "`t`"</td>
                    <td>[=local type name=] prefixed by a colon `U+003A` (`:`), e.g., "`:act`", "`:s`", and "`:t`"</td>
                    <td>null</td>
                </tr>
                <tr>
                    <td>[=MIME type record=]</td>
                    <td>2</td>
                    <td>[=MIME type=]</td>
                    <td>"`mime`"</td>
                    <td>The <a>MIME type</a> used in the NDEF record</td>
                </tr>
                <tr>
                    <td>[=Absolute-URL record=]</td>
                    <td>3</td>
                    <td>URL</td>
                    <td>"`absolute-url`"</td>
                    <td>null</td>
                </tr>
                <tr>
                    <td>[=External type record=]</a></td>
                    <td>4</td>
                    <td>[=external type name=]</td>
                    <td>[=external type name=]</td>
                    <td>null</td>
                </tr>
                <tr>
                    <td><a>Unknown record</a></td>
                    <td>5</td>
                    <td><i>unused</i></td>
                    <td>"`unknown`"</td>
                    <td>null</td>
                </tr>
            </table>
        </section>
    </section> <!-- Data types and content -->


    <section data-dfn-for="NDEFReader" data-link-for="NDEFReader">
        <h2>NDEFReader オブジェクト</h2>
        <p>
            <dfn>NDEFReader</dfn> は、タグなどのデバイスが磁気誘導フィールド内にあるときに
            <a>browsing context</a> に NFC 機能を公開し、<a>NDEF messages</a> を読み取ります。
            また、到達範囲内の <a>NFC tag</a> に <a>NDEF messages</a> を書き込むためにも使用されます。
        </p>
        <pre class="idl">
    typedef (DOMString or BufferSource or NDEFMessageInit) NDEFMessageSource;

    [SecureContext, Exposed=Window]
    interface NDEFReader : EventTarget {
      constructor();

      attribute EventHandler onreading;
      attribute EventHandler onreadingerror;

      Promise&lt;undefined&gt; scan(optional NDEFScanOptions options={});
      Promise&lt;undefined&gt; write(NDEFMessageSource message,
                                     optional NDEFWriteOptions options={});
      Promise&lt;undefined&gt; makeReadOnly(optional NDEFMakeReadOnlyOptions options={});
    };

    [SecureContext, Exposed=Window]
    interface NDEFReadingEvent : Event {
      constructor(DOMString type, NDEFReadingEventInit readingEventInitDict);

      readonly attribute DOMString serialNumber;
      [SameObject] readonly attribute NDEFMessage message;
    };

    dictionary NDEFReadingEventInit : EventInit {
      DOMString? serialNumber = "";
      required NDEFMessageInit message;
    };
  </pre>
        <p>
            <dfn>NDEFMessageSource</dfn> は {{NDEFReader/write()}} メソッドが受け付ける引数型を表すユニオン型です。
        </p>
        <p data-dfn-for="NDEFReadingEvent">
            <dfn>NDEFReadingEvent</dfn> は新しい NFC 読み取り時にディスパッチされるイベントです。
            <dfn>serialNumber</dfn> プロパティは衝突回避と識別に用いられるデバイスのシリアル番号を表し、
            利用できない場合は空文字列です。<dfn>message</dfn> は <a>NDEFMessage</a> オブジェクトです。
        </p>
        <p data-dfn-for="NDEFReadingEventInit">
            <dfn>NDEFReadingEventInit</dfn> は、シリアル番号と <dfn>message</dfn> メンバー経由の
            <a>NDEFMessageInit</a> データで新規イベントを初期化するために使用されます。
            <dfn>serialNumber</dfn> が存在しない、または null の場合、空文字列でイベントを初期化します。
        </p>
        <p class="note">
            ほとんどのタグには安定した一意識別子（UID）がありますが、すべてではなく、読み取りのたびに
            ランダムな番号を生成するタグもあります。シリアル番号は通常、`:` で区切られた 4 または 7 個の数値で構成されます。
        </p>
        <p>
            {{NDEFReader}} オブジェクトは次の <a data-cite="ECMASCRIPT#sec-object-internal-methods-and-internal-slots">
                内部スロット</a>を持ちます:
        </p>
        <table class="simple">
            <thead>
                <tr>
                    <th>Internal Slot</th>
                    <th>Initial value</th>
                    <th>Description (<em>non-normative</em>)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><dfn>[[\WriteOptions]]</dfn></td>
                    <td>null</td>
                    <td>
                        書き込み用の {{NDEFWriteOptions}} 値。
                    </td>
                </tr>
                <tr>
                    <td><dfn>[[\WriteMessage]]</dfn></td>
                    <td>null</td>
                    <td>
                        書き込まれる {{NDEFMessage}}。
                        初期状態では未設定です。
                    </td>
                </tr>
            </tbody>
        </table>

        <p>
            <dfn data-dfn-for="NDEFReader">onreading</dfn> は新しい読み取りが利用可能であることを通知するために呼び出される {{EventHandler}} です。
        </p>
        <p>
            <dfn data-dfn-for="NDEFReader">onreadingerror</dfn> は読み取り中にエラーが発生したことを通知するために呼び出される {{EventHandler}} です。
        </p>
        <section>
            <h3>設定オブジェクトに関連付けられた NFC 状態</h3>
            <p>
                NFC をサポートする <a>browsing context</a> の <a>active document</a> の
                <a>relevant settings object</a> には、次の <a
                    data-cite="ECMASCRIPT#sec-object-internal-methods-and-internal-slots">内部スロット</a>を持つ
                <dfn>NFC state</dfn> レコードが関連付けられています:
            </p>
            <table class="simple">
                <thead>
                    <tr>
                        <th>Internal Slot</th>
                        <th>Initial value</th>
                        <th>Description (<em>non-normative</em>)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><dfn>[[\Suspended]]</dfn></td>
                        <td>false</td>
                        <td>
                            NFC 機能が <a href="#nfc-suspended">suspended</a> かどうかを示すブール値フラグ。初期値は false。
                        </td>
                    </tr>
                    <tr>
                        <td><dfn>[[\ActivatedReaderList]]</dfn></td>
                        <td>empty <a>set</a></td>
                        <td>
                            {{NDEFReader}} インスタンスの <a>set</a>。
                        </td>
                    </tr>
                    <tr>
                        <td><dfn>[[\PendingWrite]]</dfn></td>
                        <td>empty</td>
                        <td>
                            |promise:Promise| と |writer:NDEFReader| のタプル。|promise| は保留中の {{Promise}} を、
                            |writer| は {{NDEFReader}} を保持します。
                        </td>
                    </tr>
                    <tr>
                        <td><dfn>[[\PendingMakeReadOnly]]</dfn></td>
                        <td>empty</td>
                        <td>
                            |promise:Promise| と |writer:NDEFReader| のタプル。|promise| は保留中の {{Promise}} を、
                            |writer| は {{NDEFReader}} を保持します。
                        </td>
                    </tr>
                </tbody>
            </table>
            <p>
                <dfn>activated reader objects</dfn> は <a>[[\ActivatedReaderList]]</a> 内部スロットの値です。
            </p>
            <p>
                <dfn>pending write tuple</dfn> は <a>[[\PendingWrite]]</a> 内部スロットの値です。
            </p>
            <p>
                <dfn>pending makeReadOnly tuple</dfn> は <a>[[\PendingMakeReadOnly]]</a> 内部スロットの値です。
            </p>
            <p>
                <dfn id="nfc-is-suspended">NFC is suspended</dfn> は <a>[[\Suspended]]</a> 内部スロットが true の場合です。
            </p>
            <p>
                <dfn id="suspend-nfc">suspend NFC</dfn> するには、<a>[[\Suspended]]</a> 内部スロットを true に設定します。
            </p>
            <p>
                <dfn id="resume-nfc">resume NFC</dfn> するには、<a>[[\Suspended]]</a> 内部スロットを false に設定します。
            </p>
            <p class="note">
                内部スロットは本仕様における記法としてのみ使用され、実装がそれらを明示的な内部プロパティに対応付ける必要はありません。
            </p>
        </section>

        <section>
            <h3>NFC アダプタの扱い</h3>
            実装は本仕様で記述されるアルゴリズム手順に従って、複数の <a>NFC adapter</a> を使用してもよい（MAY）ものとします。
        </section>

        <section>
            <h3>権限の取得</h3>
            <p>
                Web NFC API は [=default powerful feature=] であり、[=powerful feature/name=] は
                "<code>nfc</code>" です。
            </p>
            <div>
                <dfn>obtain permission</dfn> するには、次の手順を実行します:
                <ol class=algorithm>
                    <li>
                        |state:PermissionState|</var> を、" <code>nfc</code> " で
                        [=getting the current permission state=] を実行した結果とします。
                    </li>
                    <li>
                        |state| が {{PermissionState["granted"]}}（すなわち、[[[PERMISSIONS]]] API を用いて
                        <a>origin</a> および <a>global object</a> に対して権限が付与されている）であれば、true を返します。
                    </li>
                    <li>
                        それ以外で |state| が {{PermissionState["prompt"]}} の場合、
                        任意でユーザーに "<code>nfc</code>" の <a>request permission to use</a> を行います。
                        許可された場合は true を返します。
                        <p class="issue" data-number="482">
                            <a data-lt="request permission to use">request permission</a> の手順はまだ明確に定義されていません。
                            現時点では、UA は与えられた <a>origin</a> と <a>global object</a> に対する "<code>nfc</code>" の
                            ポリシーについてユーザーに問い合わせ、ユーザーが許可すれば true を返します。
                        </p>
                    </li>
                    <li>
                        false を返します。
                    </li>
                </ol>
            </div>
        </section>

        <section>
            <h3>可視状態の変更の扱い</h3>
            <p>
                本仕様における [=page visibility change steps=] は、文字列 |visibilityState| と
                {{Document}} |document| が与えられた場合、次のとおりです:
            </p>
            <ol class="algorithm">
                <li>
                    |visibilityState| が `"visible"` の場合、<a>resume NFC</a> し、これらの手順を中止します。
                </li>
                <li>
                    それ以外の場合、次を実行します:
                    <ol>
                        <li>
                            <a>Suspend NFC</a>。
                        </li>
                        <li>
                            <a>abort a pending write operation</a> を試みます。
                        </li>
                        <li>
                            <a>abort a pending make read-only operation</a> を試みます。
                        </li>
                    </ol>
                </li>
            </ol>
            <p>
                用語 <dfn id="nfc-suspended">suspended</dfn> は、NFC 操作が一時停止された状態を指し、
                一時停止中は <a>NDEFReader</a> によっていかなる <a>NFC content</a> も書き込まれず、
                受信した <a>NFC content</a> もいかなる {{NDEFReader}} にも提示されません。
            </p>
        </section>

        <section>
            <h3>保留中の書き込み操作の中止</h3>
            <div>
                <dfn>abort a pending write operation</dfn> を試みるには、次の手順を実行します:
                <ol class=algorithm>
                    <li>
                        <a>pending write tuple</a> |tuple| が存在しない場合、これらの手順を中止します。
                    </li>
                    <li>
                        |tuple| の writer がすでに進行中の NFC データ転送を開始している場合、これらの手順を中止します。
                    </li>
                    <li>
                        |tuple| の promise を {{"AbortError"}} で reject し、これらの手順を中止します。
                        <p class=note>
                            promise を reject すると <a>pending write tuple</a> はクリアされます。
                        </p>
                    </li>
                </ol>
            </div>
        </section>

        <section>
            <h3>保留中の読み取り専用化操作の中止</h3>
            <div>
                <dfn>abort a pending make read-only operation</dfn> を試みるには、次の手順を実行します:
                <ol class=algorithm>
                    <li>
                        <a>pending makeReadOnly tuple</a> |tuple| が存在しない場合、これらの手順を中止します。
                    </li>
                    <li>
                        |tuple| の writer がすでに NFC タグを恒久的な読み取り専用にしている場合、これらの手順を中止します。
                    </li>
                    <li>
                        |tuple| の promise を {{"AbortError"}} で reject し、これらの手順を中止します。
                        <p class=note>
                            promise を reject すると <a>pending makeReadOnly tuple</a> はクリアされます。
                        </p>
                    </li>
                </ol>
            </div>
        </section>

        <section>
            <h3>NFC の解放</h3>
            <p>
                <a>environment settings object</a> 上で <dfn>release NFC</dfn> するには、次の手順を実行します:
            </p>
            <ol id="steps-nfc-release">
                <li>
                    <a>Suspend NFC</a>。
                </li>
                <li>
                    <a>abort a pending write operation</a> を試みます。
                </li>
                <li>
                    <a>abort a pending make read-only operation</a> を試みます。
                </li>
                <li>
                    <a>activated reader objects</a> をクリアします。
                </li>
                <li>
                    基盤プラットフォーム上の NFC リソースを解放します。
                </li>
            </ol>
            <p>
                UA はドキュメントの <a>relevant settings object</a> が与えられた場合、
                追加の <a>unloading document cleanup steps</a> として <a>release NFC</a> しなければなりません。
            </p>
        </section> <!-- release NFC -->

        <section data-dfn-for="NDEFWriteOptions">
            <h3><dfn>NDEFWriteOptions</dfn> 辞書</h3>
            <pre class="idl">
      dictionary NDEFWriteOptions {
        boolean overwrite = true;
        AbortSignal? signal;
      };
    </pre>
            <p>
                <dfn>overwrite</dfn> プロパティの値が false の場合、<a href="#steps-write">write アルゴリズム</a>は
                <a>NFC tag</a> を読み取り、その上に <a>NDEF</a> レコードがあるかどうかを確認し、
                ある場合はいかなる保留中の書き込みも実行しません。
            </p>
            <p>
                <dfn>signal</dfn> プロパティにより、{{NDEFReader/write()}} 操作を中止できます。
            </p>
        </section>

        <section data-dfn-for="NDEFMakeReadOnlyOptions">
            <h3><dfn>NDEFMakeReadOnlyOptions</dfn> 辞書</h3>
            <pre class="idl">
      dictionary NDEFMakeReadOnlyOptions {
        AbortSignal? signal;
      };
    </pre>
            <p>
                <dfn>signal</dfn> プロパティにより、{{NDEFReader/makeReadOnly()}} 操作を中止できます。
            </p>
        </section>

        <section data-dfn-for="NDEFScanOptions">
            <h3><dfn>NDEFScanOptions</dfn> 辞書</h3>
            <pre class="idl">
        dictionary NDEFScanOptions {
          AbortSignal signal;
        };
      </pre>
            <p>
                <dfn>signal</dfn> プロパティにより、{{NDEFReader/scan()}} 操作を中止できます。
            </p>
        </section> <!-- NDEFScanOptions -->

        <section id="writing-content">
            <h3><dfn>Writing content</dfn></h3>
            <p>
                本セクションは、タイマーが期限切れになる前に、次回近接範囲に入ったときに
                <a>NFC tag</a> に <a>NDEF message</a> を書き込む方法を説明します。
                任意の時点で、現在のメッセージが送信されるか書き込みが中止されるまで、
                1 つの <a>origin</a> につき設定可能な <a>NDEF message</a> は最大 1 つです。
            </p>
            <section>
                <h3><strong>write()</strong> メソッド</h3>
                <div id="steps-write">
                    <dfn>NDEFReader.write</dfn> メソッドは、呼び出されたとき、<dfn>write a message</dfn> アルゴリズムを実行しなければなりません:
                    <ol class=algorithm>
                        <li>
                            |p:Promise| を新しい {{Promise}} オブジェクトとします。
                        </li>
                        <li>
                            現在アクティブな <a>top-level browsing context</a> で実行していない場合、|p| を
                            {{"InvalidStateError"}} で reject して |p| を返します。
                        </li>
                        <li>
                            |message:NDEFMessageSource| を第 1 引数とします。
                        </li>
                        <li>
                            |options:NDEFWriteOptions| を第 2 引数とします。
                        </li>
                        <li>
                            |signal:AbortSignal| を、存在すれば |options| の同名の辞書メンバー、そうでなければ null とします。
                        </li>
                        <li>
                            |signal| が [= AbortSignal/aborted =] の場合、|signal| の [=AbortSignal/abort reason=] で |p| を
                            reject し、|p| を返します。
                        </li>
                        <li>
                            |signal| が null でない場合、|signal| に
                            <a data-cite="dom#abortsignal-abort-algorithms">
                                次の中止手順</a>を追加します:
                            <ol>
                                <li>
                                    <a>environment settings object</a> 上で
                                    <a>abort a pending write operation</a> を実行します。
                                </li>
                            </ol>
                        </li>
                        <li>
                            [=promise/React=] to |p|:
                            <ol>
                                <li>
                                    |p| が settle（fulfill または reject）された場合、存在すれば
                                    <a>pending write tuple</a> をクリアします。
                                </li>
                            </ol>
                        </li>
                        <li>
                            |p| を返し、次の手順を<a>in parallel</a> に実行します:
                            <ol>
                                <li>
                                    <a>obtain permission</a> が false を返す場合、|p| を {{"NotAllowedError"}} で
                                    reject し、これらの手順を中止します。
                                </li>
                                <li>
                                    基盤となる <a>NFC Adapter</a> が存在しない、または接続を確立できない場合、
                                    |p| を {{"NotSupportedError"}} で reject し、これらの手順を中止します。
                                </li>
                                <li>
                                    UA が基盤の <a>NFC Adapter</a> にアクセスすることを許可されていない場合（例: ユーザー設定）、
                                    |p| を {{"NotReadableError"}} で reject し、これらの手順を中止します。
                                </li>
                                <li>
                                    基盤の <a>NFC Adapter</a> がデータのプッシュをサポートしていない場合、
                                    |p| を {{"NotSupportedError"}} で reject し、これらの手順を中止します。
                                </li>
                                <li>
                                    実装は |p| を {{"NotSupportedError"}} で reject してもよく、
                                    これらの手順を中止してもかまいません（MAY）。
                                    <p class="note">
                                        UA はこの地点でメッセージ書き込みを中止することがあります。
                                        終了の理由は実装詳細です。例えば、要求された操作をサポートできない場合があります。
                                    </p>
                                </li>
                                <li>
                                    |message|、`""`、`0` を与えて <a>create NDEF message</a> を呼び出した結果として、
                                    UA により作成される <a>NDEF message</a> の表記を |output| とします。
                                    これが例外を投げた場合、その例外で |p| を reject し、これらの手順を中止します。
                                </li>
                                <li>
                                    <a>abort a pending write operation</a> を試みます。
                                    <p class="note">
                                        書き込みは、それまでに構成された書き込み操作をすべて置き換えます。
                                    </p>
                                </li>
                                <li>
                                    `this`.<a>[[\WriteOptions]]</a> を |options| に設定します。
                                </li>
                                <li>
                                    `this`.<a>[[\WriteMessage]]</a> を |output| に設定します。
                                </li>
                                <li>
                                    <a>pending write tuple</a> を (`this`, |p|) に設定します。
                                </li>
                                <li>
                                    <a>NFC tag</a> |device| が通信範囲に入ったときはいつでも、
                                    <a>start the NFC write</a> の手順を実行します。
                                    <p class="note">
                                        <a>NFC is suspended</a> の場合、ユーザーによって promise が中止されるか、
                                        <a>NFC tag</a> が通信範囲に入るまで待機を続けます。
                                    </p>
                                </li>
                            </ol>
                        </li>
                        </li>
                    </ol>
                </div>

                <div id="steps-start-nfc-write">
                    <dfn>start the NFC write</dfn> するには、次の手順を実行します:
                    <ol class=algorithm>
                        <li>
                            |p:Promise| を <a>pending write tuple</a> の promise とします。
                        </li>
                        <li>
                            |writer| を <a>pending write tuple</a> の writer とします。
                        </li>
                        <li>
                            |options:NDEFWriteOptions| を |writer|.<a>[[\WriteOptions]]</a> とします。
                        </li>
                        <li>
                            近接範囲の <a>NFC tag</a> がフォーマットまたは書き込みのための <a>NDEF</a> 技術を公開しない場合、
                            |p| を {{"NotSupportedError"}} で reject して |p| を返します。
                        </li>
                        <li>
                            <a href="#nfc-is-suspended">NFC is not suspended</a> であることを検証します。
                        </li>
                        <li>
                            成功した場合、次を実行します:
                            <ol>
                                <li>
                                    |device| が <a>NFC tag</a> で、|options| の overwrite が false の場合、
                                    タグを読み取り、タグ上に <a>NDEF</a> レコードがあるか確認します。
                                    ある場合、|p| を {{"NotAllowedError"}} で reject して |p| を返します。
                                </li>
                                <li>
                                    |output:NDEFMessage| を |writer|.<a>[[\WriteMessage]]</a> とします。
                                </li>
                                <li>
                                    通信範囲内の <a>NFC adapter</a> を用いて、|output| をバッファとして
                                    |device| へのデータ転送を開始します。
                                    <p class="note">
                                        近接範囲の <a>NFC tag</a> が未フォーマットで <a>NDEF</a> フォーマット可能な場合は、
                                        それをフォーマットし、|output| をバッファとして書き込みます。
                                    </p>
                                    <p class="note">
                                        複数のアダプタはユーザーにより順次使用されるべきです。
                                        異なる複数の接続された <a>NFC adapter</a> で同時にタップが起こる可能性は非常に低いです。
                                        それが起きた場合、成功するまで（望ましくは 1 台ずつ）タップを繰り返す必要があるでしょう。
                                        ここでのエラーは操作を繰り返す必要があることを示します。そうしないと、
                                        すべての接続された <a>NFC adapter</a> で操作が成功したとユーザーが誤解する恐れがあります。
                                    </p>
                                </li>
                                <li>
                                    転送が失敗した場合、|p| を {{"NetworkError"}} で reject し、これらの手順を中止します。
                                </li>
                                <li>
                                    転送が完了したら、|p| を resolve します。
                                </li>
                            </ol>
                        </li>
                    </ol>
                </div>
            </section>
        </section> <!-- Writing content -->

        <section>
            <h3>NDEF メッセージの作成</h3>
            <div>
                |source:NDEFMessageSource|、|context:string|、|recordsDepth:unsigned short| を与えて
                <dfn>create NDEF message</dfn> するには、次の手順を実行します:
                <ol class=algorithm id="create-web-nfc-message" data-link-for="NDEFMessageSource">
                    <li>|source:NDEFMessageSource| の型で分岐します:
                        <dl>
                            <dt>{{DOMString}}</dt>
                            <ul>
                                <li>
                                    |textRecord| を、|recordType| を "`text`"、|data| を |source| に設定して初期化した
                                    <a>NDEFRecord</a> とします。
                                </li>
                                <li>
                                    |records| を « |textRecord| » のリストとします。
                                </li>
                                <li>
                                    |source| の records を |records| に設定します。
                                </li>
                            </ul>
                            <dt>{{BufferSource}}</dt>
                            <ul>
                                <li>
                                    |mimeRecord| を、|recordType| を "`mime`"、|data| を |source|、
                                    |mediaType| を "`application/octet-stream`" に設定して初期化した
                                    <a>NDEFRecord</a> とします。
                                </li>
                                <li>
                                    |records| を « |mimeRecord| » のリストとします。
                                </li>
                                <li>
                                    |source| の records を |records| に設定します。
                                </li>
                            </ul>
                            <dt>{{NDEFMessageInit}}</dt>
                            <ul>
                                <li>
                                    |source| の records が [= list/is empty =] の場合、{{TypeError}} を
                                    [= exception/throw =] します。
                                </li>
                                <li>
                                    |recordsDepth| を 1 増やします。
                                </li>
                                <li>
                                    |recordsDepth| > `32` の場合、{{TypeError}} を
                                    [= exception/throw =] します。
                                    <aside class="note">
                                        実運用上、NDEF メッセージに保存できる容量には限りがあるため、
                                        本仕様はネストされたメッセージの深さに上限を設けています。
                                        開発者がこの上限に達することはまずありません。
                                        <a href="https://github.com/w3c/web-nfc/issues/620">issue #620</a> を参照。
                                    </aside>
                                </li>
                            </ul>
                            <dt>unmatched type</dt>
                            <ul>
                                <li>
                                    {{TypeError}} を [= exception/throw =] します。
                                </li>
                            </ul>
                        </dl>
                    </li>
                    <li>
                        これらの手順の結果として UA により作成される <a>NDEF message</a> の表記を |output| とします。
                    </li>
                    <li>
                        <a>list</a> |source| の records 内の [= list/For each =] |record:NDEFRecordInit| について次を実行します:
                        <ol>
                            <li>
                                |record:NDEFRecordInit|、|context|、|recordsDepth| を与えて
                                <a>create NDEF record</a> を実行した結果、または基盤プラットフォームが
                                等価な値を |ndef| に提供することを確実にします。アルゴリズムが例外 |e| を投げた場合、
                                |promise| を |e| で reject し、これらの手順を中止します。
                            </li>
                            <li>
                                |output| に |ndef| を追加します。
                            </li>
                        </ol>
                    </li>
                    <li>
                        |output| と |context| を与えて <a>check created records</a> を実行し、|error: Error| を投げた場合、
                        |promise| を |error| で reject し、これらの手順を中止します。
                    </li>
                    <li>
                        |output| を返します。
                    </li>
                </ol>
            </div>

            <section>
                <h3>作成済みレコードの検査</h3>
                <div>
                    |records: NDEFRecord sequence| および |context: string| を与えて
                    <dfn>check created records</dfn> するには、次の手順を実行します:
                    <ol class=algorithm>
                        <li>
                            |context| が `"smart-poster"` で、|records| がちょうど 1 つの
                            <a>URI record</a> を含まない場合、または複数の
                            <a>type record</a>、<a>size record</a>、<a>action record</a> を含む場合、
                            {{TypeError}} を [= exception/throw =] します。
                        </li>
                        <li>
                            |context| が `"smart-poster"` の場合、<a>URI record</a> を |records| の先頭に移動します。
                        </li>
                    </ol>
                    <p class="note">
                        現時点の Web NFC は、<a>smart poster</a> 内で <a>external type</a> と
                        <a>local type</a> のレコードを書き込むことを許可しています。
                        また、<a>empty records</a> も許可されます。
                        アプリケーションは <a>smart poster</a> 内の余分なレコードを無視してもかまいません。
                    </p>
                    <p class="note">
                        アイコンレコードのメディアタイプは `"image/"` や `"video/"` に限定することもできますが、
                        [[NDEF-SMARTPOSTER]] 仕様では実際には他のメディアタイプレコードも <a>smart poster</a> 内で許容され、
                        例えば vCard の連絡先カードが関連する
                        <a href="https://www.iana.org/assignments/media-types/media-types.xhtml">
                            MIME types</a> のいずれかを使用するなど、アプリケーション固有の方法で扱えます。
                    </p>
                </div>
            </section>

            <section>
                <h3>NDEF レコードの作成</h3>
                <div>
                    |record:NDEFRecordInit|、|context:string|、|recordsDepth:unsigned short| を与えて
                    <dfn>create NDEF record</dfn> するには、次の手順を実行します:
                    <ol data-link-for="NDEFRecordInit">
                        <li>
                            UA により作成される <a>NDEF record</a> の表現を |ndef| とします。
                        </li>
                        <li>
                            |record| の <a>id</a> が undefined でない場合:
                            <ul>
                                <li>
                                    |identifier| を |record| の <a>id</a> とします。
                                </li>
                                <li>
                                    |ndef| の <a>IL field</a> を `1` に設定します。
                                </li>
                                <li>
                                    |ndef| の <a>ID LENGTH field</a> を |identifier| の長さに設定します。
                                </li>
                                <li>
                                    |ndef| の <a>ID field</a> を |identifier| に設定します。
                                </li>
                            </ul>
                        </li>
                        <li>
                            |record| の <a>recordType</a> に応じて切り替え、以下に示すアルゴリズムを
                            |record|、|ndef|、|context|、|recordsDepth| で呼び出し、その結果を返します。
                            例外 |e| が投げられた場合、|promise| を |e| で reject し、これらの手順を中止します。
                            <dl>
                                <dt>"`empty`"</dt>
                                <ul>
                                    <li>
                                        <a>map empty record to NDEF</a>。
                                    </li>
                                </ul>
                                <dt>"`text`"</dt>
                                <ul>
                                    <li>
                                        <a>map text to NDEF</a>。
                                    </li>
                                </ul>
                                <dt>"`url`"</dt>
                                <ul>
                                    <li>
                                        <a>map a URL to NDEF</a>。
                                    </li>
                                </ul>
                                <dt>"`mime`"</dt>
                                <ul>
                                    <li>
                                        <a>map binary data to NDEF</a>。
                                    </li>
                                </ul>
                                <dt>"`smart-poster`"</dt>
                                <ul>
                                    <li>
                                        <a>map smart poster to NDEF</a>。
                                    </li>
                                </ul>
                                <dt>"`absolute-url`"</dt>
                                <ul>
                                    <li>
                                        <a>map absolute-URL to NDEF</a>。
                                    </li>
                                </ul>
                            </dl>
                        </li>
                        <li>
                            |record| の <a>recordType</a> がコロン `U+003A` (`:`) で始まる場合:
                            <ul>
                                <li>
                                    |context| が `""`（すなわち |record| が別の <a>NDEF record</a> のペイロードではない）
                                    の場合、{{TypeError}} で |promise| を reject し、これらの手順を中止します。
                                </li>
                                <li>
                                    |record| の <a>recordType</a> に対して <a>validate local type</a> を実行して
                                    false を返す場合、{{TypeError}} で |promise| を reject し、これらの手順を中止します。
                                </li>
                                <li>
                                    |record|、|ndef|、|context|、|recordsDepth| を与えて
                                    <a>map local type to NDEF</a> を実行した結果を返します。
                                    それが例外 |e| を投げる場合、|promise| を |e| で reject し、これらの手順を中止します。
                                </li>
                            </ul>
                        </li>
                        <li>
                            |record| の <a>recordType</a> に対して <a>validate external type</a> が true を返す場合、
                            |record|、|ndef|、|context|、|recordsDepth| を与えて
                            <a>map external data to NDEF</a> を返します。
                            それが例外 |e| を投げる場合、|promise| を |e| で reject し、これらの手順を中止します。
                        </li>
                        <li>
                            それ以外の場合、{{TypeError}} を [= exception/throw =] し、これらの手順を中止します。
                        </li>
                    </ol>
                </div>
            </section>

            <section>
                <h3>外部タイプの検証</h3>
                <div>
                    [[NFC-RTD]] は、外部タイプが発行組織の [=domain=] 名、コロン `U+003A` (`:`)、
                    そして 1 文字以上の型名を必ず含むことを規定しています。例として
                    "`w3.org:member`" のように、すべて ASCII 文字で保存されます。
                </div>
                <p>
                    [[NFC-RTD]] は URN 接頭辞 “`urn:nfc:ext:`” も規定しますが、
                    これは <a>NDEF record</a> には保存されません。そのため、Web NFC アプリケーションは
                    <a>external type records</a> を作成する際に URN 接頭辞を指定すべきではありません（SHOULD NOT）。
                </p>
                <p class="note">
                    [[NFC-RTD]] は、例えば <a>NDEF messages</a> を読み取る場合など、外部タイプ名は
                    URN 接頭辞 “`urn:nfc:ext:`” で表現することを求めています。
                    しかし、<a>external type records</a> は <a>TNF FIELD</a> を `0x04` に設定することで区別されるため、
                    型名の衝突リスクはないと考えられます。
                    また、Web で URN の使用を避けるよう求める
                    <a href="https://www.w3.org/2001/tag/doc/URNsAndRegistries-50.html">
                        W3C TAG の勧告</a>もあります。
                    したがって、Web NFC は <a>NDEF messages</a> の読み取り・書き込みのいずれでも URN 接頭辞を使用しません。
                </p>
                <p>
                    |input:USVString| を与えて <dfn>split external type</dfn> するには、次の手順を実行します:
                </p>
                <ol class=algorithm id="split-external-type">
                    <li>
                        |input| に `U+003A` (`:`) が見つからない場合、failure を返します。
                    </li>
                    <li>
                        |domain| を、|input| の先頭から最初の `U+003A` (`:`) の直前までの文字列とします。
                    </li>
                    <li>
                        |type| を、最初の `U+003A` (`:`) の直後（もしあれば）から末尾までの文字列とします。
                    </li>
                    <li>
                        |domain| と |type| のペアを返します。
                    </li>
                </ol>
                <p>
                    |input:USVString| を与えて <dfn>validate external type</dfn> するには、次の手順を実行します:
                </p>
                <ol class=algorithm id="validate-external-type">
                    <li>
                        [=split external type=] の結果として |domain| と |type| を得るか、失敗なら false を返します。
                    </li>
                    <li>
                        |domain| が [=valid domain string=] でない場合、false を返します。
                    </li>
                    <li>
                        |type| に、[=ASCII alphanumeric=] 以外、または `U+0024` (`$`)、`U+0027` (`'`),
                        `U+0028` `LEFT PARENTHESIS` (`(`)、`U+0029` `RIGHT PARENTHESIS` (`)`)、`U+002A` (`*`)、`U+002B`
                        (`+`)、
                        `U+002C` (`,`)、`U+002D` (`-`)、`U+002E` (`.`)、`U+003B` (`;`)、`U+003D` (`=`)、
                        `U+0040` (`@`)、`U+005F` (`_`) のいずれでもない [=code points=] が含まれている場合、false を返します。
                    </li>
                    <li>
                        true を返します。
                    </li>
                </ol>
            </section>

            <section>
                <h3>ローカルタイプの検証</h3>
                <p>
                    |input:USVString| を与えて <dfn>validate local type</dfn> するには、次の手順を実行します:
                </p>
                <ol class=algorithm id="validate-local-type">
                    <li>
                        |localTypeName| を、|input| の最初の `U+003A` (`:`) の直後から末尾までとします。
                    </li>
                    <li>
                        |localTypeName| が {{USVString}} でない、または長さが 255 バイトを超える場合、false を返します。
                    </li>
                    <li>
                        |localTypeName| が小文字または数字で始まっていない場合、false を返します。
                    </li>
                    <li>
                        |input| が、その包含する <a>NDEF message</a> 内で定義された任意の <a>NDEF record</a> の
                        <a>record type</a> と等しい場合、false を返します。
                    </li>
                    <li>
                        true を返します。
                    </li>
                </ol>
            </section>

            <section>
                <h3>空レコードから NDEF へのマッピング</h3>
                <div>
                    |record:NDEFRecordInit|、|ndef| を与えて <dfn>map empty record to NDEF</dfn> するには、次の手順を実行します:
                    <ol class=algorithm data-link-for="NDEFRecordInit">
                        <!--
          <li>
            If |context| is `"smart-poster"`,
            [= exception/throw =] a {{TypeError}}.
          </li>
          -->
                        <li>
                            |record| の <a>mediaType</a> が undefined でない場合、{{TypeError}} を
                            [= exception/throw =] します。
                        </li>
                        <li>
                            |record| の <a>id</a> が undefined でない場合、{{TypeError}} を
                            [= exception/throw =] します。
                        </li>
                        <li>
                            |ndef| の <a>TNF field</a> を `0`（<a>empty record</a>）に設定します。
                        </li>
                        <li>
                            |ndef| の <a>IL field</a> を `0` に設定します。
                        </li>
                        <li>
                            |ndef| の <a>TYPE LENGTH field</a> および <a>PAYLOAD LENGTH field</a> を `0` に設定し、
                            <a>TYPE field</a> と <a>PAYLOAD field</a> を省略します。
                        </li>
                        <li>
                            |ndef| を返します。
                        </li>
                    </ol>
                </div>
            </section>

            <section>
                <h3>文字列から NDEF へのマッピング</h3>
                <div>
                    |record:NDEFRecordInit| と |ndef| を与えて <dfn>map text to NDEF</dfn> するには、次の手順を実行します:
                    <p class="note">
                        これは、クライアントが特に [=well-known type record=] としてテキストを書き込みたい場合に有用です。
                        他の選択肢として、明示的な <a>MIME type</a> のテキスト型を用いる "`mime`" の値を使用することもでき、
                        例えば "`text/xml`" や "`text/vcard`" を用いることで、より明確な区別が可能です。
                    </p>
                    <ol class=algorithm data-link-for="NDEFRecordInit">
                        <li>
                            |record| の <a>mediaType</a> が undefined でない場合、{{TypeError}} を
                            [= exception/throw =] します。
                        </li>
                        <li>
                            |record| の <a>data</a> の型が {{DOMString}} または {{BufferSource}} でない場合、
                            {{TypeError}} を [= exception/throw =] し、これらの手順を中止します。
                        </li>
                        <li>
                            |documentLanguage:string| を [=document element=] の <a>lang</a> 属性とします。
                        </li>
                        <li>
                            |documentLanguage| が空文字列である場合、"`en`" に設定します。
                        </li>
                        <li>
                            |language:string| を、存在する場合は |record| の <a>lang</a> に、そうでなければ |documentLanguage| に設定します。
                        </li>
                        <li>|record| の <a>data</a> の型で分岐します:
                            <dl>
                                <dt>{{DOMString}}</dt>
                                <ol>
                                    <li>
                                        |record| の <a>encoding</a> が undefined ではなく、かつ "`utf-8`" でもない場合、
                                        {{TypeError}} を [= exception/throw =] し、これらの手順を中止します。
                                    </li>
                                    <li>
                                        |encoding label:string| を "`utf-8`" に設定します。
                                    </li>
                                </ol>
                                <dt>{{BufferSource}}</dt>
                                <ol>
                                    <li>
                                        |encoding label:string| を、存在する場合は |record| の <a>encoding</a> に、
                                        そうでなければ "`utf-8`" に設定します。
                                    </li>
                                    <li>
                                        |encoding label| が "`utf-8`"、"`utf-16`"、"`utf-16le`"、"`utf-16be`" のいずれでもない場合、
                                        {{TypeError}} を [= exception/throw =] します。
                                    </li>
                                </ol>
                            </dl>
                        </li>
                        <li>
                            |encoding name| を、|encoding label| から
                            <a data-cite="encoding#concept-encoding-get">取得</a>された [=encoding/name|name=] とします。
                        </li>
                        <li>
                            |header:byte| を次のように構築した <a>byte</a> とします:
                            <ol>
                                <li>
                                    |encoding name| が UTF-8 に等しい場合、ビット `7` を `0` に設定し、
                                    そうでなければ `1` に設定します。
                                </li>
                                <li>
                                    ビット `6` を `0`（予約）に設定します。
                                </li>
                                <li>
                                    |languageLength:octet| を |language| <a>string</a> の長さとします。
                                </li>
                                <li>
                                    |languageLength| を 6 ビットに格納できない場合（|languageLength| > 63）、
                                    {{SyntaxError}} を [= exception/throw =] します。
                                </li>
                                <li>
                                    ビット `5` からビット `0` に |languageLength| を設定します。
                                </li>
                            </ol>
                        </li>
                        <li>
                            |data:byte sequence| を空の [= byte sequence =] とします。
                            <ol>
                                <li>
                                    |data| の最初の <a>byte</a>（位置 0）を |header| に設定します。
                                </li>
                                <li>
                                    |data| の位置 1（2 番目の <a>byte</a>）から |languageLength| までを |language| に設定します。
                                </li>
                                <li>|record| の <a>data</a> の型で分岐します:
                                    <dl>
                                        <dt>{{DOMString}}</dt>
                                        <ol>
                                            <li>
                                                |stream:byte stream| を、|record| の <a>data</a> に
                                                <a data-cite="encoding#concept-stream">UTF-8 encode</a> を実行した結果の
                                                <a data-cite="encoding#concept-stream">byte stream</a> とします。
                                            </li>
                                            <li>
                                                <a data-cite="encoding#concept-stream-read">read</a> が
                                                <a data-cite="encoding#end-of-stream">end-of-stream</a> を返すまで、
                                                |stream| から |data|（位置 |languageLength| + 1 から）へバイトを
                                                <a data-cite="encoding#concept-stream-read">読み込み</a>ます。
                                            </li>
                                        </ol>
                                        <dt>{{BufferSource}}</dt>
                                        <ol>
                                            <li>
                                                |record| の <a>data</a> のバイトを |data| の（位置 |languageLength| + 1 から）
                                                設定します。
                                            </li>
                                        </ol>
                                    </dl>
                                </li>
                            </ol>
                        </li>
                        <li>
                            |length:unsigned long| を |data| の [=byte sequence/length=] とします。
                        </li>
                        <li>
                            <ol>
                                <li>
                                    |ndef| の <a>TNF field</a> を `1`（[=well-known type record=]）に設定します。
                                </li>
                                <li>
                                    |ndef| の <a>TYPE field</a> を "`T`"（`0x54`）に設定します。
                                </li>
                                <li>
                                    |ndef| の <a>PAYLOAD LENGTH field</a> を |length| に設定します。
                                </li>
                                <li>
                                    |length| > `0` の場合、|ndef| の <a>PAYLOAD field</a> を |data| に設定します。
                                </li>
                            </ol>
                        </li>
                        <li>
                            |ndef| を返します。
                        </li>
                    </ol>
                </div>
            </section>

            <section>
                <h3>URL から NDEF へのマッピング</h3>
                <div>
                    |record:NDEFRecordInit| と |ndef| を与えて <dfn>map a URL to NDEF</dfn> するには、次の手順を実行します:
                    <ol class=algorithm data-link-for="NDEFRecordInit">
                        <li>
                            |record| の <a>mediaType</a> が undefined でない場合、{{TypeError}} を
                            [= exception/throw =] します。
                        </li>
                        <li>
                            |record| の <a>data</a> が {{DOMString}} でない場合、{{TypeError}} を
                            [= exception/throw =] します。
                        </li>
                        <li>
                            |url:URL| を、|record| の <a>data</a> を
                            <a data-lt="url parser">parsing</a> した結果とします。
                        </li>
                        <li>
                            |url| が failure の場合、{{SyntaxError}} を [= exception/throw =] します。
                        </li>
                        <li>
                            |serializedURL:string| を |url| の
                            <a data-cite="url#concept-url-serializer">serialization</a> とします。
                        </li>
                        <li>
                            [[[NFC-STANDARDS]]] の URI Record Type Definition 仕様 セクション 3.2.2 に定義された
                            URI プレフィックスを |serializedURL| に対して照合します。
                        </li>
                        <li>
                            |prefixString:string| を、一致したプレフィックス、または <a href="#dfn-empty">empty</a> な
                            <a>string</a> とします。
                        </li>
                        <li>
                            |prefixByte:byte| を、対応するプレフィックス番号、または `0` とします。
                        </li>
                        <li>
                            |shortenedURL:string| を、|serializedURL| の先頭から |prefixString| を取り除いた
                            <a>string</a> とします。
                        </li>
                        <li>
                            |data:byte sequence| を空の [= byte sequence =] とします。
                            <ol>
                                <li>
                                    |data| の最初の <a>byte</a> を |prefixByte| に設定します。
                                </li>
                                <li>
                                    |stream:byte stream| を、|shortenedURL| に
                                    <a data-cite="encoding#concept-stream">UTF-8 encode</a> を実行した結果の
                                    <a data-cite="encoding#concept-stream">byte stream</a> とします。
                                </li>
                                <li>
                                    <a data-cite="encoding#concept-stream-read">read</a> が
                                    <a data-cite="encoding#end-of-stream">end-of-stream</a> を返すまで、
                                    |stream| から |data|（位置 1 から）へバイトを
                                    <a data-cite="encoding#concept-stream-read">読み込み</a>ます。
                                </li>
                            </ol>
                        </li>
                        <li>
                            |length:unsigned long| を |data| の [=byte sequence/length=] とします。
                        </li>
                        <li>
                            |ndef| の <a>TNF field</a> を `1`（[=well-known type record=]）に設定します。
                        </li>
                        <li>
                            |ndef| の <a>TYPE field</a> を "`U`"（`0x55`）に設定します。
                        </li>
                        <li>
                            |ndef| の <a>PAYLOAD LENGTH field</a> を |length| に設定します。
                        </li>
                        <li>
                            |length| > `0` の場合、|ndef| の <a>PAYLOAD field</a> を |data| に設定します。
                        </li>
                        <li>
                            |ndef| を返します。
                        </li>
                    </ol>
                </div>
            </section>

            <section>
                <h3>バイナリデータから NDEF へのマッピング</h3>
                <div>
                    |record:NDEFRecordInit| と |ndef| を与えて <dfn>map binary data to NDEF</dfn> するには、
                    次の手順を実行します:
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            |record| の <a>data</a> の型が {{BufferSource}} でない場合、{{TypeError}} を
                            [= exception/throw =] します。
                        </li>
                        <li>
                            |mimeType| を、|record| の <a>mediaType</a> に対して
                            <a>parse a MIME type</a> を実行して得られる <a>MIME type</a> とします。
                        </li>
                        <li>
                            |mimeType| が failure の場合、|mimeTypeRecord| を、type が "`application`"、
                            subtype が "`octet-stream`" の新しい <a>MIME type record</a> とします。
                        </li>
                        <!--
          <li>
            If |context| is `"smart-poster"` and |mimeType| does not
            start with `"image/"` or `"video/"`, [= exception/throw =] a {{TypeError}}.
          </li>
          -->
                        <li>
                            |arrayBuffer| を |record| の <a>data</a> に設定します。
                        </li>
                        <li>
                            |length:unsigned long| を |arrayBuffer|.[[\ArrayBufferByteLength]] に設定します。
                        </li>
                        <li>
                            |data:byte sequence| を |arrayBuffer|.[[\ArrayBufferData]] に設定します。
                        </li>
                        <li>
                            |ndef| の <a>TNF field</a> を `2`（<a>MIME type</a>）に設定します。
                        </li>
                        <li>
                            |ndef| の <a>TYPE field</a> を、|mimeType| を入力として
                            <a>serialize a MIME type</a> を実行した結果に設定します。
                        </li>
                        <li>
                            |ndef| の <a>PAYLOAD LENGTH field</a> を |length| に設定します。
                        </li>
                        <li>
                            |length| > `0` の場合、|ndef| の <a>PAYLOAD field</a> を |data| に設定します。
                        </li>
                        <li>
                            |ndef| を返します。
                        </li>
                    </ol>
                </div>
            </section>

            <section>
                <h3>外部データから NDEF へのマッピング</h3>
                <div>
                    |record:NDEFRecordInit|、|ndef|、|recordsDepth:unsigned short| を与えて
                    <dfn>map external data to NDEF</dfn> するには、次の手順を実行します:
                    <ol class=algorithm data-link-for="NDEFRecordInit">
                        <!--
          <li>
            If |context| is `"smart-poster"`,
            [= exception/throw =] a {{TypeError}}.
          </li>
          -->
                        <li>
                            |record| の <a>mediaType</a> が undefined でない場合、{{TypeError}} を
                            [= exception/throw =] します。
                        </li>
                        <li>
                            |domain| と |type| を、|record| の <a>recordType</a> に対して
                            [=split external type=] を実行した結果とします。
                        </li>
                        <aside class="note">
                            上のステップは、外部タイプの事前検証により常に成功します。
                        </aside>
                        <li>
                            |domain| を、|domain| と true を与えて
                            <a href="https://url.spec.whatwg.org/#concept-domain-to-ascii">
                                domain to ASCII</a> を実行した結果とします。
                        </li>
                        <aside class="note">
                            レコードの <a>recordType</a> はユーザー設定で UTF-8 エンコーディングであり、
                            "håndværker.dk:abc" のように国際化ドメイン名を含むことができます。
                            これを NDEF レコードに書き込む際は ASCII バイトに変換する必要があり、
                            変換後は "xn--hndvrker-9zan.dk:abc" のように表現されます。
                        </aside>
                        <li>
                            |customTypeName| を |domain|、"`:`"、|type| を連結したものとします。
                        </li>
                        <li>
                            |customTypeName| が {{USVString}} でない、または長さが 255 バイトを超える場合、
                            {{TypeError}} を [= exception/throw =] します。
                        </li>
                        <li>
                            |ndef| の <a>TYPE field</a> を |customTypeName| に設定します。
                        </li>
                        <li>
                            |record| の <a>data</a> の型が {{BufferSource}} または {{NDEFMessageInit}} でない場合、
                            {{TypeError}} を [= exception/throw =] します。
                        </li>
                        <li>
                            |ndef| の <a>TNF field</a> を `4`（<a>external type record</a>）に設定します。
                        </li>
                        <li>
                            |record| の <a>data</a> の型が {{BufferSource}} の場合、
                            <ol>
                                <li>
                                    |arrayBuffer| を |record| の <a>data</a> に設定します。
                                </li>
                                <li>
                                    |length:unsigned long| を |arrayBuffer|.[[\ArrayBufferByteLength]] に設定します。
                                </li>
                                <li>
                                    |data:byte sequence| を |arrayBuffer|.[[\ArrayBufferData]] に設定します。
                                </li>
                                <li>
                                    |ndef| の <a>PAYLOAD LENGTH field</a> を |length| に設定します。
                                </li>
                                <li>
                                    |length| > `0` の場合、|ndef| の <a>PAYLOAD field</a> を |data| に設定します。
                                </li>
                            </ol>
                        </li>
                        <li>
                            |record| の <a>data</a> の型が {{NDEFMessageInit}} の場合、
                            <ol>
                                <li>
                                    |ndef| の <a>PAYLOAD field</a> を、
                                    |record| の <a>data</a>、`"external"`、|recordsDepth| を与えた
                                    <a>create NDEF message</a> を実行した結果に設定します。
                                </li>
                                <li>
                                    |ndef| の <a>PAYLOAD LENGTH field</a> を、
                                    |ndef| の <a>PAYLOAD field</a> の長さに設定します。
                                </li>
                            </ol>
                        </li>
                        <li>
                            |ndef| を返します。
                        </li>
                    </ol>
                </div>
            </section>

            <section>
                <h3>ローカルタイプから NDEF へのマッピング</h3>
                <div>
                    |record:NDEFRecordInit|、|ndef|、|context:string|、|recordsDepth:unsigned short| を与えて
                    <dfn>map local type to NDEF</dfn> するには、次の手順を実行します:
                    <ol class=algorithm data-link-for="NDEFRecordInit">
                        <li>
                            |record| の <a>mediaType</a> が undefined でない場合、{{TypeError}} を
                            [= exception/throw =] します。
                        </li>
                        <li>
                            |record| の <a>data</a> の型が {{BufferSource}} または {{NDEFMessageInit}} でない場合、
                            {{TypeError}} を [= exception/throw =] します。
                        </li>
                        <li>
                            |ndef| の <a>TNF field</a> を `1`（[=well-known type record=]）に設定します。
                        </li>
                        <li>
                            |localTypeName| を、|record| の <a>recordType</a> の最初の
                            `U+003A` (`:`) の直後から末尾までとします。
                        </li>
                        <li>
                            |ndef| の <a>TYPE field</a> を |localTypeName| に設定し、
                            <a>local type name</a> を表します。
                        </li>
                        <li>
                            |context| が `"smart-poster"`、|localTypeName| が
                            <strong>"`s`"（`0x73`）</strong> で、|record| の <a>data</a> の型が
                            {{BufferSource}} でない、またはバイト長が 4 を超える場合、{{TypeError}} を
                            [= exception/throw =] します。
                        </li>
                        <li>
                            |context| が `"smart-poster"`、|localTypeName| が
                            <strong>"`act`"（`0x61` `0x63` `0x74`）</strong> で、|record| の <a>data</a> の型が
                            {{BufferSource}} でない、またはバイト長がちょうど 1 ではない場合、
                            {{TypeError}} を [= exception/throw =] し、これらの手順を中止します。
                        </li>
                        <li>
                            |record| の <a>data</a> の型が {{BufferSource}} の場合、
                            <ol>
                                <li>
                                    |arrayBuffer| を |record| の <a>data</a> に設定します。
                                </li>
                                <li>
                                    |length:unsigned long| を |arrayBuffer|.[[\ArrayBufferByteLength]] に設定します。
                                </li>
                                <li>
                                    |data:byte sequence| を |arrayBuffer|.[[\ArrayBufferData]] に設定します。
                                </li>
                                <li>
                                    |ndef| の <a>PAYLOAD LENGTH field</a> を |length| に設定します。
                                </li>
                                <li>
                                    |length| > `0` の場合、|ndef| の <a>PAYLOAD field</a> を |data| に設定します。
                                </li>
                            </ol>
                        </li>
                        <li>
                            |record| の <a>data</a> の型が {{NDEFMessageInit}} の場合、
                            <ol>
                                <li>
                                    |ndef| の <a>PAYLOAD field</a> を、
                                    |record| の <a>data</a>、`"local"`、|recordsDepth| を与えた
                                    <a>create NDEF message</a> を実行した結果に設定します。
                                </li>
                                <li>
                                    |ndef| の <a>PAYLOAD LENGTH field</a> を、
                                    |ndef| の <a>PAYLOAD field</a> の長さに設定します。
                                </li>
                            </ol>
                        </li>
                        <li>
                            |ndef| を返します。
                        </li>
                    </ol>
                </div>
            </section>

            <section>
                <h3>スマートポスターから NDEF へのマッピング</h3>
                <div>
                    |record:NDEFRecordInit|、|ndef|、|recordsDepth:unsigned short| を与えて
                    <dfn>map smart poster to NDEF</dfn> するには、次の手順を実行します:
                    <ol class=algorithm data-link-for="NDEFRecordInit">
                        <li>
                            |record| の <a>mediaType</a> が undefined でない場合、{{TypeError}} を
                            [= exception/throw =] します。
                        </li>
                        <li>
                            |record| の <a>data</a> の型が {{NDEFMessageInit}} でない場合、
                            {{TypeError}} を [= exception/throw =] します。
                        </li>
                        <li>
                            |ndef| の <a>TNF field</a> を `1`（[=well-known type record=]）に設定します。
                        </li>
                        <li>
                            |ndef| の <a>TYPE field</a> を "`Sp`"（`0x53` `0x70`）に設定します。
                        </li>
                        <li>
                            |ndef| の <a>PAYLOAD field</a> を、|record| の <a>data</a>、`"smart-poster"`、
                            |recordsDepth| を与えた <a>create NDEF message</a> を実行した結果に設定します。
                        </li>
                        <li>
                            |ndef| の <a>PAYLOAD LENGTH field</a> を、|ndef| の <a>PAYLOAD field</a> の長さに設定します。
                        </li>
                        <li>
                            |ndef| を返します。
                        </li>
                    </ol>
                </div>
            </section>

            <section>
                <h3>absolute-URL から NDEF へのマッピング</h3>
                <div>
                    |record:NDEFRecordInit|、|ndef|、|context:string| を与えて
                    <dfn>map absolute-URL to NDEF</dfn> するには、次の手順を実行します:
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            |context| が `"smart-poster"` の場合、{{TypeError}} を [= exception/throw =] します。
                            <p class="note">
                                [[NDEF-SMARTPOSTER]] 仕様では <a>smart poster</a> 内の URL は 1 つのみ許可され、
                                それは単一の <a>URI record</a> でなければなりません。
                            </p>
                        </li>
                        <li>
                            |record| の <a>mediaType</a> が undefined でない場合、{{TypeError}} を
                            [= exception/throw =] します。
                        </li>
                        <li>
                            |record| の <a>data</a> が {{DOMString}} でない場合、{{TypeError}} を
                            [= exception/throw =] します。
                        </li>
                        <li>
                            |record| の <a>data</a> を <a data-lt="url parser">parsing</a> した結果が failure の場合、
                            {{SyntaxError}} を [= exception/throw =] します。
                        </li>
                        <li>
                            |arrayBuffer| を |record| の <a>data</a> に設定します。
                        </li>
                        <li>
                            |data:byte sequence| を |arrayBuffer|.[[\ArrayBufferData]] に設定します。
                        </li>
                        <li>
                            |ndef| の <a>TNF field</a> を `3`（[=absolute-URL record=]）に設定します。
                        </li>
                        <li>
                            |ndef| の <a>TYPE field</a> を |data| に設定します。
                        </li>
                        <li>
                            |ndef| の <a>PAYLOAD LENGTH field</a> を `0` に設定し、<a>PAYLOAD field</a> を省略します。
                        </li>
                        <li>
                            |ndef| を返します。
                        </li>
                    </ol>
                </div>
            </section>
        </section>

        <section id="making-content-read-only">
            <h3><dfn>Making content read-only</dfn></h3>
            <p>
                本セクションは、近接範囲内にあるときに <a>NFC tag</a> を恒久的に読み取り専用にする方法を説明します。
                任意の時点で、<a>NFC tag</a> が恒久的に読み取り専用にされるか操作が中止されるまで、
                1 つの <a>origin</a> につきリクエストは最大 1 件です。
            </p>
            <section>
                <h3><strong>makeReadOnly()</strong> メソッド</h3>
                <div id="steps-make-read-only">
                    <dfn>NDEFReader.makeReadOnly</dfn> メソッドは、呼び出されたとき、
                    <dfn>make an NFC tag permanently read-only</dfn> アルゴリズムを実行しなければなりません:
                    <ol class=algorithm>
                        <li>
                            |p:Promise| を新しい {{Promise}} オブジェクトとします。
                        </li>
                        <li>
                            現在アクティブな <a>top-level browsing context</a> で実行していない場合、|p| を
                            {{"InvalidStateError"}} で reject して |p| を返します。
                        </li>
                        <li>
                            |options:NDEFMakeReadOnlyOptions| を第 2 引数とします。
                        </li>
                        <li>
                            |signal:AbortSignal| を、存在すれば |options| の同名の辞書メンバー、そうでなければ null とします。
                        </li>
                        <li>
                            |signal| が [= AbortSignal/aborted =] の場合、|signal| の [=AbortSignal/abort reason=] で |p| を
                            reject し、|p| を返します。
                        </li>
                        <li>
                            |signal| が null でない場合、|signal| に
                            <a data-cite="dom#abortsignal-abort-algorithms">
                                次の中止手順</a>を追加します:
                            <ol>
                                <li>
                                    <a>environment settings object</a> 上で
                                    <a>abort a pending make read-only operation</a> を実行します。
                                </li>
                            </ol>
                        </li>
                        <li>
                            [=promise/React=] to |p|:
                            <ol>
                                <li>
                                    |p| が settle（fulfill または reject）された場合、存在すれば
                                    <a>pending write tuple</a> をクリアします。
                                </li>
                            </ol>
                        </li>
                        <li>
                            |p| を返し、次の手順を<a>in parallel</a> に実行します:
                            <ol>
                                <li>
                                    <a>obtain permission</a> が false を返す場合、|p| を {{"NotAllowedError"}} で
                                    reject し、これらの手順を中止します。
                                </li>
                                <li>
                                    基盤となる <a>NFC Adapter</a> が存在しない、または接続を確立できない場合、
                                    |p| を {{"NotSupportedError"}}
                                    で reject し、これらの手順を中止します。
                                </li>
                                <li>
                                    UA が基盤の <a>NFC Adapter</a> にアクセスすることを許可されていない場合（例: ユーザー設定）、
                                    |p| を {{"NotReadableError"}}
                                    で reject し、これらの手順を中止します。
                                </li>
                                <li>
                                    実装は |p| を {{"NotSupportedError"}}
                                    で reject してもよく、これらの手順を中止してもかまいません（MAY）。
                                    <p class="note">
                                        UA はこの地点で中止することがあります。終了の理由は実装詳細です。
                                        例えば、実装が要求された操作をサポートできない場合があります。
                                    </p>
                                </li>
                                <li>
                                    <a>abort a pending make read-only operation</a> を試みます。
                                    <p class="note">
                                        読み取り専用化操作は、それまでに構成された読み取り専用化操作をすべて置き換えます。
                                    </p>
                                </li>
                                <li>
                                    <a>pending makeReadOnly tuple</a> を (`this`, |p|) に設定します。
                                </li>
                                <li>
                                    <a>NFC tag</a> |device| が通信範囲に入ったときはいつでも、
                                    <a>start the NFC make read-only</a> の手順を実行します。
                                    <p class="note">
                                        <a>NFC is suspended</a> の場合、ユーザーによって promise が中止されるか、
                                        <a>NFC tag</a> が通信範囲に入るまで待機を続けます。
                                    </p>
                                </li>
                            </ol>
                        </li>
                        </li>
                    </ol>
                </div>

                <div id="steps-start-nfc-make-read-only">
                    <dfn>start the NFC make read-only</dfn> するには、次の手順を実行します:
                    <ol class=algorithm>
                        <li>
                            |p:Promise| を <a>pending makeReadOnly tuple</a> の promise とします。
                        </li>
                        <li>
                            近接範囲の <a>NFC tag</a> がフォーマットのための <a>NDEF</a> 技術を公開しない場合、
                            |p| を {{"NotSupportedError"}} で reject して |p| を返します。
                        </li>
                        <li>
                            <a href="#nfc-is-suspended">NFC is not suspended</a> であることを検証します。
                        </li>
                        <li>
                            成功した場合、次を実行します:
                            <ol>
                                <li>
                                    通信範囲内の <a>NFC adapter</a> を用いて、|device| を恒久的に読み取り専用にします。
                                </li <li>
                                操作が失敗した場合、|p| を {{"NetworkError"}}
                                で reject し、これらの手順を中止します。
                        </li>
                        <li>
                            操作が完了したら、|p| を resolve します。
                        </li>
                        <p class="note">
                            この操作は一方向であり、元に戻すことはできません。
                            一度 NFC タグを読み取り専用にすると、以後書き込みはできません。
                        </p>
                    </ol>
                    </li>
                    </ol>
                </div>
            </section>
        </section> <!-- making-content-read-only content -->

        <section>
            <h3>コンテンツのリッスン</h3>
            <p>
                <a>NFC content</a> をリッスンするには、クライアントは <a>NDEFReader.scan()</a> を呼び出して
                {{NDEFReader}} インスタンスをアクティブ化しなければなりません（MUST）。
                その上で "`reading`" イベントのイベントリスナをアタッチすると、<a>NFC content</a> にアクセスできます。
            </p>
            <p>
                <a>activated reader objects</a> に任意の {{NDEFReader}} インスタンスが存在する場合、
                <a>UA</a> は接続されたすべての NFC アダプタで <a>NDEF message</a> をリッスンしなければなりません（MUST）。
            </p>

            <section>
                <h3><strong>scan()</strong> メソッド</h3>
                <p>
                    受信する <a>NFC content</a> は {{NDEFReader}} インスタンスで照合されます。
                </p>
                <div>
                    <dfn>NDEFReader.scan</dfn> メソッドが呼び出されたとき、UA は次の
                    <dfn id="steps-listen">NFC listen algorithm</dfn> を実行しなければなりません（MUST）:
                    <ol class=algorithm>
                        <li>
                            |p:Promise| を新しい {{Promise}} オブジェクトとします。
                        </li>
                        <li>
                            現在アクティブな <a>top-level browsing context</a> で実行していない場合、|p| を
                            {{"InvalidStateError"}} で reject して |p| を返します。
                        </li>
                        <li>
                            |reader:NDEFReader| を {{NDEFReader}} インスタンスとします。
                        </li>
                        <li>
                            |options| を第 1 引数とします。
                        </li>
                        <li>
                            |signal:AbortSignal| を、存在すれば |options| の同名の辞書メンバー、そうでなければ null とします。
                        </li>
                        <li>
                            |signal| が [= AbortSignal/aborted =] の場合、|signal| の [=AbortSignal/abort reason=] で |p| を
                            reject し、|p| を返します。
                        </li>
                        <li>
                            |signal| が null でない場合、|signal| に
                            <a data-cite="dom#abortsignal-abort-algorithms">
                                次の <dfn>clean up the pending scan</dfn> 手順</a>を追加します:
                            <ol>
                                <li>
                                    |reader| を <a>activated reader objects</a> から削除します。
                                </li>
                                <li>
                                    <a>activated reader objects</a> が [= list/is empty =] の場合、
                                    すべての <a>NFC adapter</a> 上で <a>NDEF message</a> のリッスンを停止する要求を行います。
                                </li>
                            </ol>
                        </li>
                        <li>
                            |p| を返し、次の手順を<a>in parallel</a> に実行します:
                            <ol>
                                <li>
                                    <a>obtain permission</a> が false を返す場合、|p| を {{"NotAllowedError"}} で
                                    reject し、これらの手順を中止します。
                                </li>
                                <li>
                                    基盤となる <a>NFC Adapter</a> が存在しない、または接続を確立できない場合、
                                    |p| を {{"NotSupportedError"}}
                                    で reject し、これらの手順を中止します。
                                </li>
                                <li>
                                    UA が基盤の <a>NFC Adapter</a> にアクセスすることを許可されていない場合（例: ユーザー設定）、
                                    |p| を {{"NotReadableError"}}
                                    で reject し、これらの手順を中止します。
                                </li>
                                <li>
                                    |reader| がすでに <a>activated reader objects</a> に存在する場合、
                                    |p| を {{"InvalidStateError"}}
                                    で reject し、これらの手順を中止します。
                                </li>
                                <li>
                                    |reader| を <a>activated reader objects</a> に追加します。
                                </li>
                                <li>
                                    |p| を resolve します。
                                </li>
                                <li>
                                    <a>UA</a> が NFC 技術を検出するたびに、<a>NFC reading algorithm</a> を実行します。
                                </li>
                            </ol>
                        </li>
                    </ol>
                </div>
            </section>

            <section>
                <h3>NFC 読み取りアルゴリズム</h3>
                <a>NDEF</a> コンテンツを受信するには、<dfn>NFC reading algorithm</dfn> を実行します:
                <ol class=algorithm id="parse-ndef">
                    <li>
                        <a>NFC is suspended</a> の場合、これらの手順を中止します。
                    </li>
                    <li>
                        近接範囲の <a>NFC tag</a> が読み取りまたはフォーマットのための <a>NDEF</a> 技術を公開しない場合、
                        次のサブ手順を実行します:
                        <ol>
                            <li>[= list/For each =]
                                <a>activated reader objects</a> 内の {{NDEFReader}} インスタンス
                                |reader:NDEFReader| について、次のサブ手順を実行します:
                                <ol>
                                    <li>
                                        |reader| に対して "`readingerror`" という名前の <a>Fire an event</a> を実行します。
                                    </li>
                                </ol>
                            </li>
                            <li>
                                これらの手順を中止します。
                            </li>
                        </ol>
                    </li>
                    <li>
                        |serialNumber:serialNumber| を、デバイス識別子（数値の並び）または、利用不可の場合は null とします。
                    </li>
                    <li>
                        |serialNumber| が null でない場合、同じ順序で各数値を
                        <a>ASCII hex digit</a> で表現し、U+003A（`:`）で連結した <a>string</a> に設定します。
                    </li>
                    <li>
                        |message:NDEFMessage| を新しい <a>NDEFMessage</a> オブジェクトとし、|message| の records を空の
                        <a>list</a> に設定します。
                    </li>
                    <li>
                        近接範囲の <a>NFC tag</a> が未フォーマットで NDEF フォーマット可能な場合、|input| を null とします。
                        それ以外の場合、受信した <a>NDEF message</a> の表記を |input| とします。
                        <p class="note">
                            UA は未フォーマットの <a>NFC tag</a> を、<a>NDEF record</a> を含まない
                            <a>NDEF message</a> として（すなわち {{NDEFMessage/records}} プロパティが空配列）表現するべきです（SHOULD）。
                        </p>
                    </li>
                    <li>
                        |input| の一部である [= list/For each =] <a>NDEF record</a> について、次のサブ手順を実行します:
                        <ol>
                            <li>
                                |ndef| を現在の <a>NDEF record</a> の表記とし、
                                |typeNameField:number| を <a>TNF field</a> に対応する値、
                                |payload:byte sequence| を <a>PAYLOAD field</a> データに対応する値とします。
                            </li>
                            <li>
                                |record:NDEFRecord| を、|ndef| と `""` を与えて <a>parse an NDEF record</a> を実行した結果とします。
                            </li>
                            <li>
                                |record| が null でない場合、|message| の records に |record| を<a>append</a> します。
                            </li>
                        </ol>
                    </li>
                    <li>
                        与えられた |serialNumber| と |message| で <a>dispatch NFC content</a> の手順を実行します。
                    </li>
                </ol>
            </section>

            <section data-link-for="NDEFReadingEvent">
                <h3>NFC コンテンツのディスパッチ</h3>
                <p>
                    型 <a>serialNumber</a> の |serialNumber:serialNumber| と、型 <a>NDEFMessage</a> の
                    |message:NDEFMessage| を与えて <dfn>dispatch NFC content</dfn> するには、次の手順を実行します:
                </p>
                <ol class=algorithm>
                    <li>
                        [= list/For each =] <a>activated reader objects</a> 内の {{NDEFReader}} インスタンス
                        |reader:NDEFReader| について、
                        <ol>
                            <li>
                                |reader| に対して、<a>NDEFReadingEvent</a> を用い、
                                その <a>serialNumber</a> 属性を |serialNumber| に、
                                その <a>message</a> 属性を |message| に初期化して、
                                "`reading`" という名前の <a>fire an event</a> を実行します。
                            </li>
                        </ol>
                    </li>
                </ol>
            </section>
        </section>

        <section id="steps-receiving">
            <h3>コンテンツのパース</h3>

            <section>
                <h3>バイト列からのレコードのパース</h3>
                |bytes:byte sequence| および |context: string| を与えて
                <dfn>parse records from bytes</dfn> するには、次の手順を実行します:
                <ol class=algorithm>
                    <li>
                        |bytes| の長さが `0` の場合、null を返します。
                    </li>
                    <li>
                        |records| を空のリストとします。
                    </li>
                    <li>
                        |bytes| に未読のバイトがある限り、次のサブ手順を実行します:
                        <ol>
                            <li>
                                残りの |bytes| の長さが `3` 未満の場合、null を返します。
                            </li>
                            <li>
                                以降のいずれかのステップで残りの |bytes| の長さを超えて読み取る必要がある場合、null を返します。
                            </li>
                            <li>
                                |ndef| を現在の <a>NDEF record</a> の表記とします。
                            </li>
                            <li>
                                |header:byte| を |bytes| の次のバイトとします。
                                <ol>
                                    <li>
                                        |messageBegin:boolean|（<a>MB field</a>）を |header| の最上位ビット（ビット 7）とします。
                                    </li>
                                    <li>
                                        これがこれらのサブ手順の最初の反復で、かつ |messageBegin| が false の場合、null を返します。
                                    </li>
                                    <li>
                                        |messageEnd:boolean|（<a>ME field</a>）を |header| のビット 6 とします。
                                    </li>
                                    <p class=note>
                                        チャンク化されたレコードはサブレコードとして許可されないため、ビット 5（<a>CF field</a>）は無視します。
                                    </p>
                                    <li>
                                        |shortRecord:boolean|（<a>SR field</a>）を |header| のビット 4 とします。
                                    </li>
                                    <li>
                                        |hasIdLength:boolean|（<a>IL field</a>）を |header| のビット 3 とします。
                                    </li>
                                    <li>
                                        |ndef| の |typeNameField:number|（<a>TNF field</a>）を |header| のビット 2〜0 の整数値とします。
                                    </li>
                                </ol>
                            </li>
                            <li>
                                |typeLength:number| を |bytes| の次のバイト（<a>TYPE LENGTH field</a>）の整数値とします。
                            </li>
                            <li>
                                |shortRecord| が true の場合、|payloadLength:number| を |bytes| の次のバイト
                                （<a>PAYLOAD LENGTH field</a>）の整数値とします。
                            </li>
                            <li>
                                それ以外の場合、|payloadLength| を |bytes| の次の 4 バイトの整数値とします。
                            </li>
                            <li>
                                |hasIdLength| が true の場合、|idLength:number| を |bytes| の次のバイト
                                （<a>ID LENGTH field</a>）の整数値とし、そうでなければ `0` とします。
                            </li>
                            <li>
                                |typeLength| > 0 の場合、|ndef| の |type:string| を、次の |typeLength| バイト
                                （<a>TYPE field</a>）に対して <a>UTF-8 decode</a> を実行した結果とし、
                                そうでなければ |type| を空文字列とします。
                            </li>
                            <li>
                                |idLength| > 0 の場合、|ndef| の |id:string| を、次の |idLength| バイト
                                （<a>ID field</a>）に対して <a>UTF-8 decode</a> を実行した結果とし、
                                そうでなければ |ndef| の |id| を空文字列とします。
                            </li>
                            <li>
                                |ndef| の |payload| を、最後の |payloadLength| バイト
                                （<a>PAYLOAD field</a>）の <a>byte sequence</a> とし、`0` バイトであってもよいものとします。
                            </li>
                            <li>
                                |record:NDEFRecord| を、|ndef| と |context| を与えて
                                <a>parse an NDEF record</a> を実行した結果とします。
                            </li>
                            <li>
                                |record| が null でない場合、|records| に |record| を<a>append</a> します。
                            </li>
                            <li>
                                |messageEnd| が true の場合、
                                <ol>
                                    <li>
                                        |records| と |context| を与えて <a>check parsed records</a> を実行し、
                                        |error| を投げた場合、|promise| を |error| で reject し、これらの手順を中止します。
                                    </li>
                                    <li>
                                        それ以外の場合、これらのサブ手順を終了します（ループを終了）。
                                    </li>
                                </ol>
                            </li>
                        </ol>
                    </li>
                    <li>
                        |records| を返します。
                    </li>
                </ol>
            </section>

            <section>
                <h3>パース済みレコードの検査</h3>
                |records: NDEFRecord sequence| および |context: string| を与えて
                <dfn>check parsed records</dfn> するには、次の手順を実行します:
                <ol class=algorithm>
                    <li>
                        |context| が `"smart-poster"` で、|records| がちょうど 1 つの <a>URI record</a> を含まない場合、
                        または複数の <a>type record</a>、<a>size record</a>、<a>action record</a> を含む場合、
                        {{TypeError}} を [= exception/throw =] します。
                    </li>
                    <!--
      <li>
        If |context| is `"smart-poster"` and |records| contain
        [=absolute-URL records=], remove them from |records|.
        <p class="note">
          In other words, remove [=absolute-URL records=] from <a>smart poster</a>,
          as required by the [[NDEF-SMARTPOSTER]] specification.
        </p>
      </li>
      <li>
        If any record in |records| is a <a>smart poster</a>, then remove
        all <a>URI records</a> and [=absolute-URL records=] from |records|.
        <p class="note">
          In other words, remove [=absolute-URL records=] and <a>URI records</a>
          from <a>NDEF messages</a> that contain a <a>smart poster</a> record,
          as required by the [[NDEF-SMARTPOSTER]] specification.
        </p>
      </li>
      -->
                    <li>
                        それ以外の場合は true を返します。
                    </li>
                </ol>
            </section>

            <section>
                <h3>NDEF レコードのパース</h3>
                <div>
                    |ndef| および |context:string| を与えて <dfn>parse an NDEF record</dfn> を
                    |record:NDEFRecord| に行うには、次の手順を実行します:
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            |record| の <a>id</a> を |ndef| の |id:string| に設定します。
                        </li>
                        <li>
                            |record| の <a>lang</a> を null に設定します。
                        </li>
                        <li>
                            |record| の <a>encoding</a> を null に設定します。
                        </li>
                        <li>
                            |ndef| の |typeNameField:number|（<a>TNF field</a>）が `0`（<a>empty record</a>）の場合:
                            <ol>
                                <li>
                                    |record| の <a>id</a> を null に設定します。
                                </li>
                                <li>
                                    |record| の <a>recordType</a> を "`empty`" に設定します。
                                </li>
                                <li>
                                    |record| の <a>mediaType</a> を null に設定します。
                                </li>
                                <li>
                                    |record| の <a>data</a> を null に設定します。
                                </li>
                            </ol>
                        </li>
                        <li>
                            |ndef| の |typeNameField| が `1`（[=well-known type record=]）の場合:
                            <ol>
                                <li>
                                    |ndef| の |type:string| が <strong>"`T`"（`0x54`）</strong> の場合、
                                    |record| を |ndef| に対して <a>parse an NDEF text record</a> を実行した結果に設定します。
                                </li>
                                <li>
                                    |ndef| の |type:string| が <strong>"`U`"（`0x55`）</strong> の場合、
                                    |record| を |ndef| に対して <a>parse an NDEF URL record</a> を実行した結果に設定します。
                                </li>
                                <li>
                                    |ndef| の |type:string| が <strong>"`Sp`"（`0x53` `0x70`）</strong> の場合、
                                    |record| を |ndef| に対して <a>parse an NDEF smart-poster record</a> を実行した結果に設定します。
                                </li>
                                <li>
                                    |ndef| の |type:string| が <strong>"`s`"（`0x73`）</strong> で、
                                    |context| が `"smart-poster"` と等しい場合、
                                    |record| を |ndef| に対して <a>parse a smart-poster size record</a> を実行した結果に設定します。
                                </li>
                                <li>
                                    |ndef| の |type:string| が <strong>"`t`"（`0x74`）</strong> で、
                                    |context| が `"smart-poster"` と等しい場合、
                                    |record| を |ndef| に対して <a>parse a smart-poster type record</a> を実行した結果に設定します。
                                </li>
                                <li>
                                    |ndef| の |type:string| が <strong>"`act`"（`0x61` `0x63` `0x74`）
                                    </strong> で、|context| が `"smart-poster"` と等しい場合、
                                    |record| を |ndef| に対して <a>parse a smart-poster action record</a> を実行した結果に設定します。
                                </li>
                                <li>
                                    |ndef| の |type:string| に対して <a>validate local type</a> を実行して
                                    true を返す場合、
                                    <ol>
                                        <li>
                                            |context| が `"external"` または `"smart-poster"` でない場合、
                                            {{TypeError}} を [= exception/throw =] します。
                                        </li>
                                        <li>
                                            |record| を |ndef| に対して <a>parse a local type record</a> を実行した結果に設定します。
                                        </li>
                                    </ol>
                                </li>
                                <li>
                                    それ以外の場合、{{TypeError}} を [= exception/throw =] します。
                                </li>
                            </ol>
                        </li>
                        <li>
                            |ndef| の |typeNameField| が `2`（<a>MIME type record</a>）の場合、
                            |record| を |ndef| に対して <a>parse an NDEF MIME type record</a> を実行した結果に設定するか、
                            基盤プラットフォームが |record| オブジェクトのプロパティに等価な値を提供することを確実にします。
                        </li>
                        <li>
                            |ndef| の |typeNameField| が `3`（<a>absolute-URL record</a>）の場合、
                            |record| を |ndef| に対して <a>parse an NDEF absolute-URL record</a> を実行した結果に設定します。
                        </li>
                        <li>
                            |ndef| の |typeNameField| が `4`（<a>external type record</a>）の場合、
                            |record| を |ndef| に対して <a>parse an NDEF external type record</a> を実行した結果に設定するか、
                            基盤プラットフォームが |record| オブジェクトのプロパティに等価な値を提供することを確実にします。
                        </li>
                        <li>
                            |ndef| の |typeNameField| が `5`（<a>unknown record</a>）の場合、
                            |record| を |ndef| に対して <a>parse an NDEF unknown record</a> を実行した結果に設定するか、
                            基盤プラットフォームが |record| オブジェクトのプロパティに等価な値を提供することを確実にします。
                        </li>
                        <li>
                            それ以外の場合、{{TypeError}} を [= exception/throw =] します。
                        </li>
                    </ol>
                </div>
            </section>

            <section>
                <h3>NDEF well-known `T` レコードのパース</h3>
                <div>
                    |ndefRecord| を与えて <dfn>parse an NDEF text record</dfn> を |record:NDEFRecord| に行うには、
                    次の手順を実行します:
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            |record| の <a>recordType</a> を "`text`" に設定します。
                        </li>
                        <li>
                            |record| の <a>mediaType</a> を null に設定します。
                        </li>
                        <li>
                            |ndefRecord| の <a>PAYLOAD field</a> が存在しない場合、
                            |record| の <a>data</a> を null に設定して |record| を返します。
                        </li>
                        <li>
                            |header:byte| を |ndefRecord| の <a>PAYLOAD field</a> の最初の <a>byte</a> とします。
                        </li>
                        <li>
                            |languageLength:octet| を、|header| のビット `5` からビット `0` の値とします。
                        </li>
                        <li>
                            |language:string| を、2 バイト目から |languageLength| + `1` バイト目までを
                            <a>ASCII decode</a> した結果とします。
                        </li>
                        <li>
                            |buffer:byte sequence| を、|ndefRecords| の <a>PAYLOAD field</a> の残り
                            （|header| と |languageLength| バイト分を除く）の <a>byte sequence</a> とします。
                        </li>
                        <li>
                            |record| の <a>lang</a> を |language| に設定します。
                        </li>
                        <li>
                            |record| の <a>encoding</a> を、|header| のビット `7` が `0` の場合は "`utf-8`"、
                            それ以外は "`utf-16be`" に設定します。
                        </li>
                        <li>
                            |record| の <a>data</a> を |buffer| に設定します。
                        </li>
                        <li>
                            |record| を返します。
                        </li>
                    </ol> <!-- parsing NDEF text record -->
                </div>
                <aside class="note" data-link-for="NDEFRecord">
                    <p>
                        Unicode 標準は UTF-8、UTF-16、UTF-32 など複数のエンコーディングを定義しています。
                        UTF-8 はウェブで推奨されるエンコーディングであり、[=code points=] が単一バイトで表現されるため、
                        エンディアンに依存しない利点があります。
                    </p>
                    <p>
                        NDEF のテキストレコードは、テキストを UTF-8 または UTF-16 のいずれかでエンコードできます。
                        一般にウェブでは UTF-8 の使用が推奨されますが、既存システムとの統合のために UTF-16 が必要な場合もあります。
                    </p>
                    <p>
                        データ伝送順序、すなわち NDEF のバイトオーダは [[[NFC-NDEF]]] でビッグエンディアン（BE）と定義されており、
                        すべてがビッグエンディアンのバイト順序で読み戻されます。
                    </p>
                    <p>
                        UTF-16 の場合、各 [=code point=] が 2 バイトにまたがるため、読み書き間でバイト順序が異なる可能性があり、
                        バイト順序は重要です。このため UTF-16 でエンコードされたテキストには通常バイトオーダマーク（BOM、`0xFEFF`）が含まれます。
                        ホストマシンと NDEF でバイト順序が異なる場合、値は `0xFFFE` として読み戻され、
                        バイト順序を入れ替える必要があることを示します。[[[ENCODING]]] ではバイト順序に応じて
                        UTF-16 を UTF-16BE（ビッグエンディアン）と UTF-16LE（リトルエンディアン）に区別します。
                    </p>
                    <p>
                        バイトオーダマークが存在しない場合は、UTF-16BE エンコーディングを仮定すべきです。
                    </p>
                    <p>
                        <a data-cite="encoding#decoder">decoder</a> を `encoding` を `utf-16` に設定して使用すると、
                        バイトオーダマークが存在する場合に自動的にバイトの入れ替えを検出します。
                        バイトオーダマークがない場合にビッグエンディアンとして読み取るには `utf-16be` を使用できます。
                    </p>
                    <p>
                        <a data-cite="encoding#encoder">encoder</a> を使用する場合、UTF-8 にのみエンコード可能です。
                        したがって UTF-16 が必要な場合は、手動で、またはライブラリを用いてエンコードする必要があります。
                    </p>
                </aside>
            </section>

            <section>
                <h3>NDEF well-known `U` レコードのパース</h3>
                <div>
                    |ndefRecord| を与えて <dfn>parse an NDEF URL record</dfn> を |record:NDEFRecord| に行うには、
                    次の手順を実行します:
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            |record| の <a>recordType</a> を "`url`" に設定します。
                        </li>
                        <li>
                            |record| の <a>mediaType</a> を null に設定します。
                        </li>
                        <li>
                            |ndefRecord| の <a>PAYLOAD field</a> が存在しない場合、
                            |record| の <a>data</a> を null に設定して |record| を返します。
                        </li>
                        <li>
                            |buffer:byte sequence| を、|ndefRecords| の <a>PAYLOAD field</a> の
                            <a>byte sequence</a> とします。
                        </li>
                        <li>
                            |prefixByte:byte| を、|buffer| の最初の <a>byte</a> の値とします。
                        </li>
                        <li>
                            |prefixByte| の値が [[[NFC-STANDARDS]]] の URI Record Type Definition 仕様
                            セクション 3.2.2 表 3 の URL 展開コードに一致する場合、
                            <ol>
                                <li>
                                    |prefixString:string| を、|prefixByte| の値に対応する
                                    <a>byte sequence</a> の値とします。
                                </li>
                                <li>
                                    |record| の <a>data</a> を、|prefixString| に |buffer| を連結したものに設定します。
                                </li>
                            </ol>
                        </li>
                        <li>
                            それ以外で |prefixByte| に一致がない場合、|record| の <a>data</a> を |buffer| に設定します。
                        </li>
                        <li>
                            |record| を返します。
                        </li>
                    </ol> <!-- parsing NDEF URL record -->
                </div>
            </section>

            <section>
                <h3>NDEF well-known `Sp` レコードのパース</h3>
                <div>
                    |ndefRecord| を与えて <dfn>parse an NDEF smart-poster record</dfn> を |record:NDEFRecord| に行うには、
                    次の手順を実行します:
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            |record| の <a>recordType</a> を "`smart-poster`" に設定します。
                        </li>
                        <li>
                            |record| の <a>mediaType</a> を null に設定します。
                        </li>
                        <li>
                            |ndefRecord| の <a>PAYLOAD field</a> が存在しない場合、
                            |record| の <a>data</a> を null に設定して |record| を返します。
                        </li>
                        <li>
                            |buffer:byte sequence| を、|ndefRecords| の <a>PAYLOAD field</a> の
                            <a>byte sequence</a> とします。
                        </li>
                        <li>
                            |record| の <a>data</a> を |buffer| に設定します。
                        </li>
                        <li>
                            |record| を返します。
                            <p class="note">
                                アプリケーションは <a>data</a> に対して <code>toRecords()</code> を呼び出して
                                <a>NDEF records</a> にパースするか、自身でパースしてもかまいません。
                            </p>
                        </li>
                    </ol> <!-- parsing NDEF smart-poster record -->
                </div>
                <div>
                    |ndefRecord| を与えて <dfn>parse a smart-poster size record</dfn> を |record:NDEFRecord| に行うには、
                    次の手順を実行します:
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            |record| の <a>recordType</a> を "`:s`" に設定します。
                        </li>
                        <li>
                            |record| の <a>mediaType</a> を null に設定します。
                        </li>
                        <li>
                            |ndefRecord| の <a>PAYLOAD field</a> がちょうど 4 バイトでない場合、
                            {{TypeError}} を [= exception/throw =] します。
                        </li>
                        <li>
                            |buffer:byte sequence| を、|ndefRecords| の <a>PAYLOAD field</a> の
                            <a>byte sequence</a> とします。
                        </li>
                        <li>
                            |record| の <a>data</a> を |buffer| に設定します。
                            <p class="note">
                                アプリケーションはこの値を、<a>smart-poster</a> 内の URI レコードが参照する
                                オブジェクトのサイズを示す 32 ビット符号なし整数としてパースできます。
                            </p>
                        </li>
                        <li>
                            |record| を返します。
                        </li>
                    </ol>
                </div>
                <div>
                    |ndefRecord| を与えて <dfn>parse a smart-poster type record</dfn> を |record:NDEFRecord| に行うには、
                    次の手順を実行します:
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            |record| の <a>recordType</a> を "`:t`" に設定します。
                        </li>
                        <li>
                            |record| の <a>mediaType</a> を null に設定します。
                        </li>
                        <li>
                            |buffer:byte sequence| を、|ndefRecords| の <a>PAYLOAD field</a> の
                            <a>byte sequence</a> とします。
                            <p class="note">
                                アプリケーションはこの値を、<a>smart-poster</a> 内の URI レコードが参照する
                                オブジェクトのメディアタイプを示す [[RFC2048]] メディアタイプを含む文字列としてパースできます。
                            </p>
                        </li>
                        <li>
                            |record| の <a>data</a> を |buffer| に設定します。
                        </li>
                        <li>
                            |record| を返します。
                        </li>
                    </ol>
                </div>
                <div>
                    |ndefRecord| を与えて <dfn>parse a smart-poster action record</dfn> を
                    |record:NDEFRecord| に行うには、次の手順を実行します:
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            |record| の <a>recordType</a> を "`:act`" に設定します。
                        </li>
                        <li>
                            |record| の <a>mediaType</a> を null に設定します。
                        </li>
                        <li>
                            |ndefRecord| の <a>PAYLOAD field</a> がちょうど 1 バイトでない場合、
                            {{TypeError}} を [= exception/throw =] します。
                        </li>
                        <li>
                            |buffer:byte sequence| を、|ndefRecords| の <a>PAYLOAD field</a> の
                            <a>byte sequence</a> とします。
                        </li>
                        <li>
                            |record| の <a>data</a> を |buffer| に設定します。
                            <p class="note">
                                アプリケーションはこの値を 8 ビット符号なし整数としてパースでき、その値は
                                <a href="#dfn-action-record">ここ</a>で定義されています。
                            </p>
                        </li>
                        <li>
                            |record| を返します。
                        </li>
                    </ol>
                </div>
            </section>

            <section>
                <h3>ローカルタイプレコードのパース</h3>
                <div>
                    |ndef| を与えて <dfn>parse a local type record</dfn> を |record:NDEFRecord| に行うには、
                    次の手順を実行します:
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            |record| の <a>recordType</a> を "`:`"（`U+003A`）に |ndef| の |type:string| を連結したものに設定します。
                        </li>
                        <li>
                            |record| の <a>mediaType</a> を null に設定します。
                        </li>
                        <li>
                            |buffer:byte sequence| を、|ndefRecords| の <a>PAYLOAD field</a> の
                            <a>byte sequence</a> とします。
                        </li>
                        <li>
                            |record| の <a>data</a> を |buffer| に設定します。
                        </li>
                        <li>
                            |record| を返します。
                        </li>
                    </ol>
                </div>
            </section>

            <section>
                <h3>NDEF MIME タイプレコードのパース</h3>
                <div>
                    |ndefRecord| を与えて <dfn>parse an NDEF MIME type record</dfn> を |record:NDEFRecord| に行うには、
                    次の手順を実行します:
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            |record| の <a>recordType</a> を "`mime`" に設定します。
                        </li>
                        <li>
                            |record| の <a>mediaType</a> を、|mimeType| を入力として
                            <a>serialize a MIME type</a> を実行した結果に設定します。
                        </li>
                        <li>
                            |buffer:byte sequence| を、存在する場合は |ndefRecords| の <a>PAYLOAD field</a> の
                            <a>byte sequence</a>、そうでなければ null とします。
                        </li>
                        <li>
                            |record| の <a>data</a> を |buffer| に設定します。
                        </li>
                        <li>
                            |record| を返します。
                        </li>
                    </ol> <!-- parsing NDEF MIME type record -->
                </div>
            </section>

            <section>
                <h3>NDEF absolute-URL レコードのパース</h3>
                <div>
                    |ndefRecord| を与えて <dfn>parse an NDEF absolute-URL record</dfn> を
                    |record:NDEFRecord| に行うには、次の手順を実行します:
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            |record| の <a>recordType</a> を "`absolute-url`" に設定します。
                        </li>
                        <li>
                            |record| の <a>mediaType</a> を null に設定します。
                        </li>
                        <li>
                            |buffer:byte sequence| を、|ndefRecords| の <a>TYPE field</a> の
                            <a>byte sequence</a> とします。
                        </li>
                        <li>
                            |record| の <a>data</a> を |buffer| に設定します。
                        </li>
                        <li>
                            |record| を返します。
                        </li>
                    </ol> <!-- parsing NDEF absolute URI record -->
                </div>
            </section>

            <section>
                <h3>NDEF 外部タイプレコードのパース</h3>
                <div>
                    |ndefRecord| を与えて <dfn>parse an NDEF external type record</dfn> を
                    |record:NDEFRecord| に行うには、次の手順を実行します:
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            record の |ndefRecord| の <a>TYPE field</a> に対して [=validate external type=] を実行して
                            false を返す場合、null を返します。
                        </li>
                        <li>
                            |domain| と |type| を、|ndefRecord| の <a>TYPE field</a> の値に対して
                            [=split external type=] を実行した結果とします。
                        </li>
                        <li>
                            |domain| を、
                            <a href="https://www.unicode.org/reports/tr46/#ToUnicode">Unicode ToUnicode</a> を
                            |domain_name| に |domain|、|CheckHyphens| に false、|CheckBidi| に true、
                            |CheckJoiners| に true、|UseSTD3ASCIIRules| に true、|Transitional_Processing| に false を
                            それぞれ設定して実行した結果とします。結果にエラーが含まれる場合、null を返します。
                        </li>
                        <aside class="note">
                            <a>TYPE field</a> には ASCII として保存されたドメイン部分が含まれるため、
                            例えば "xn--hndvrker-9zan.dk:abc" は上記の変換後に "håndværker.dk:abc" として提示されます。
                        </aside>
                        <li>
                            |record| の <a>recordType</a> を、|domain|、"`:`"、|type| を連結したものに設定します。
                        </li>
                        <li>
                            |record| の <a>mediaType</a> を null に設定します。
                        </li>
                        <li>
                            |buffer:byte sequence| を、存在する場合は |ndefRecords| の <a>PAYLOAD field</a> の
                            <a>byte sequence</a>、そうでなければ null とします。
                        </li>
                        <li>
                            |record| の <a>data</a> を |buffer| に設定します。
                        </li>
                        <li>
                            |record| を返します。
                        </li>
                    </ol> <!-- parsing NDEF external type record -->
                </div>
            </section>

            <section>
                <h3>NDEF 不明タイプレコードのパース</h3>
                <div>
                    |ndefRecord| を与えて <dfn>parse an NDEF unknown record</dfn> を |record:NDEFRecord| に行うには、
                    次の手順を実行します:
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            |record| の <a>recordType</a> を "`unknown`" に設定します。
                        </li>
                        <li>
                            |record| の <a>mediaType</a> を null に設定します。
                        </li>
                        <li>
                            |buffer:byte sequence| を、存在する場合は |ndefRecords| の <a>PAYLOAD field</a> の
                            <a>byte sequence</a>、そうでなければ null とします。
                        </li>
                        <li>
                            |record| の <a>data</a> を |buffer| に設定します。
                        </li>
                        <li>
                            |record| を返します。
                        </li>
                    </ol> <!-- parsing NDEF unknown record -->
                </div>
            </section>
        </section>
    </section>

    <!-- - - - - - - - - - - - - - - The Blocklist - - - - - - - - - - - - - - - -->
    <section>
        <h2 id="blocklist">ブロックリスト</h2>
        <p>
            本仕様は、ウェブサイトがアクセスできる NFC デバイスの集合を制限するためにブロックリストファイルに依存します。
        </p>
        <p>
            |url:URL| における <dfn>parsing the blocklist</dfn> の結果は、次のアルゴリズムによって生成される historical bytes の16進値のリストです:
        <ol class=algorithm>
            <li>
                |url:URL| を取得し、その本文を UTF-8 としてデコードしたものを |contents:string| とします。
            </li>
            <li>
                |lines:array| を |contents| を `"\n"` で分割したものとします。
            </li>
            <li>
                |result:list| を空の <a>list</a> とします。
            </li>
            <li>
                |lines| 内の |line:string| について [= list/For each =]、次の副手順を実行します:
                <ol>
                    <li>
                        |line| が空であれば、次の行に進みます。
                    </li>
                    <li>
                        |line| が `"#"` で始まる場合、次の行に進みます。
                    </li>
                    <li>
                        |line| に無効な16進値が含まれる場合、次の行に進みます。
                    </li>
                    <li>
                        <a>Append</a> |line| を |result| に追加します。
                    </li>
            </li>
        </ol>
        </li>
        <li>
            |result| を返します。
        </li>
        </ol> <!-- parsing the blocklist -->
        </p>
        <p>
            <dfn>blocklist</dfn> は、<a
                href="https://github.com/w3c/web-nfc/blob/gh-pages/blocklist.txt">https://github.com/w3c/web-nfc/blob/gh-pages/blocklist.txt</a>
            における
            <a>parsing the blocklist</a> の結果です。UA はブロックリストを定期的に再取得すべきですが、その頻度は規定されていません。
        </p>
        <p>
            <a>NFC device</a> は、<a>blocklist</a> の値にそのデバイスの <a>historical bytes</a> の16進値が含まれている場合、
            <dfn>blocklisted</dfn> とされます。ISO 14443-4 の用語では、<dfn>historical bytes</dfn> は RATS（Request for Answer To
            Select）
            応答の一部集合です。
        </p>
    </section>

    <!-- - - - - - - - - - - - - Security and Privacy - - - - - - - - - - - - - -->
    <section>
        <h2 id="security">セキュリティとプライバシー</h2>
        <section>
            <h3>信頼の連鎖</h3>
            <p>
                実装は、ユーザーが Web NFC API の一部であるメソッドを許可したときに、副作用なくそのアクションのみが実行されることを保証する必要があります。
            </p>
            <p>
                既定では、NDEF は、データを書き込んだ後にタグを恒久的な読み取り専用にできることを除いて、コンテンツを信頼できるようにする手段を提供しません。
                これは工場出荷時設定からでも可能です。
            </p>
            <p>
                この API によって書き込まれるデータは自動的に署名や暗号化はされず、これは既存のネイティブ NFC API に従います。
                NDEF メッセージの完全性と真正性を保護するために、NFC Forum は [[NDEF-SIGNATURE]] を導入しました。
                <a>NDEF signature</a> と鍵管理の使用はアプリケーションの責任です。
            </p>
            <p>
                NFC 経由で交換されるデータの<strong>機密性</strong>を信頼するため、アプリケーションは暗号化された
                <a>NFC content</a> を使用しても構いません。
            </p>
            <p>
                NFC 経由で交換されるデータの<strong>完全性</strong>を信頼するため、アプリケーションは PKI（公開鍵基盤）に基づく鍵管理とともに
                <a>NDEF signature</a> を使用しても構いません。
            </p>
            <p>
                一般的な MIME タイプに関するセキュリティ上の考慮事項は [[RFC2048]] および [[RFC2046]] で議論されています。
            </p>
        </section>
        <section>
            <h3>プライバシーへの影響と実装上の考慮事項</h3>
            <p>
                NFC タグは、バーコードや QR コードと同様に、人間が読めない方法でデータを交換する別の手段であり、それらを共有することは、
                予期しないプライバシーおよびセキュリティ上の影響をもたらす可能性があります。ウェブサイトが QR コードを読み取るには、
                画像を取得して、その画像の内容（QR コードを含む）がウェブページで利用可能になることを明確に示す中断的な UI（カメラ）を
                使用する必要があり、ユーザーにスキャンが行われていることを明確にします。
            </p>
            <p>
                NFC でタグをスキャンするには、ユーザーがスキャンデバイス（例: 携帯電話）を NFC タグに近接（通常 5〜10cm、2〜4 インチ）
                させる必要があります。
            </p>
            <p>
                Web NFC のスキャンがアクティブでないときにタグをスキャンすると、ホスト OS の処理がトリガーされます。
                したがって、NFC タグのスキャンから URL やアプリを起動することは Web NFC 自身では処理もサポートもされません。
            </p>
            <p>
                さらに、Web NFC のスキャンはユーザー操作から有効化される必要があり、サイトがフォーカスされていない場合や
                デバイスの画面が消灯（すなわちロック解除されていない）したときにはスキャンは一時停止されます。
                これは、偶発的なスキャンが起こりにくいようにするためです。
            </p>
            <p>
                Web NFC はさらに、スキャンデバイスを NFC タグに近づけたときにデータがスキャンされることを UX 上ユーザーに非常に明確に示すことを
                実装に推奨します。基本的には QR コードのスキャンの UX フローを模倣します。
            </p>
            <p>
                そのための方法は多数あります。例えば音を鳴らす、スキャン中に永続的な UI を表示する（任意の時点でキャンセルできるモーダルダイアログなど）。
            </p>
            <img class="illustration" src="https://w3c.github.io/web-nfc/images/scan.jpg">
            <p>
                実装は、アップロードしようとしているデータを表示し、ユーザーが承認するまで共有を延期し、どのレコードを共有するかをユーザーが選択できる
                UI を表示することもできます。
            </p>
            <img class="illustration" src="https://w3c.github.io/web-nfc/images/approve.jpg">
            <section>
                <h4>スキャン中の読み取りと書き込み</h4>
                <p>
                    ユーザーがタグをスキャンすると、その時点でウェブアプリケーションはタグ上のデータを読み取るアクセス権を持ち、
                    読み取り専用でない場合はタグにデータを書き込むこともできます。私的利用向けの市販ステッカー（例: メイカーコミュニティ）では
                    しばしばロックされておらず（読み取り＋書き込み）、商用展開の NFC は読み取り専用であるのが一般的です。
                </p>
                <p class="note">
                    以前のプロトコル SNEP（Simple NDEF Exchange Protocol）は、能動デバイス（例: 携帯電話）が別の能動デバイスから
                    NDEF データを受信することを可能にしていましたが、Web NFC ではサポートされておらず、サポートされているネイティブプラットフォームでも
                    現在廃止されつつあります。
                </p>
                <p class="note">
                    より新しいプロトコル TNEP（Tag NDEF Exchange Protocol）は、スキャナデバイス（例: 携帯電話）と能動的に給電された
                    IoT デバイスの間で双方向通信を可能にします。これは現時点では Web NFC でサポートされておらず、また受け入れる入力に制限があり、
                    IoT デバイスは受け付けるレコードが有効であることを保証しなければなりません。
                </p>
                <p>
                    タグがプライバシーに敏感なデータを含む場合、そのようなデータはサイトと共有されます。UX がデータ交換の前にユーザーによる確認を
                    要求する場合は、すぐには共有されない可能性もあります。
                </p>
                <p>
                    場合によっては、タグ／デバイスがプライバシーに敏感なデータを含むことが明らかなこともあります。例えば NFC 対応の会議バッジや
                    名刺の場合です。これは、あなたや近親者が糖尿病患者であることを示しうる、NFC 対応のグルコースメータでも同様です。
                </p>
                <p>
                    他の場合には起こりうることが明確でないかもしれませんが、ユーザーがタグにデータを書き込むアプリやウェブサイトを使用し、
                    ユーザーの知らないうちにユーザー ID などをエンコードしてしまい、その後別のサイトが読み戻せることがあります。
                </p>
                <p>
                    私的で予期しないデータは、ファイル（例: ワープロ文書、PDF、カメラ画像）にも保存され、ファイルアップロード API を使って
                    アップロードされることがあります。Web NFC API に関連する緩和策は、ファイルアップロードに関連するものよりも強力であり、
                    個人を特定できる可能性はより低くなります。
                </p>
            </section>
            <section>
                <h4>スキャン中の読み取りと書き込み</h4>
                <p>
                    タグのスキャンは、ウェブサイトがタグを識別する方法を知っており、かつ現実世界でのタグの位置を知っている場合（例えば博物館内に
                    設置されているなど）、ユーザーの位置を明らかにすることがあります。また、FeliCa NFC タグは主に日本で使用されている等の理由から、
                    ある程度推測できるかもしれませんが、Web NFC は使用されているタグ技術を明らかにはしません。
                </p>
                <p>
                    これは、ユーザーのアクションを必要とし、バックグラウンドでトリガーされないため、ウェブの広告およびトラッキングモデルを
                    現実世界に持ち込むものではありません。適切な UX によって、スキャンがアクティブであることが明確になるべきです。
                </p>
            </section>
            <section>
                <h4>既存データの上書き</h4>
                <p>
                    NFC タグに書き込むとタグを壊してしまう、いわゆる「文鎮化（brick）」してしまうのではないかという懸念もあります。
                    NFC タグは複数のユーザーアプリケーションによって読み取られるように設計されており、NDEF タグは簡単に恒久的な読み取り専用にできるように
                    設計されています。これは工場出荷時の設定でそのように構成することもできます。
                </p>
                <p>
                    NDEF はデータの読み書きのための単純な交換フォーマットであり、双方向通信のためのものではありません。NFC は下位技術に基づく複数の
                    通信フォーマットをサポートしており（そのため NDEF のように読み取り専用にロックされていません）が、これらはいずれも Web NFC では
                    サポートされていません。
                </p>
            </section>
        </section>

        <section>
            <h3>NFC 利用時にユーザーが認識すべき事項</h3>
            <p>
                本節では、NFC の使用時にユーザーが認識すべき事項のいくつかを詳述します。実装は、関連する NFC アクションが実行される前または実行時に、
                これらの事実をユーザーに教育するのを助けることが推奨されます。
            </p>
            <h4>読み取られたデータはサイトと共有される</h4>
            <p>
                サイトが NFC コンテンツを読み取るアクセス権を持っている場合、スキャンされたタグのデータは、ファイルや画像をアップロードする場合と
                同様にサイトと共有されます。どのサイトでも同じですが、そのデータを適切かつ意図した方法で扱うかどうかはユーザーの信頼に委ねられます。
            </p>
            <h4>読み取り専用でないタグのデータはサイトによって変更・上書きされ得る</h4>
            <p>
                店舗内のタグなど、展開された NFC ソリューションは、誤って、または悪意ある行為の一環として変更されないよう、常に読み取り専用に
                すべきです。
            </p>
            <p>
                私用のタグやステッカーは工場出荷時にロック解除（書き込み可能）されていることが多く、そのようなタグはスキャンによって上書き／変更される
                可能性があることをユーザーは認識すべきです。
            </p>
            <h4>固定（例: 設置）タグの読み取りは読み取り位置を露出し得る</h4>
            <p>
                固定タグは、そのデータ内に ID や位置をエンコードしている場合があり、そのため、タグの物理的な位置を把握しているサイトにその情報が
                露出し、読み取りが行われた位置を推定できることがあります。これがサービスへのログインと組み合わさると、あなたの位置情報をサイトと
                共有してしまう可能性があります。
            </p>
            <p>
                書き込まれたデータは、読み取りアクセス権が付与された他のアプリやサイトから読み取れます。
                タグ上の任意の NDEF データは、適切なアクセスを持つ任意のアプリやウェブサイトによって読み取られます。
                その意図がない場合は、想定された読者のみが読み取れるように、データを安全な方法で暗号化すべきです。
            </p>
            <h4>同時に複数のタグが読み取りフィールド内に存在し得る</h4>
            <p>
                NFC は一度に 1 つのタグしか読み取れませんが、複数のタグを検出でき、そのうち 1 つを通信対象のタグとして選択できます。
            </p>
            <p>
                このユースケースは、財布の中に複数のスマートカード（NFC ベース）があり、カードを取り出したくない場合などが考えられます。
            </p>
            <p>
                これは主に外部ハードウェアによって読み取られる決済カードや交通系カードに有用であり、Web NFC のユースケースではありません。
                Web NFC では、以下の攻撃ベクトルを防ぐため、複数のタグが利用可能な場合の読み取りを許可しません。
            </p>
            <p>
                誰かが正規のタグの上に悪意のある NFC タグ／ステッカーを重ねて貼り、誤ったアプリ／サイトを読み込ませたり、
                正しいアプリ／サイトに誤ったデータを注入したりする攻撃ベクトルがあります。これは、元のタグのデータをクローンして変更することで
                実行できます。例えば URL を変更して悪意のあるアプリ／サイトを読み込ませる、あるいは正しいアプリ／サイトに悪意のあるデータを
                注入するなどです。例: タグは本来 <code>https://example.com</code> に誘導するはずが、
                <code>https://exаmple.com</code>（キリル文字の а を使用）に変更される——見た目は正規に見え、
                機微なデータを悪意のあるサイトに渡してしまうかもしれません。
            </p>
            <p>
                タグからウェブサイトを読み込むことは Web NFC の範囲外ですが、上記の攻撃ベクトルのため、複数のタグが利用可能な場合に
                ユーザーエージェントが URL を自動読み込みしないことが推奨されます。
            </p>
            <p>
                複数のタグが利用可能なときに読み取りを禁止することで、Web NFC はサイトへの誤／悪意あるデータ注入に対して十分に保護します。
                既存の NFC タグを遮蔽することは容易ではなく、目立つフェライトシールドが必要となるためです。金属は磁場に干渉し、
                タグを読み取れなくします。
            </p>
        </section>

        <section class="informative">
            <h2>資産</h2>
            <div>
                保護すべき資産には以下が含まれます:
                <ul>
                    <li>
                        <strong>NDEF message</strong> 全体、および特に <strong>NDEF records</strong>（ペイロードとヘッダを含む）。
                        これらが Web NFC によってトリガーされた操作で上書きされる際、転送中または保存中の状態における
                        データ漏えいとデータ改ざんからの保護。
                        これには、NFC タグと連携したソリューションに対するサービス不能（DoS）攻撃（例: ソリューションに紐づくタグを破壊）
                        も含まれます。
                    </li>
                    <li>
                        <strong>ユーザーの識別子やその他のプライバシーに敏感な属性</strong>。
                        これは Web NFC、<a>NFC content</a> の作成者、または Web NFC を使用するウェブサイトによって
                        直接的または間接的に特定され得ます。
                        これらのデータは直接利用されたり、第三者に漏えいされたりする可能性があります。
                        例として、ユーザーの位置、デバイス識別子、ユーザー識別子などが挙げられます。
                    </li>
                    <li>
                        Web NFC を使用するウェブページに公開される<strong>ユーザーデータ</strong>。
                        ウェブページは Web NFC 以外の手段でもユーザーデータを収集し得ますが、このデータを NDEF レコードに
                        埋め込み、Web NFC 経由で共有する可能性があります。
                    </li>
                    <li>
                        <strong>ユーザーデバイスの完全性</strong>。
                        NFC タグの読み取りはユーザーデバイスの侵害を引き起こす可能性があり、さらに他の Web NFC や
                        プラットフォーム資産の損失につながり得ます。
                    </li>
                </ul>
            </div>
        </section>

        <section class="informative">
            <h2>攻撃者モデル</h2>
            <p>
                次の攻撃者パターンが考慮されています:
            <ul>
                <li>
                    <strong>悪意のあるウェブページ作成者</strong>:
                    ユーザーデータ、アイデンティティ、またはその他のプライバシーに敏感な属性のフィッシング、
                    偽の身元や攻撃ベクトルによるさらなる被害を引き起こすための NFC タグの破壊や改ざん。
                </li>
                <li>
                    <strong>悪意のある NFC タグ作成者</strong>:
                    上記と同様だが、NFC タグをローカルで作成・削除・改ざんできる可能性が追加される。
                    その結果、ユーザーデバイスの完全性を損ない、データ注入、悪意のあるウェブページへのリダイレクト、
                    ユーザー位置のフィッシング、アプリのインストールなどの副次的なアクションの誘発、
                    自動ディスパッチやその他のアクションを引き起こし得る。
                </li>
                <li>
                    <strong>侵害されたデバイスまたはユーザーエージェント：中間者（MITM）攻撃</strong>:
                    Web NFC 実装とユーザーデバイス内の <a>NFC adapter</a> の間のあらゆる MITM 形式の攻撃。
                    修正またはリプレイされた NDEF レコードを提示して、Web NFC を使用するウェブサイトとやり取りを試みることを含む。
                </li>
            </ul>
            </p>
        </section>

        <section class="informative">
            <h3>脅威</h3>
            <p>
                NFC セキュリティの概要は <a
                    href="https://resources.infosecinstitute.com/near-field-communication-nfc-technology-vulnerabilities-and-principal-attack-schema/">こちら</a>
                にあります。
                Web NFC に対する潜在的な脅威は以下のとおりです。
            </p>

            <section>
                <h4>フィンガープリンティングとデータ収集</h4>
                <dl>
                    <dt><strong>脅威の説明</strong></dt>
                    <dd>
                        悪意のあるウェブページが、ユーザーの同意なしにユーザーデータ、アイデンティティ、またはその他の
                        プライバシーに敏感な属性（位置情報など）を収集し、それを第三者に公開する（NFC タグに書き込む）こと。
                    </dd>
                    <dt><strong>影響を受ける資産</strong></dt>
                    <dd>
                        ユーザーデータ、ユーザーのアイデンティティ、その他のプライバシーに敏感な属性
                    </dd>
                    <dt><strong>アクター</strong></dt>
                    <dd>
                        Web NFC を使用する悪意のあるウェブページの所有者、悪意のあるタグの所有者。
                    </dd>
                    <dt><strong>緩和策・コメント</strong></dt>
                    <dd>
                        ユーザーは、与えられたウェブページから NFC を使用して共有され得るデータについて把握できるべきです（SHOULD）。
                        個人データへのアクセスには許可とユーザープロンプトを使用し、NFC に公開されるユーザーデータを最小化します。
                        NFC タグが、ユーザーの許可なく、ユーザーのデバイスにウェブサイトへの遷移を引き起こすべきではありません（SHOULD NOT）。
                        サイトがフォアグラウンドにある、またはフォアグラウンドに移されたうえで、許可が付与されている場合を除きます。
                        ユーザーエージェントは、<a href="http://dev.w3.org/geo/api/spec-source.html#security">Geolocation API</a>
                        に列挙された
                        セキュリティとプライバシー対策を考慮すべきです。
                    </dd>
                </dl>
            </section>

            <section>
                <h4>NFC タグの改ざん</h4>
                <dl>
                    <dt><strong>脅威の説明</strong></dt>
                    <dd>
                        ユーザーの同意なしに NFC タグが改ざんされ、場合によっては読み取り専用にされることで不可逆的な変更となる。
                        これにより、悪意のあるタグを用いたさらなる攻撃を可能にしたり、1つ以上のタグを使用不能にするサービス不能攻撃となり得る。
                    </dd>
                    <dt><strong>影響を受ける資産</strong></dt>
                    <dd>
                        保存中の NDEF メッセージレコード（ペイロードおよびヘッダを含む）。
                    </dd>
                    <dt><strong>アクター</strong></dt>
                    <dd>
                        悪意のあるウェブページ作成者、悪意のあるユーザー。
                    </dd>
                    <dt><strong>緩和策・コメント</strong></dt>
                    <dd>
                        タグへの書き込みや読み取り専用化には、許可とユーザープロンプトを必要とする。
                        あるいは、特定のウェブページが書き込めるタグを制御する（例えば、ウェブページは自らの <a>origin</a> に紐づけられるタグにのみ書き込める）。
                        または、上書きを許可する（書き込み対象ではないタグは読み取り専用にすることで保護できるため）。
                        <a>NDEF signature</a> を使用して NFC タグの改ざんを検出する。
                    </dd>
                </dl>
            </section>

            <section>
                <h4>転送中の NDEF レコード改ざん</h4>
                <dl>
                    <dt><strong>脅威の説明</strong></dt>
                    <dd>
                        Web NFC と <a>NFC adapter</a> およびユーザーデバイス間で転送される <a>NDEF record</a> が改ざんされ、
                        さまざまな中間者攻撃やサービス不能（DoS）攻撃を引き起こす。
                        また、<a>NDEF signature</a> レコードが、変更されたコンテンツとともに削除・置換され得る。
                    </dd>
                    <dt><strong>影響を受ける資産</strong></dt>
                    <dd>
                        転送中の <a>NDEF record</a>。
                    </dd>
                    <dt><strong>アクター</strong></dt>
                    <dd>
                        悪意のある中間者。
                    </dd>
                    <dt><strong>緩和策・コメント</strong></dt>
                    <dd>
                        この脅威は Web NFC 実装の範囲外です。アプリケーションは <a>NDEF signature</a> と適切なツール
                        （署名アルゴリズム、証明書、セキュリティポリシー）を使用して <a>NFC content</a> を保護できます。
                        さらに、プラットフォームスタックを強化します。
                    </dd>
                </dl>
            </section>

            <section>
                <h4>NDEF レコードのペイロード漏えい</h4>
                <dl>
                    <dt><strong>脅威の説明</strong></dt>
                    <dd>
                        保存中（NFC タグ上）または Web NFC と <a>NFC adapter</a> の間で転送中の
                        <a>NDEF record</a> の機密ペイロードが、権限のない第三者に読み取られる。
                    </dd>
                    <dt><strong>影響を受ける資産</strong></dt>
                    <dd>
                        転送中および保存中の機密 NDEF メッセージペイロード。
                    </dd>
                    <dt><strong>アクター</strong></dt>
                    <dd>
                        悪意のある中間者、悪意のあるウェブページ作成者。
                    </dd>
                    <dt><strong>緩和策・コメント</strong></dt>
                    <dd>
                        機密性を確保するため、ペイロードの暗号化と、安全な通信、認証および認可を使用して、
                        Web NFC と <a>NFC adapter</a> 間のデータ交換を行います。
                    </dd>
                </dl>
            </section>

            <section>
                <h4>悪意のある NFC タグによる能動的攻撃</h4>
                <dl>
                    <dt><strong>脅威の説明</strong></dt>
                    <dd>
                        悪意のあるタグが、意図的または非意図的にデバイスに読み取られ、読み取られたデータがユーザーエージェントに対する
                        攻撃ベクトルとなり得る。例えば、デバイス上でアクションをトリガーしようとする（悪意のあるウェブサイトの起動や、
                        デバイス攻撃用に準備された画像を開くなど）。
                    </dd>
                    <dt><strong>影響を受ける資産</strong></dt>
                    <dd>
                        ユーザーデバイスの完全性、その他すべての Web NFC 資産。
                    </dd>
                    <dt><strong>アクター</strong></dt>
                    <dd>
                        悪意のあるタグ作成者。
                    </dd>
                    <dt><strong>緩和策・コメント</strong></dt>
                    <dd>
                        これは既存のすべての NFC タグに共通する一般的な問題です。データはアプリケーション固有と見なされます。
                        実装にはセキュリティの強化が必要です。短距離と読み取りのための厳しい角度、そしてフォーカス要件により、
                        非意図的な接触の可能性は低いです。スマートポスターやその他のタグに対する自動アクションは許可すべきではありません。
                        ユーザーは、NFC 通信中に何が起こっているかを認識し、制御できるようにされなければなりません。
                        例えば <a>smart poster</a> からのコンテンツを開く、<a>NFC handover</a> による（悪意のある可能性のある）Wi-Fi への
                        自動接続など。信頼できない NFC タグからのアクションは許可しないでください。信頼は <a>NDEF signature</a> チェック
                        によって確立できます。
                    </dd>
                </dl>
            </section>
        </section>

        <section class="informative">
            <h2>実装のためのセキュリティメカニズム</h2>
            <section>
                <h3><dfn>Obtaining permission</dfn></h3>
                <p>
                    実装は、例えばユーザーによる明示的な許可など、<a>obtain permission</a> するためのメカニズムを使用すべきです（SHOULD）。
                    NFC 関連の許可を実装するために、ユーザーエージェントが [[[PERMISSIONS]]] API を使用することが提案されています。
                </p>
                <p>
                    実装はセッションごと／エフェメラルな許可を使用しても構いません（MAY）。
                </p>
            </section>
            <section>
                <h3><dfn>Warning user during NFC operations</dfn></h3>
                <p>
                    実装は、ウェブページが NFC アダプタにアクセスしている（例: スキャンが進行中）際に、ユーザーに警告するため、
                    オーバーレイダイアログを表示しても構いません（MAY）。
                </p>
            </section>
        </section>
        <section class="informative">
            <h2>アプリケーションのためのセキュリティメカニズム</h2>
            <section>
                <h3><a>NFC content</a> の暗号化</h3>
                <p>
                    NFC 経由で交換されるデータの機密性を信頼するために、アプリケーションは PKI（公開鍵基盤）に基づく鍵管理とともに
                    暗号化された <a>NFC content</a> を使用しても構いません。鍵管理は Web NFC の範囲外です。
                </p>
            </section>

            <section>
                <h3>NDEF レコードへの署名</h3>
                <p>
                    NFC 経由で交換されるデータの完全性を信頼するために、ユーザーエージェントは鍵管理に PKI を用いた
                    <a>NDEF signature</a> を使用しても構いません（MAY）。
                </p>
                <p>
                    <a>NDEF signature</a> バージョン 1.0（[[NFC-SECURITY]]）で署名されたタグでは、署名は
                    <a>TYPE field</a>、<a>ID field</a>、<a>PAYLOAD field</a> にのみ適用され、NDEF ヘッダの先頭 1 バイトは
                    除外されるため、攻撃の余地が残ります。[[NFC-SECURITY]] バージョン 2.0 では、署名にタグのハードウェア属性を含め、
                    より短い証明書を許容しました。
                </p>
                <p>
                    1 つの <a>NDEF signature</a> は、次の <a>NDEF signature</a> または <a>NDEF message</a> の先頭に達するまでの
                    先行レコードをカバーします。
                </p>
                <p>
                    <a
                        href="https://www.researchgate.net/publication/224227216_Security_Vulnerabilities_of_the_NDEF_Signature_Record_Type">
                        既知の脆弱性</a> を緩和するため、アプリケーションは常に 1 つの <a>NDEF signature</a> で
                    <a>NDEF message</a> 全体に署名し、署名の作成と検証のために適切なツールチェーンとセキュリティポリシーを
                    使用することが推奨されます。
                </p>
            </section>

        </section>

        <section>
            <h3>セキュリティポリシー</h3>
            <p>
                本節は実装に関する規範的なセキュリティポリシーを列挙します。
            </p>

            <section>
                <h4>セキュアコンテキスト</h4>
                <p>
                    <a>secure contexts</a> のみが <a>NFC content</a> にアクセスすることを許可されます。
                    ブラウザは開発目的に限りこの規則を無視しても構いません（MAY）。
                </p>
            </section>

            <section>
                <h4>可視のドキュメント</h4>
                <p>
                    Web NFC の機能は、<a>top-level browsing context</a> の {{Document}} のうち、
                    その {{Document/visibilityState}} が `"visible"` の場合に限り許可されます。
                </p>
                <p>
                    これはまた、表示がオフである、またはデバイスがロックされている場合、UA は NFC 無線へのアクセスをブロックすべきであることを意味します。
                    バックグラウンドのウェブページについては、<a>NFC content</a> の受信および書き込みは
                    <a id="#nfc-suspended">suspended</a> でなければなりません（MUST）。
                </p>
            </section>

            <section>
                <h4>許可の制御</h4>
                <p>
                    <a>NFC tag</a> を恒久的に読み取り専用にするには、<a>obtain permission</a> を
                    必ず行わなければならず（MUST）、そうでなければ失敗します。
                    [[[#making-content-read-only]]] 節を参照してください。
                </p>
                <p>
                    <a>NFC content</a> を読み取るためのリスナー設定は、<a>obtain permission</a> を行うべきです（SHOULD）。
                </p>
                <p>
                    <a>NFC content</a> を <a>NFC tag</a> に書き込むには、<a>obtain permission</a> を
                    必ず行わなければなりません（MUST）。[[[#writing-content]]] 節を参照してください。
                </p>
                <p>
                    現在の閲覧セッションを超えて保存されるすべての許可は、取り消し可能でなければなりません（MUST）。
                </p>
            </section>

            <section>
                <h4>ブロックリスト</h4>
                <p>
                    Web NFC には、ウェブサイトがそれらを悪用するのを防ぐための脆弱な NFC デバイスの
                    <a>blocklist</a> が含まれます。
                </p>
            </section>

            <section>
                <h4>物理的な位置漏えいのリスクの警告</h4>
                <p>
                    <a>NFC content</a> のリッスンおよび書き込み時に、与えられた <a>origin</a> が物理的位置を推測できる可能性について、
                    UA はユーザーに警告しても構いません（MAY）。
                </p>
            </section>

            <section>
                <h4>自動処理の制限</h4>
                <p>
                    <a>NFC content</a> 上のペイロードデータが信頼できない場合、ユーザーが承認しない限り、
                    UA はそのコンテンツの自動処理（<a>NFC tag</a> 内の URL を用いたウェブページのオープン、アプリのインストール、
                    その他のアクションなど）に使用してはなりません（MUST NOT）。
                </p>
            </section>

            <section>
                <h4> <a>NFC content</a> の署名</h4>
                <div>
                    次のポリシーは、アプリケーションによる実装が推奨されます。
                    <ul>
                        <li>
                            <a>smart poster</a> は、同一発行者による単一の <a>NDEF signature</a> レコードで署名され、
                            メッセージ内の最初のレコードであるか、または別の <a>NDEF signature</a> に先行している場合にのみ信頼しても構いません（MAY）。
                        </li>
                        <li>
                            <a>NDEF message</a> は、同一発行者による単一の <a>NDEF signature</a> レコードで署名されている場合にのみ
                            信頼しても構いません（MAY）。
                        </li>
                        <li>
                            ユーザーエージェントは <a>NDEF signature</a> レコードを検証せずに公開します。署名の検証および
                            <a>NFC content</a> の署名はアプリケーションの責任です。
                        </li>
                        <li>
                            アプリケーションは <a>NDEF signature</a> の作成と検証に適切な署名アルゴリズム、証明書、セキュリティポリシーを
                            使用すべきです（SHOULD）。また、<a>NDEF signature</a> に対する既知の攻撃（例えば
                            <a>NDEF signature</a> の削除、<a>NDEF signature</a> を変更された <a>NFC content</a> とともに置換、
                            レコードの <a>PAYLOAD LENGTH field</a> を変更することでの順序入れ替えなど）を考慮してください。
                        </li>
                    </ul>
                </div>
            </section>
            <!-- TODO: add later
    <p class="note">
      For Bluetooth and WiFi handover (supported in later versions),
      the user should have to grant access to the secondary API and must be
      able to properly understand what they are granting.
    </p>
    -->
        </section> <!-- Policies -->
    </section> <!-- Security and Privacy  -->

    <section id="idl-index" class="appendix">
        <!-- All the Web IDL will magically appear here -->
    </section>

    <!-- - - - - - - - - - - - - - - Acknowledgments - - - - - - - - - - - - - -->
    <section>
        <h2>謝辞</h2>
        <p>
            編集者は、本ドキュメントへの貢献に対し、Jeffrey Yasskin、Anne van Kesteren、
            Anssi Kostiainen、Domenic Denicola、Daniel Ehrenberg、Jonas Sicking、
            Don Coleman、Salvatore Iovene、Rijubrata Bhaumik、Wanming Lin、Han Leon、
            Ryan Sleevi、Balázs Engedy、Theodore Olsauskas-Warren、Reilly Grant、
            Diego González、および Daniel Appelquist に感謝します。
        </p>
        <p>
            特別な感謝を、NFC をウェブプラットフォームに公開する取り組みの
            初期の<a href="https://github.com/w3c/nfc">work</a> と現行アプローチの支援に対して
            Luc Yriarte と Samuel Ortiz に。また、セキュリティとプライバシーの節への貢献に対して
            Elena Reshetova に特別な感謝を表します。
        </p>
    </section>

</body>

</html>