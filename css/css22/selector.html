<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01//EN'>
<html lang="ja-JP">

<head>
    <title>セレクター</title>
    <link rel="stylesheet" href="https://www.w3.org/TR/CSS22/style/default.css" type="text/css">
    <link rel="stylesheet" href="https://www.w3.org/StyleSheets/TR/2016/W3C-WD.css" type="text/css">
    <link rel="prev" href="syndata.html">
    <link rel="next" href="cascade.html">
    <link rel="contents" href="index.html#minitoc">
    <link rel="CSS-properties" href="propidx.html" title="properties">
    <link rel="index" href="indexlist.html" title="index">
    <link rel="first" href="index.html">
    <script type="text/javascript" src="https://www.w3.org/scripts/TR/2016/fixup.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

</head>

<body>
    <div class="navbar">
        <p><a href="syndata.html">前のページ</a> &nbsp;
            <a href="cascade.html">次のページ</a> &nbsp;
            <a href="index.html#minitoc">目次</a> &nbsp;
            <a href="propidx.html">プロパティ一覧</a> &nbsp;
            <a href="indexlist.html">索引</a> &nbsp;
    </div>
    <hr class="navbar">

    <h1><a name="q0">5 セレクター</a></h1>
    <div id="toc" class="subtoc">
        <p><strong>目次</strong>
        <ul class="toc">
            <li><a href="selector.html#pattern-matching" class="tocxref">5.1 パターンマッチング</a>
            <li><a href="selector.html#selector-syntax" class="tocxref">5.2 セレクター構文</a>
                <ul class="toc">
                    <li><a href="selector.html#grouping" class="tocxref">5.2.1 グループ化</a>
                </ul>
            <li><a href="selector.html#universal-selector" class="tocxref">5.3 汎用セレクター</a>
            <li><a href="selector.html#type-selectors" class="tocxref">5.4 型セレクター</a>
            <li><a href="selector.html#descendant-selectors" class="tocxref">5.5 子孫セレクター</a>
            <li><a href="selector.html#child-selectors" class="tocxref">5.6 子セレクター</a>
            <li><a href="selector.html#adjacent-selectors" class="tocxref">5.7 隣接兄弟セレクター</a>
            <li><a href="selector.html#attribute-selectors" class="tocxref">5.8 属性セレクター</a>
                <ul class="toc">
                    <li><a href="selector.html#matching-attrs" class="tocxref">5.8.1 属性と属性値の一致</a>
                    <li><a href="selector.html#default-attrs" class="tocxref">5.8.2 DTDにおけるデフォルト属性値</a>
                    <li><a href="selector.html#class-html" class="tocxref">5.8.3 クラスセレクター</a>
                </ul>
            <li><a href="selector.html#id-selectors" class="tocxref">5.9 IDセレクター</a>
            <li><a href="selector.html#pseudo-elements" class="tocxref">5.10 疑似要素と疑似クラス</a>
            <li><a href="selector.html#pseudo-class-selectors" class="tocxref">5.11 疑似クラス</a>
                <ul class="toc">
                    <li><a href="selector.html#first-child" class="tocxref">5.11.1 :first-child 疑似クラス</a>
                    <li><a href="selector.html#link-pseudo-classes" class="tocxref">5.11.2 リンク疑似クラス:
                            <span class="index-def" title="pseudo-classes:::link|:link|link (pseudo-class)">:link</span>
                            および <span class="index-def"
                                title="pseudo-classes:::visited|:visited|visited (pseudo-class)">:visited</span></a>
                    <li><a href="selector.html#dynamic-pseudo-classes" class="tocxref">5.11.3 動的疑似クラス:
                            <span class="index-def"
                                title="pseudo-classes:::hover|:hover|hover (pseudo-class)">:hover</span>, <span
                                class="index-def"
                                title="pseudo-classes:::active|:active|active (pseudo-class)">:active</span>, および <span
                                class="index-def"
                                title="pseudo-classes:::focus|:focus|focus (pseudo-class)">:focus</span></a>
                    <li><a href="selector.html#lang" class="tocxref">5.11.4 言語疑似クラス: <span class="index-def"
                                title="pseudo-classes:::lang|:lang|lang (pseudo-class)">:lang</span></a>
                </ul>
            <li><a href="selector.html#pseudo-element-selectors" class="tocxref">5.12 疑似要素</a>
                <ul class="toc">
                    <li><a href="selector.html#first-line-pseudo" class="tocxref">5.12.1 <span class="index-def"
                                title="pseudo-elements:::first-line|:first-line|first-line">:first-line</span>
                            疑似要素</a>
                    <li><a href="selector.html#first-letter" class="tocxref">5.12.2 <span class="index-def"
                                title="pseudo-elements:::first-letter|:first-letter|first-letter">:first-letter</span>
                            疑似要素</a>
                    <li><a href="selector.html#before-and-after" class="tocxref">5.12.3 <span class="index-def"
                                title="pseudo-elements:::before|:before">:before</span> および <span class="index-def"
                                title="pseudo-elements:::after|:after">:after</span> 疑似要素</a>
                </ul>
        </ul>
    </div>


    <h2>5.1 <a name="pattern-matching">パターンマッチング</a></h2>

    <p>CSSでは、パターンマッチング規則によって、<a href="conform.html#doctree">文書ツリー</a>内の要素に適用されるスタイル規則が決定されます。
        これらのパターンは<a name="x0"><span class="index-inst" title="selector">セレクター</span></a>と呼ばれ、
        単純な要素名から複雑な文脈的パターンまで多岐にわたります。
        パターン内のすべての条件が特定の要素に対して真である場合、そのセレクターはその要素に<a name="x1"><span class="index-def"
                title="match|selector::match"><dfn>一致</dfn></span></a>します。

    <p>セレクター内の文書言語の要素名の大文字小文字の区別は文書言語に依存します。
        例えば、HTMLでは要素名は大文字小文字を区別しませんが、XMLでは区別します。

    <p>次の表にCSS&nbsp;2.2のセレクター構文をまとめます：</p>

    <table class=data>
        <tr>
            <th>パターン
            <th>意味
            <th>説明されているセクション
        </tr>
        <tr>
            <td>*
            <td>任意の要素に一致します。
            <td><a href="#universal-selector">汎用セレクター</a>
        </tr>
        <tr>
            <td>E
            <td>任意のE要素（つまり、タイプEの要素）に一致します。
            <td><a href="#type-selectors">型セレクター</a>
        </tr>
        <tr>
            <td>E F
            <td>E要素の子孫である任意のF要素に一致します。
            <td><a href="#descendant-selectors">子孫セレクター</a>
        </tr>
        <tr>
            <td>E &gt; F
            <td>E要素の子である任意のF要素に一致します。
            <td><a href="#child-selectors">子セレクター</a>
        </tr>
        <tr>
            <td>E:first-child
            <td>Eが親の最初の子要素である場合に一致します。
            <td><a href="#first-child">:first-child 疑似クラス</a>
        </tr>

        <tr>
            <td>E:link<br>E:visited
            <td>ハイパーリンクのソースアンカーであるE要素が、まだ訪問されていない場合(:link)、
                またはすでに訪問済みである場合(:visited)に一致します。
            <td><a href="#link-pseudo-classes">リンク疑似クラス</a>
        </tr>
        <tr>
            <td>E:active<br>E:hover<br>E:focus
            <td>特定のユーザー操作中にEに一致します。
            <td><a href="#dynamic-pseudo-classes">動的疑似クラス</a>
        <tr>
            <td>E:lang(c)
            <td>タイプEの要素が（文書言語が定義する方法で決定された）言語cの場合に一致します。
            <td><a href="#lang">:lang() 疑似クラス</a>
        <tr>
            <td>E + F
            <td>兄弟要素Eの直後にある任意のF要素に一致します。
            <td><a href="#adjacent-selectors">隣接セレクター</a>
        </tr>
        <tr>
            <td>E[foo]
            <td>"foo"属性が設定されている任意のE要素に一致します（値に関係なく）。
            <td><a href="#attribute-selectors">属性セレクター</a>
        </tr>
        <tr>
            <td>E[foo="warning"]
            <td>"foo"属性値が正確に"warning"と等しい任意のE要素に一致します。
            <td><a href="#attribute-selectors">属性セレクター</a>
        </tr>
        <tr>
            <td>E[foo~="warning"]
            <td>"foo"属性値がスペースで区切られた値のリストであり、その中に正確に"warning"と等しい値が含まれる任意のE要素に一致します。
            <td><a href="#attribute-selectors">属性セレクター</a>
        </tr>
        <tr>
            <td>E[lang|="en"]
            <td>"lang"属性がハイフンで区切られた値のリストで、
                左から始まる値が"en"である任意のE要素に一致します。
            <td><a href="#attribute-selectors">属性セレクター</a>
        </tr>
        <tr>
            <td>DIV.warning
            <td><em>言語固有。</em>（HTMLでは、DIV[class~="warning"]と同じです。）
            <td><a href="#class-html">クラスセレクター</a>
        </tr>
        <tr>
            <td>E#myid
            <td>IDが"myid"と等しい任意のE要素に一致します。
            <td><a href="#id-selectors">IDセレクター</a>
        </tr>
    </table>


    <h2>5.2 <a name="selector-syntax">セレクター構文</a></h2>

    <p><span class="index-def" title="simple selector"><a name="simple-selector"><dfn>単純セレクター</dfn></a></span>は、
        <a href="#type-selectors">型セレクター</a>または<a href="#universal-selector">汎用セレクター</a>に続けて、
        任意の順序で0個以上の<a href="#attribute-selectors">属性セレクター</a>、<a href="#id-selectors">IDセレクター</a>、
        または<a href="#pseudo-classes">疑似クラス</a>が続くものです。
        単純セレクターは、そのすべての構成要素が一致する場合に一致します。

    <p class="note">注記：CSS&nbsp;2.2で使用されている用語は、CSS3で使用されているものとは異なります。
        例えば、「単純セレクター」は、CSS&nbsp;2.2ではCSS3よりもセレクターの小さな部分を指します。
        CSS3セレクターモジュールを参照してください <a href="refs.html#ref-CSS3SEL" rel="biblioentry" class="noxref"><span
                class="informref">[CSS3SEL]</span></a>。

    <p><a name="x4"><span class="index-def" title="selector"><dfn>セレクター</dfn></span></a>は、
        コンビネーターで区切られた1つ以上の単純セレクターの連鎖です。
        <span class="index-def" title="combinator"><a name="combinator"><dfn>コンビネーター</dfn></a></span>には、
        空白、"&gt;"、"+"があります。
        コンビネーターとその周囲の単純セレクターの間に空白を入れることができます。

    <p>セレクターと一致する文書ツリーの要素を
        <span class="index-def" title="subject (of selector)|selector::subject
of"><a name="subject"><dfn>対象</dfn></a></span>と呼びます。
        単一の単純セレクターからなるセレクターは、その要件を満たす任意の要素に一致します。
        単純セレクターとコンビネーターをチェーンに追加することで追加の一致制約が課されるため、
        セレクターの対象は常に最後の単純セレクターと一致する要素の部分集合です。

    <p>1つの<a href="#pseudo-elements">疑似要素</a>をチェーン内の最後の単純セレクターに追加することができ、
        その場合、スタイル情報は各対象のサブパートに適用されます。

    <h3>5.2.1 <a name="grouping">グループ化</a></h3>

    <p>複数のセレクターが同じ宣言を共有する場合、それらをカンマ区切りのリストにグループ化できます。</p>

    <div class="example">
        <P style="display:none">例：</P>
        <P>この例では、同一の宣言を持つ3つの規則を1つにまとめます。このようにして、

        <pre>
h1 { font-family: sans-serif }
h2 { font-family: sans-serif }
h3 { font-family: sans-serif }
</pre>

        <p>は次と等価です：</p>

        <pre>
h1, h2, h3 { font-family: sans-serif }
</pre>
    </div>

    <p>CSSは、<span class="index-def" title="multiple declarations">
            <a name="x8" href="syndata.html#declaration">複数宣言</a></span>や
        <span class="index-inst" title="shorthand property"><a name="x9" href="about.html#shorthand">略記プロパティ</a></span>
        など、他の「略記」メカニズムも提供します。

    <h2>5.3 <a name="universal-selector">汎用セレクター</a></h2>

    <p><a name="x10"><span class="index-def" title="universal selector">汎用セレクター</span></a>は、"*"と記述され、
        任意の要素型の名前に一致します。これは、<a href="conform.html#doctree">文書ツリー</a>内の任意の1つの要素に一致します。</p>

    <p>汎用セレクターが<a href="#simple-selector">単純セレクター</a>の唯一の構成要素ではない場合、"*"を省略することができます。例えば：</p>

    <ul>
        <li><code>*[lang=fr]</code> と <code>[lang=fr]</code> は同等です。
        <li><code>*.warning</code> と <code>.warning</code> は同等です。
        <li><code>*#myid</code> と <code>#myid</code> は同等です。
    </ul>

    <h2>5.4 <a name="type-selectors">型セレクター</a></h2>

    <p><a name="x11"><span class="index-def" title="type selector"><em>型セレクター</em></span></a>は、
        文書言語の要素型の名前に一致します。型セレクターは、文書ツリー内のその要素型のすべてのインスタンスに一致します。</p>

    <div class="example">
        <p style="display:none">例：</p>
        <p>次の規則は、文書ツリー内のすべてのH1要素に一致します：</p>

        <pre>
h1 { font-family: sans-serif }
</pre>
    </div>

    <h2>5.5 <a name="descendant-selectors">子孫セレクター</a></h2>

    <p>時には、文書ツリー内の別の要素の子孫である要素に一致するセレクターを著者が作成したい場合があります
        （例：「H1要素内に含まれるEM要素に一致させる」）。
        <a name="x12"><span class="index-def" title="descendant-selectors">子孫セレクター</span></a>は、
        パターン内でこのような関係を表現します。
        子孫セレクターは、<a href="syndata.html#whitespace">空白</a>で区切られた2つ以上のセレクターで構成されます。
        "<code>A B</code>"形式の子孫セレクターは、<a
            href="conform.html#doctree">祖先</a>要素<code>A</code>の任意の子孫である要素<code>B</code>に一致します。
    </p>

    <div class="example">
        <p style="display:none">例：</p>
        <p>例えば、次の規則を考えてみましょう：</p>

        <pre>
h1 { color: red }
em { color: red }
</pre>

        <p>これらの規則の意図は、テキストの色を変更することで強調を追加することですが、次のような場合には効果が失われます：</p>

        <pre>
&lt;H1&gt;This headline is &lt;EM&gt;very&lt;/EM&gt; important&lt;/H1&gt;
</pre>

        <p>このケースに対処するために、H1内でEMが発生する場合にテキストの色を青に設定する規則を追加します：</p>

        <pre>
h1 { color: red }
em { color: red }
h1 em { color: blue }
</pre>

        <p>3つ目の規則は、次の断片内のEMに一致します：</p>

        <pre>
&lt;H1&gt;This &lt;SPAN class="myclass"&gt;headline 
is &lt;EM&gt;very&lt;/EM&gt; important&lt;/SPAN&gt;&lt;/H1&gt;
</pre>
    </div>

    <div class="example">
        <p style="display:none">例：</p>
        <p>次のセレクター：</p>

        <pre>
div * p 
</pre>

        <p>これは、DIV要素の孫またはそれ以降の子孫であるP要素に一致します。
            "*"の両側にある空白は汎用セレクターの一部ではありません。
            空白は、DIVがある要素の祖先であり、その要素がPの祖先である必要があることを示します。
    </div>

    <div class="example">
        <p style="display:none">例：</p>
        <p>次の規則のセレクターは、子孫セレクターと<a href="#attribute-selectors">属性セレクター</a>を組み合わせたもので、
            (1) "href"属性が設定されており、(2) P内にあり、そのPがDIV内にある任意の要素に一致します：</p>

        <pre>
div p *[href]
</pre>
    </div>

    <h2>5.6 <a name="child-selectors">子セレクター</a></h2>

    <p><a name="x13"><span class="index-def" title="child selector"><em>子セレクター</em></span></a>は、
        ある要素が別の要素の<a href="conform.html#doctree">子</a>である場合に一致します。
        子セレクターは、"&gt;"で区切られた2つ以上のセレクターで構成されます。</p>

    <div class="example">
        <p style="display:none">例：</p>
        <p>次の規則は、BODYの子であるすべてのP要素のスタイルを設定します：</p>

        <pre>
body &gt; P { line-height: 1.3 }
</pre>
    </div>

    <div class="example">
        <p style="display:none">例：</p>
        <p>次の例は、子孫セレクターと子セレクターを組み合わせたものです：</p>

        <pre>
div ol&gt;li p
</pre>

        <p>これは、LIの子孫であるP要素に一致します。
            LI要素はOL要素の子でなければならず、OL要素はDIVの子孫でなければなりません。
            "&gt;"コンビネーターの周囲の空白は省略されています。
    </div>

    <p>要素の最初の子を選択する方法については、以下の<a href="#first-child">:first-child</a>疑似クラスのセクションを参照してください。</p>

    <h2>5.7 <a name="adjacent-selectors">隣接兄弟セレクター</a></h2>

    <p>隣接兄弟セレクターは次の構文を持ちます：E1 + E2。
        E2はセレクターの対象です。このセレクターは、E1とE2が文書ツリー内で同じ親を共有し、
        E1がE2の直前にある場合に一致します。
        非要素ノード（テキストノードやコメントなど）は無視されます。</p>

    <div class="example">
        <p style="display:none">例：</p>
        <p>したがって、次の規則は、MATH要素の直後にP要素がある場合、インデントをなくすことを示します：</p>

        <pre>
math + p { text-indent: 0 } 
</pre>

        <p>次の例では、H1の直後に続くH2間の垂直スペースを減らします：</p>

        <pre>
h1 + h2 { margin-top: -5mm }   
</pre>
    </div>

    <div class="example">
        <p style="display:none">例：</p>
        <p>次の規則は、前の例の規則と似ていますが、クラスセレクターを追加しています。
            したがって、特別なフォーマットはH1が<samp>class="opener"</samp>を持つ場合にのみ発生します：</p>

        <pre>
h1.opener + h2 { margin-top: -5mm }   
</pre>
    </div>

    <h2>5.8 <a name="attribute-selectors">属性セレクター</a></h2>

    <p>CSS&nbsp;2.2では、ソース文書内で特定の属性が定義されている要素に一致する規則を著者が指定することができます。</p>

    <h3>5.8.1 <a name="matching-attrs">属性と属性値の一致</a></h3>

    <p>属性セレクターは次の4つの方法で一致する可能性があります：</p>

    <dl>
        <dt><code>[att]</code>
        <dd>要素が"att"属性を設定している場合に一致します。属性の値に関係なく一致します。
        <dt><a name="x14"><span class="index-def" title="exact
matching|="><code>[att=val]</code></span></a>
        <dd>要素の"att"属性値が正確に"val"である場合に一致します。
        <dt><a name="x16"><span class="index-def" title="space-separated
matching|~="><code>[att~=val]</code></span></a>
        <dd><code>att</code>属性の値がスペースで区切られた単語のリストであり、その中に正確に"val"が含まれる要素を表します。
            "val"にスペースが含まれている場合、それは何も表しません（単語はスペースで<em>区切られている</em>ため）。
            また、"val"が空文字列の場合も何も表しません。
        <dt><a name="x18"><span class="index-def" title="hyphen-separated
matching|&#124;="><code>[att|=val]</code></span></a>
        <dd><code>att</code>属性を持つ要素を表し、その値が正確に"val"であるか、"val"に続けてすぐに"-"（U+002D）が続く場合に一致します。
            これは主に、BCP&nbsp;47（<a href="refs.html#ref-BCP47" rel="biblioentry" class="noxref"><span
                    class="informref">[BCP47]</span></a>）
            またはその後継で説明されているように、<a name="x20"><span class="index-inst" title="language code">言語サブコード</span></a>
            の一致を可能にすることを目的としています。<code>lang</code>（または<code>xml:lang</code>）の言語サブコードの一致については、
            <a href="#lang"><code>:lang</code>疑似クラス</a>を参照してください。
    </dl>

    <p>属性値は識別子または文字列でなければなりません。
        セレクター内の属性名と値の大文字小文字の区別は文書言語に依存します。</p>

    <div class="example">
        <p style="display:none">例：</p>
        <p>例えば、次の属性セレクターは、
            "title"属性を指定しているすべてのH1要素に一致します（値に関係なく）：</p>

        <pre>
h1[title] { color: blue; }
</pre>
    </div>

    <div class="example">
        <p style="display:none">例：</p>
        <p>次の例では、セレクターは"クラス"属性が正確に"example"という値を持つすべてのSPAN要素に一致します：</p>

        <pre>
span[class=example] { color: blue; }
</pre>
    </div>

    <p>複数の属性セレクターを使用して、要素の複数の属性、
        または同じ属性を複数回参照することができます。</p>

    <div class="example">
        <p style="display:none">例：</p>
        <p>ここでは、セレクターは"hello"属性が正確に"Cleveland"という値を持ち、
            "goodbye"属性が正確に"Columbus"という値を持つすべてのSPAN要素に一致します：</p>

        <pre>
span[hello="Cleveland"][goodbye="Columbus"] { color: blue; }
</pre>
    </div>

    <div class="example">
        <p style="display:none">例：</p>
        <p>次のセレクターは、"="と"~="の違いを示しています。
            最初のセレクターは、例えば"rel"属性の値が"copyright copyleft copyeditor"の場合に一致します。
            2番目のセレクターは、"href"属性が正確に"http://www.w3.org/"という値を持つ場合にのみ一致します。</p>

        <pre>
a[rel~="copyright"]
a[href="http://www.w3.org/"]
</pre>
    </div>

    <div class="example">
        <p style="display:none">例：</p>
        <p>次の規則は、"lang"属性の値が"fr"（つまり、言語がフランス語）であるすべての要素を非表示にします。</p>

        <pre>
*[lang=fr] { display : none }
</pre>
    </div>

    <div class="example">
        <p style="display:none">例：</p>
        <p>次の規則は、"lang"属性の値が"en"で始まる場合に一致します。"en"、"en-US"、"en-cockney"を含みます：</p>

        <pre>
*[lang|="en"] { color : red }
</pre>
    </div>

    <div class="example">
        <p style="display:none">例：</p>
        <p>同様に、次の音声スタイルシート規則では、スクリプトを各役割ごとに異なる声で読み上げることができます：</p>

        <pre>
DIALOGUE[character=romeo] 
     { voice-family: "Laurence Olivier", charles, male }
      
DIALOGUE[character=juliet]  
     { voice-family: "Vivien Leigh", victoria, female }
</pre>
    </div>

    <h3>5.8.2 <a name="default-attrs">DTDにおけるデフォルト属性値</a></h3>

    <p>一致は文書ツリー内の属性値に基づいて行われます。
        デフォルト属性値は<a name="x21"><span class="index-inst" title="DTD">DTD</span></a>やその他の場所で定義される場合がありますが、
        属性セレクターによって常に選択できるわけではありません。
        スタイルシートは、デフォルト値が文書ツリーに含まれていない場合でも機能するように設計されるべきです。</p>

    <p>より正確には、UAはDTDの"外部部分集合"を読み取ることができる場合がありますが、
        必ずしもそうする必要はありません。ただし、文書の"内部部分集合"内のデフォルト属性値を探す必要があります。
        （これらの部分集合の定義については<a href="refs.html#ref-XML11" rel="biblioentry" class="noxref"><span
                class="normref">[XML11]</span></a>
        を参照してください）。
        UAによっては、DTDの外部部分集合で定義されたデフォルト属性値が文書ツリーに表示されるかどうかが異なる場合があります。</p>

    <p>XML名前空間を認識するUA（<a href="refs.html#ref-XMLNAMESPACES" rel="biblioentry" class="noxref"><span
                class="informref">[XMLNAMESPACES]</span></a>
        を参照）は、その名前空間に関する知識を使用して、デフォルト属性値を文書内に存在するかのように扱うことができますが、
        必ずしもその必要はありません。（例：XHTML UAは、XHTML DTDに関する組み込みの知識を使用する必要はありません）。</p>

    <p class="note">注記：通常、実装は外部部分集合を無視することを選択します。</p>

    <div class="example">
        <p style="display:none">例：</p>
        <p>例えば、"notation"という属性を持つEXAMPLE要素があり、
            そのデフォルト値が"decimal"であるとします。DTDフラグメントは次のようになる可能性があります：</p>

        <pre>
&lt;!ATTLIST EXAMPLE notation (decimal,octal) "decimal">
</pre>

        <p>スタイルシートに次の規則が含まれている場合：</p>

        <pre>
EXAMPLE[notation=decimal] { /*... default property settings ...*/ }
EXAMPLE[notation=octal]   { /*... other settings...*/ }
</pre>

        <p>最初の規則は、"notation"属性がデフォルトで設定されている要素（つまり、明示的に設定されていない要素）には一致しない可能性があります。
            すべての場合をキャッチするには、デフォルト値の属性セレクターを削除する必要があります：</p>

        <pre>
EXAMPLE                   { /*... default property settings ...*/ }
EXAMPLE[notation=octal]   { /*... other settings...*/ }
</pre>

        <p>ここで、セレクター<code>EXAMPLE[notation=octal]</code>は型セレクター単独よりも
            <a href="cascade.html#specificity">特異性</a>が高いため、
            "notation"属性値が"octal"である要素に対しては、2番目の規則のスタイル宣言が最初の規則のそれをオーバーライドします。
            デフォルトケースにのみ適用されるプロパティ宣言が、非デフォルトケースのスタイル規則でオーバーライドされるように注意を払う必要があります。
    </div>


    <h3>5.8.3 <a name="class-html">クラスセレクター</a></h3>

    <p>HTMLを使用する場合、著者は<code>class</code>属性を表現する際に<code>~=</code>記法の代わりにピリオド（<code>.</code>）記法を使用できます。
        したがって、HTMLでは<code>div.value</code>と<code>div[class~=value]</code>は同じ意味を持ちます。
        属性値はピリオド（<code>.</code>）の直後に続かなければなりません。
        UAは、該当する名前空間の<code>class</code>属性を特定する名前空間固有の知識を持つ場合、XML文書内でピリオド（<code>.</code>）記法を使用するセレクターを適用できます。
        名前空間固有の知識の例として、特定の名前空間の仕様書内の記述が挙げられます（例：SVG 1.1 <a href="refs.html#ref-SVG11" rel="biblioentry"
            class="noxref"><span class="informref">[SVG11]</span></a>
        は<a
            href="https://www.w3.org/TR/2003/REC-SVG11-20030114/styling.html#ClassAttribute">SVGの<code>class</code>属性</a>について記述しており、
        同様にMathML 3.0 <a href="refs.html#ref-MATH30" rel="biblioentry" class="noxref"><span
                class="informref">[MATH30]</span></a>は
        <a href="https://www.w3.org/TR/MathML2/chapter2.html#fund.globatt">MathMLの<code>class</code>属性</a>について記述しています）。
    </p>

    <div class="example">
        <p style="display:none">例：</p>
        <p>例えば、<samp>class~="pastoral"</samp>であるすべての要素にスタイル情報を割り当てる場合：</p>

        <pre>
*.pastoral { color: green }  /* class~=pastoral のすべての要素 */
</pre>

        または単に：

        <pre>
.pastoral { color: green }  /* class~=pastoral のすべての要素 */
</pre>

        <p>次の例では、<samp>class~="pastoral"</samp>のH1要素のみにスタイルを割り当てています：</p>

        <pre>
H1.pastoral { color: green }  /* class~=pastoral のH1要素 */
</pre>

        <p>これらの規則に基づき、次の最初のH1要素は緑色にはなりませんが、2番目のH1要素は緑色になります：</p>

        <pre>
&lt;H1&gt;Not green&lt;/H1&gt;
&lt;H1 class="pastoral"&gt;Very green&lt;/H1&gt;
</pre>
    </div>

    <p>"class"値のサブセットに一致させるには、各値の前にピリオド（<code>.</code>）を付ける必要があります。</p>

    <div class="example">
        <p style="display:none">例：</p>
        <p>例えば、次の規則は、"class"属性にスペースで区切られた値のリストが割り当てられており、
            その中に"pastoral"と"marine"が含まれているすべてのP要素に一致します：</p>

        <pre>
p.marine.pastoral { color: green }
</pre>

        <p>この規則は<samp>class="pastoral blue aqua marine"</samp>には一致しますが、<samp>class="pastoral blue"</samp>には一致しません。</p>
    </div>

    <div class="note">
        <p><em><strong>注意：</strong> CSSは<code>class</code>属性に非常に大きな力を与えています。そのため、著者はほとんど関連するプレゼンテーションを持たない要素
                （HTMLのDIVやSPANのような）をベースに独自の「文書言語」を設計し、<code>class</code>属性を通じてスタイル情報を割り当てることが考えられます。
                ただし、文書言語の構造的要素には一般的に認識され、受け入れられた意味がありますが、著者定義のクラスにはそれがない可能性があるため、このような実践は避けるべきです。</em></p>
    </div>

    <div class="note">
        <p><em><strong>注意：</strong> 要素に複数のクラス属性がある場合、その値はクラスを検索する前にスペースで区切られて連結されなければなりません。
                現時点では、この状況に達する方法は知られていないため、この動作は本仕様では明示的に規範的ではありません。</em></p>
    </div>

    <h2>5.9 <a name="id-selectors">IDセレクター</a></h2>

    <p>文書言語には、ID型として宣言されている属性を含む場合があります。
        ID型の属性が特別である理由は、同じ値を持つ属性が2つ存在できないことです。
        どの文書言語であれ、ID属性はその要素を一意に識別するために使用されます。
        HTMLでは、すべてのID属性は"id"という名前を持ちますが、XMLアプリケーションでは異なる名前を持つ場合がありますが、
        同じ制限が適用されます。</p>

    <p>文書言語のID属性を使用すると、著者は文書ツリー内の1つの要素インスタンスに識別子を割り当てることができます。
        CSSのIDセレクターは、識別子に基づいて要素インスタンスに一致します。
        CSSのIDセレクターは、"#"に続けて識別子であるID値を記述します。</p>

    <p class="note">注意：CSSは、UAが要素のID属性をどのように認識するかを指定していません。
        UAは、例えば文書のDTDを読み取るか、情報をハードコードするか、またはユーザーに尋ねることができます。</p>

    <div class="example">
        <p style="display:none">例：</p>
        <p>次のIDセレクターは、ID属性が"chapter1"という値を持つH1要素に一致します：</p>

        <pre>
h1#chapter1 { text-align: center }
</pre>
    </div>

    <div class="html example">
        <p>次の例では、スタイル規則はID値が"z98y"である要素に一致します。
            この規則はP要素に一致します：</p>

        <pre>
&lt;HEAD&gt;
  &lt;TITLE&gt;Match P&lt;/TITLE&gt;
  &lt;STYLE type="text/css"&gt;
    *#z98y { letter-spacing: 0.3em }
  &lt;/STYLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
   &lt;P id=z98y&gt;Wide text&lt;/P&gt;
&lt;/BODY&gt;
</pre>

        <p>しかし、次の例では、スタイル規則はID値が"z98y"であるH1要素にのみ一致します。
            この規則は、この例のP要素には一致しません：</p>

        <pre>
&lt;HEAD&gt;
  &lt;TITLE&gt;Match H1 only&lt;/TITLE&gt;
  &lt;STYLE type="text/css"&gt;
    H1#z98y { letter-spacing: 0.5em }
  &lt;/STYLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
   &lt;P id=z98y&gt;Wide text&lt;/P&gt;
&lt;/BODY&gt;
</pre>
    </div>

    <p>IDセレクターは属性セレクターよりも特異性が高いです。
        例えば、HTMLでは、セレクター<samp>#p123</samp>は<samp>[id=p123]</samp>よりも<a href="cascade.html">カスケード</a>において特異性が高いです。</p>

    <div class="note">
        <p><em><strong>注意：</strong> XML 1.1 <a href="refs.html#ref-XML11" rel="biblioentry" class="noxref"><span
                        class="informref">[XML11]</span></a>では、どの属性が要素のIDを含むかに関する情報はDTDに含まれています。
                XMLをパースする際、UAは必ずしもDTDを読み取るわけではないため、要素のIDが何であるかを認識できない場合があります。
                スタイルシート設計者がこれが起こる可能性を知っている、または疑っている場合は、
                <code>#p371</code>の代わりに通常の属性セレクターを使用するべきです：<code>[name=p371]</code>。
                ただし、通常の属性セレクターのカスケード順序はIDセレクターとは異なります。
                そのため、宣言に<code>!important</code>優先順位を追加する必要がある場合があります：
                <code>[name=p371] {color: red !important}</code>。</em></p>
    </div>

    <p>要素に複数のID属性がある場合、IDセレクターの目的上、それらすべてがその要素のIDとして扱われなければなりません。
        このような状況は、xml:id <a href="refs.html#ref-XMLID" rel="biblioentry" class="noxref"><span
                class="informref">[XMLID]</span></a>、
        DOM3 Core <a href="refs.html#ref-DOM-LEVEL-3-CORE" rel="biblioentry" class="noxref"><span
                class="informref">[DOM-LEVEL-3-CORE]</span></a>、
        XML DTDs <a href="refs.html#ref-XML11" rel="biblioentry" class="noxref"><span
                class="informref">[XML11]</span></a>
        および名前空間固有の知識を組み合わせて到達する可能性があります。</p>

    <h2>5.10 <a name="pseudo-elements">疑似要素</a> と <a name="pseudo-classes">疑似クラス</a></h2>

    <p>CSS&nbsp;2.2では、スタイルは通常<a href="conform.html#doctree">文書ツリー</a>内の要素の位置に基づいて適用されます。
        この単純なモデルは多くの場合に十分ですが、<a href="conform.html#doctree">文書ツリー</a>の構造のために、
        一部の一般的な出版シナリオが実現できない場合があります。
        例えば、HTML 4（<a href="refs.html#ref-HTML4" rel="biblioentry" class="noxref"><span
                class="normref">[HTML4]</span></a>）では、
        段落の最初の行を参照する要素がなく、そのため単純なCSSセレクターではそれを参照することができません。</p>

    <p>CSSは、<a name="x22"><span class="index-def" title="pseudo-elements"><dfn>疑似要素</dfn></span></a>と
        <a name="x23"><span class="index-def" title="pseudo-classes"><dfn>疑似クラス</dfn></span></a>の概念を導入し、
        文書ツリーの外部にある情報に基づいてフォーマットを可能にします。
    </p>

    <ul>
        <li>疑似要素は、文書言語で指定されているものを超えて文書ツリーに関する抽象化を作成します。
            例えば、文書言語では、要素の内容の最初の文字や最初の行にアクセスするためのメカニズムを提供していません。
            CSS疑似要素を使用することで、スタイルシート設計者は通常アクセスできない情報を参照できます。
            また、疑似要素は、ソース文書に存在しないコンテンツにスタイルを割り当てる方法も提供します（例：
            <a href="generate.html#before-after-content">:before と :after</a>疑似要素は生成されたコンテンツにアクセスできます）。

        <li>疑似クラスは、名前、属性、または内容以外の特性に基づいて要素を分類します。
            基本的には、文書ツリーから推測できない特性です。
            疑似クラスは動的である場合があります。つまり、ユーザーが文書と対話する際に要素が疑似クラスを取得または失う可能性があります。
            例外として、<a href="#first-child">':first-child'</a>は文書ツリーから推測でき、
            <a href="#lang">':lang()'</a>も場合によっては文書ツリーから推測可能です。
    </ul>

    <p>疑似要素も疑似クラスも、文書ソースや文書ツリーには現れません。</p>

    <p>疑似クラスはセレクター内のどこにでも使用できますが、疑似要素はセレクターの最後の単純セレクターの後にのみ追加できます。</p>

    <p>疑似要素と疑似クラスの名前は大文字小文字を区別しません。</p>

    <p>一部の疑似クラスは相互排他的ですが、他のものは同じ要素に同時に適用することができます。
        競合する規則がある場合は、通常の<a href="cascade.html#cascading-order">カスケードの順序</a>が結果を決定します。</p>

    <h2>5.11 <a name="pseudo-class-selectors">疑似クラス</a></h2>

    <h3>5.11.1 <a name="first-child">:first-child</a> 疑似クラス</h3>

    <p><a name="x24"><span class="index-def" title="first-child|:first-child">:first-child</span></a>疑似クラスは、
        他の要素の最初の子要素である要素に一致します。</p>

    <div class="example">
        <p style="display:none">例：</p>
        <p>
            次の例では、セレクターはDIV要素の最初の子であるすべてのP要素に一致します。
            この規則は、DIVの最初の段落のインデントを抑制します：</p>

        <pre>
div &gt; p:first-child { text-indent: 0 }
</pre>

        このセレクターは、次の断片のDIV内のPに一致します：

        <pre>
&lt;P&gt; The last P before the note.
&lt;DIV class="note"&gt;
   &lt;P&gt; The first P inside the note.
&lt;/DIV&gt;
</pre>

        しかし、次の断片の2番目のPには一致しません：

        <pre>
&lt;P&gt; The last P before the note.
&lt;DIV class="note"&gt;
   &lt;H2&gt;Note&lt;/H2&gt;
   &lt;P&gt; The first P inside the note.
&lt;/DIV&gt;
</pre>
    </div>

    <div class="example">
        <p style="display:none">例：</p>
        <p>次の規則は、最初の子であるP要素の子孫であるすべてのEM要素のフォントウェイトを'bold'に設定します：</p>

        <pre>
p:first-child em { font-weight : bold }
</pre>
    </div>

    <p>注意：<a href="visuren.html#anonymous">匿名</a>ボックスは文書ツリーの一部ではないため、
        最初の子を計算する際に考慮されません。</p>

    <div class="html example">
        <p>例えば、次の例ではEMは：</p>

        <pre>
&lt;P&gt;abc &lt;EM&gt;default&lt;/EM&gt; 
</pre>

        Pの最初の子です。
    </div>

    <p>次の2つのセレクターは同等です：</p>

    <pre>
* &gt; a:first-child   /* 任意の要素の最初の子であるA */
a:first-child       /* 同じ */
</pre>


    <h3>5.11.2 <a name="link-pseudo-classes">リンク疑似クラス</a>: <a name="x26"><span class="index-def" title="pseudo-classes:::link|:link|link
(pseudo-class)">:link</span></a> および <a name="x29"><span class="index-def" title="pseudo-classes:::visited|:visited|visited
(pseudo-class)">:visited</span></a></h3>

    <p>ユーザーエージェントは通常、未訪問のリンクと既訪問のリンクを異なる方法で表示します。
        CSSは、これらを区別するために疑似クラス':link'と':visited'を提供します：</p>

    <ul>
        <li>:link 疑似クラスは、まだ訪問されていないリンクに適用されます。

        <li>:visited 疑似クラスは、ユーザーがリンクを訪問した後に適用されます。
    </ul>

    <p>UAは、訪問済みリンクを（未訪問の）':link'状態に戻す場合があります。</p>

    <p>これら2つの状態は相互排他的です。</p>

    <p>文書言語は、どの要素がハイパーリンクのソースアンカーであるかを決定します。
        例えば、HTML4では、リンク疑似クラスは"href"属性を持つA要素に適用されます。
        したがって、次の2つのCSS&nbsp;2.2宣言は同様の効果を持ちます：</p>

    <pre>
a:link { color: red }
:link  { color: red }
</pre>

    <div class="example">
        <p style="display:none">例：</p>
        <p>次のリンクが：</p>

        <pre>
&lt;A class="external" href="http://out.side/"&gt;external link&lt;/A&gt;
</pre>

        訪問済みの場合、この規則：

        <pre>
a.external:visited { color: blue }
</pre>

        は、そのリンクを青色にします。
    </div>

    <p class="note">注意：スタイルシートの著者がユーザーの同意なしに、ユーザーが訪問したサイトを特定するために
        :link と :visited 疑似クラスを悪用する可能性があります。</p>

    <p>そのため、UAはすべてのリンクを未訪問リンクとして扱うか、
        訪問済みリンクと未訪問リンクを異なる方法でレンダリングする際にユーザーのプライバシーを保護するための他の対策を実装する場合があります。
        プライバシーの取り扱いに関する詳細は<a href="refs.html#ref-P3P" rel="biblioentry" class="noxref"><span
                class="informref">[P3P]</span></a>を参照してください。</p>

    <h3>5.11.3 <a name="dynamic-pseudo-classes">動的疑似クラス:</a>
        <a name="x32"><span class="index-def" title="pseudo-classes:::hover|:hover|hover
(pseudo-class)">:hover</span></a>, <a name="x35"><span class="index-def" title="pseudo-classes:::active|:active|active
(pseudo-class)">:active</span></a>, および <a name="x38"><span class="index-def" title="pseudo-classes:::focus|:focus|focus
(pseudo-class)">:focus</span></a>
    </h3>

    <p>インタラクティブなユーザーエージェントは、ユーザーの操作に応じてレンダリングを変更することがあります。
        CSSは、一般的なケースのために3つの疑似クラスを提供します：</p>

    <ul>
        <li>:hover 疑似クラスは、ユーザーが要素を指定している間（ポインティングデバイスを使用して）適用されますが、
            要素をアクティブ化しません。例えば、ビジュアルユーザーエージェントは、要素によって生成されたボックス上に
            カーソル（マウスポインター）が存在する場合にこの疑似クラスを適用できます。
            <a href="media.html#interactive-media-group">インタラクティブメディア</a>をサポートしていない
            ユーザーエージェントは、この疑似クラスをサポートする必要はありません。
            <a href="media.html#interactive-media-group">インタラクティブメディア</a>をサポートする適合ユーザーエージェントの中には、
            この疑似クラスをサポートできない場合があります（例：ペンデバイス）。

        <li>:active 疑似クラスは、ユーザーによって要素がアクティブ化されている間に適用されます。
            例えば、ユーザーがマウスボタンを押してから離すまでの間。

        <li>:focus 疑似クラスは、要素がフォーカスを持っている間（キーボードイベントや他の形式のテキスト入力を受け付ける場合）に適用されます。
    </ul>

    <p>要素は同時に複数の疑似クラスに一致することがあります。</p>

    <p>CSSは、上記の状態にある要素や状態への移行方法を定義していません。
        スクリプトは、要素がユーザーイベントに反応するかどうかを変更することができ、
        デバイスやユーザーエージェントによって、要素を指し示したりアクティブ化したりする方法が異なる場合があります。</p>

    <p>CSS&nbsp;2.2は、':active'または':hover'状態にある要素の親がその状態にあるかどうかを定義していません。</p>

    <p>ユーザーエージェントは、疑似クラス遷移によって現在表示されている文書を再フローする必要はありません。
        例えば、スタイルシートが':active'リンクの<a href="fonts.html#propdef-font-size" class="noxref"><span
                class="propinst-font-size">'font-size'</span></a>が非アクティブのリンクよりも大きくなるように指定している場合、
        リンクを選択したときに文字が位置を変える可能性があるため、UAは対応するスタイル規則を無視することがあります。</p>

    <div class="example">
        <p style="display:none">例：</p>
        <p>

        <pre>
a:link    { color: red }    /* 未訪問リンク */
a:visited { color: blue }   /* 訪問済みリンク */
a:hover   { color: yellow } /* ユーザーがホバー中 */
a:active  { color: lime }   /* アクティブなリンク */
</pre>

        <p>A:hoverはA:linkおよびA:visitedの規則の後に配置する必要があります。
            そうでない場合、カスケード規則によってA:hover規則の<a href="colors.html#propdef-color" class="noxref"><span
                    class="propinst-color">'color'</span></a>プロパティが隠されます。
            同様に、A:activeがA:hoverの後に配置されるため、ユーザーがA要素をアクティブ化してホバーしている場合、
            アクティブな色（ライム）が適用されます。
    </div>

    <div class="example">
        <p style="display:none">例：</p>
        <p>動的疑似クラスを組み合わせた例：</p>

        <pre>
a:focus { background: yellow }
a:focus:hover { background: white }
</pre>

        <p>最後のセレクターは、疑似クラス:focusおよび疑似クラス:hoverにあるA要素に一致します。</p>

    </div>



    <p>フォーカスアウトラインの表示については、<a href="ui.html#dynamic-outlines">動的フォーカスアウトライン</a>
        のセクションを参照してください。</p>

    <div class="note">
        <p>
            <em><strong>注意：</strong>
                CSS1では、':active'疑似クラスは':link'および':visited'と相互排他的でした。
                現在はその制限はありません。要素は':visited'と':active'（または':link'と':active'）の両方である可能性があり、
                通常のカスケード規則によってどのスタイル宣言が適用されるかが決定されます。
            </em>
    </div>

    <div class="note">
        <p>
            <em><strong>注意：</strong>
                また、CSS1では':active'疑似クラスはリンクにのみ適用されていました。</em>
    </div>

    <h3>5.11.4 <a name="lang">言語疑似クラス:</a> <a name="x41"><span class="index-def" title="pseudo-classes:::lang|:lang|lang
(pseudo-class)">:lang</span></a></h3>

    <p>文書言語が要素の<a name="x44"><span class="index-inst" title="language (human)">人間の言語</span></a>を
        どのように決定するかを指定している場合、CSSセレクターでその言語に基づいて要素に一致させることができます。
        例えば、HTML <a href="refs.html#ref-HTML4" rel="biblioentry" class="noxref"><span
                class="normref">[HTML4]</span></a>では、
        言語は"lang"属性、META要素、およびプロトコル（HTTPヘッダーなど）からの情報の組み合わせによって決定されます。
        XMLはxml:langという属性を使用しており、他の文書言語固有の方法で言語を決定する場合もあります。</p>

    <p>疑似クラス':lang(C)'は、その要素が言語Cにある場合に一致します。
        一致するかどうかは、要素の言語値がCと等しいか、またはCがその言語値のハイフンで区切られた部分文字列であるかに基づきます。
        これは<a href="#attribute-selectors">'|='</a>演算子による場合と同様です。
        Cと要素の言語値の一致は、ASCII範囲内の文字について大文字小文字を区別せずに実行されます。
        Cは有効な言語名である必要はありません。</p>

    <p>Cは空であってはなりません。</p>

    <p class="note">注意：文書とプロトコルは、BCP&nbsp;47 <a href="refs.html#ref-BCP47" rel="biblioentry" class="noxref"><span
                class="informref">[BCP47]</span></a>またはその後継からのコードを使用して言語を示し、
        XMLベースの文書の場合は"xml:lang"属性を使用することを推奨します。
        詳細は<a href="https://www.w3.org/International/questions/qa-lang-2or3">「FAQ: Two-letter or three-letter language
            codes」</a>を参照してください。</p>

    <div class="example">
        <p style="display:none">例：</p>
        <p>次の規則は、カナダフランス語またはドイツ語のHTML文書の引用符を設定します：</p>

        <pre>
html:lang(fr-ca) { quotes: '« ' ' »' }
html:lang(de) { quotes: '»' '«' '\2039' '\203A' }
:lang(fr) > Q { quotes: '« ' ' »' }
:lang(de) > Q { quotes: '»' '«' '\2039' '\203A' }
</pre>

        <p>2番目の規則ペアは、親の言語に応じてQ要素の<a href="generate.html#propdef-quotes" class="noxref"><span
                    class="propinst-quotes">'quotes'</span></a>プロパティを実際に設定します。
            これは、引用符の選択が通常、引用自体ではなく引用の周囲の要素の言語に基づいているためです。
            例えば、英語のテキストの中にあるフランス語の「&agrave; l'improviste」は、英語の引用符を使用します。
    </div>

    <div class=note>
        <p><strong>注意</strong>：[lang|=xx]と:lang(xx)の違いに注意してください。
            このHTMLの例では、[lang|=fr]に一致するのはBODYのみですが（LANG属性を持っているため）、
            :lang(fr)にはBODYとPの両方が一致します（どちらもフランス語であるため）。</p>

        <pre>&lt;body lang=fr>
  &lt;p>Je suis Fran&ccedil;ais.&lt;/p>
&lt;/body></pre>
    </div>

    <h2>5.12 <a name="pseudo-element-selectors">疑似要素</a></h2>

    <p>疑似要素は、以下および<a href="generate.html#before-after-content">他の場所</a>で説明される例外を除き、
        CSSにおいて実際の要素と同様に機能します。</p>

    <p class="note"><em>以下のセクションは、すべてのケースにおける':first-line'および':first-letter'の正確なレンダリングを定義するものではありません。
            将来のCSSのレベルでは、これらがより正確に定義される可能性があります。</em></p>

    <h3>5.12.1 <a name="first-line-pseudo">:first-line</a> 疑似要素</h3>

    <p>:first-line疑似要素は、段落の最初の書式設定された行の内容に特別なスタイルを適用します。例えば：</p>

    <pre class="example">
p:first-line { text-transform: uppercase }
</pre>

    <p>上記の規則は、「すべての段落の最初の行の文字を大文字に変更する」という意味です。
        ただし、セレクター「P:first-line」は実際のHTML要素には一致しません。
        これは、<a href="conform.html#conformance">適合するユーザーエージェント</a>がすべての段落の先頭に挿入する疑似要素に一致します。</p>

    <p>最初の行の長さは、ページの幅、フォントサイズなど、いくつかの要因によって決まります。
        したがって、次のような通常のHTML段落：</p>

    <pre class="html example">
&lt;P&gt;This is a somewhat long HTML 
paragraph that will be broken into several 
lines. The first line will be identified
by a fictional tag sequence. The other lines 
will be treated as ordinary lines in the 
paragraph.&lt;/P&gt;
</pre>

    <p>が以下のように分割される場合があります：</p>

    <pre class="html example">
THIS IS A SOMEWHAT LONG HTML PARAGRAPH THAT
will be broken into several lines. The first
line will be identified by a fictional tag 
sequence. The other lines will be treated as 
ordinary lines in the paragraph.
</pre>

    <p>ユーザーエージェントによって、:first-lineのための<em><a name="x48"><span class="index-def"
                    title="fictional tag sequence">架空のタグシーケンス</span></a></em>を含むように「書き換えられる」可能性があります。この架空のタグシーケンスは、プロパティがどのように継承されるかを示すのに役立ちます。
    </p>

    <pre>
&lt;P&gt;<b>&lt;P:first-line&gt;</b> This is a somewhat long HTML 
paragraph that <b>&lt;/P:first-line&gt;</b> will be broken into several
lines. The first line will be identified 
by a fictional tag sequence. The other lines 
will be treated as ordinary lines in the 
paragraph.&lt;/P&gt;
</pre>

    <p>疑似要素が実際の要素を分割する場合、目的の効果は、要素を閉じて再度開く架空のタグシーケンスによって説明できることがよくあります。
        したがって、前の段落にSPAN要素をマークアップした場合：</p>

    <pre>
&lt;P&gt;<b>&lt;SPAN class="test"&gt;</b> This is a somewhat long HTML
paragraph that will be broken into several
lines.<b>&lt;/SPAN&gt;</b> The first line will be identified
by a fictional tag sequence. The other lines 
will be treated as ordinary lines in the 
paragraph.&lt;/P&gt;
</pre>

    <p>ユーザーエージェントは、:first-line用の架空のタグシーケンスを挿入する際に、
        SPANの開始タグと終了タグをシミュレートすることができます。</p>

    <pre>
&lt;P&gt;&lt;P:first-line&gt;<b>&lt;SPAN class="test"&gt;</b> This is a
somewhat long HTML
paragraph that will <b>&lt;/SPAN&gt;</b>&lt;/P:first-line&gt;<b>&lt;SPAN class="test"&gt;</b> be
broken into several
lines.<b>&lt;/SPAN&gt;</b> The first line will be identified
by a fictional tag sequence. The other lines
will be treated as ordinary lines in the 
paragraph.&lt;/P&gt;
</pre>

    <p>:first-line疑似要素は、<a href="visuren.html#block-boxes">ブロックコンテナ要素</a>にのみ付加できます。</p>

    <p><a name="first-formatted-line"></a>要素の「最初の書式設定された行」は、
        同じフロー内のブロックレベルの子孫（つまり、位置指定されておらず、フロートでもないブロックレベルの子孫）内部に発生する可能性があります。
        例えば、<code>&lt;DIV>&lt;P>This line...&lt;/P>&lt;/DIV></code>のDIVの最初の行は、Pの最初の行です（PとDIVがどちらもブロックレベルであると仮定）。</p>

    <p>表セルまたはインラインブロックの最初の行は、祖先要素の最初の書式設定された行にはなり得ません。
        したがって、<code>&lt;DIV&gt;&lt;P STYLE="display: inline-block">Hello&lt;BR&gt;Goodbye&lt;/P&gt; etcetera&lt;/DIV&gt;</code>では、DIVの最初の書式設定された行は「Hello」ではありません。
    </p>

    <p class="note">注：次の断片のPの最初の行：
        <code>&lt;p&gt;&lt;br&gt;First...</code>は文字を含んでいません（HTML 4のBRのデフォルトスタイルを仮定）。
        「First」という単語は最初の書式設定された行には含まれません。
    </p>

    <p>:first-line疑似要素の架空の開始タグは、最も内側の囲むブロックレベル要素のすぐ内側にネストされているように振る舞うべきです。
        （CSS1およびCSS2ではこのケースについて明確にされていなかったため、著者はこの動作に依存するべきではありません）。
        以下はその例です。次のHTML断片用の架空のタグシーケンスは：</p>

    <pre>
&lt;DIV>
  &lt;P>First paragraph&lt;/P>
  &lt;P>Second paragraph&lt;/P>
&lt;/DIV>
</pre>

    <p>以下のようになります：</p>

    <pre>
&lt;DIV>
  &lt;P>&lt;DIV:first-line>&lt;P:first-line>First paragraph&lt;/P:first-line>&lt;/DIV:first-line>&lt;/P>
  &lt;P>&lt;P:first-line>Second paragraph&lt;/P:first-line>&lt;/P>
&lt;/DIV>
</pre>

    <p><a name="first-line">:first-line</a>疑似要素は、インラインレベル要素に類似していますが、いくつかの制限があります。
        以下のプロパティは、:first-line疑似要素に適用されます：
        <a href="fonts.html">フォントプロパティ</a>、<a href="colors.html">カラー
            プロパティ</a>、<a href="colors.html#background-properties">背景プロパティ</a>、
        <a href="text.html#propdef-word-spacing" class="noxref"><span class="propinst-word-spacing">単語間隔</span></a>、
        <a href="text.html#propdef-letter-spacing" class="noxref"><span class="propinst-letter-spacing">文字間隔</span></a>、
        <a href="text.html#propdef-text-decoration" class="noxref"><span
                class="propinst-text-decoration">テキスト装飾</span></a>、
        <a href="text.html#propdef-text-transform" class="noxref"><span class="propinst-text-transform">文字変換</span></a>、
        および<a href="visudet.html#propdef-line-height" class="noxref"><span class="propinst-line-height">行の高さ</span></a>。
        UAは他のプロパティを適用する場合もあります。
    </p>


    <h3>5.12.2 <a name="first-letter"></a> <a name="x50"><span class="index-def"
                title="pseudo-elements:::first-letter|:first-letter|first-letter">:first-letter</span></a>
        擬似要素</h3>

    <p>:first-letter擬似要素は、ブロックの最初の行の最初の文字を選択しなければなりません。この文字がその行で他のコンテンツ（画像やインラインテーブルなど）に先行されていない場合です。:first-letter擬似要素は、<a
            name="x53"><span class="index-inst" title="initial
caps">「イニシャルキャップ」</span></a>や<a name="x54"><span class="index-inst" title="drop
caps">「ドロップキャップ」</span></a>といった一般的なタイポグラフィ効果のために使用できます。この種の最初の文字は、<a href="visuren.html#propdef-float"
            class="noxref"><span
                class="propinst-float">'float'</span></a>プロパティが'none'の場合、インラインレベル要素に似ています。それ以外の場合は、フロートされた要素に似ています。
    </p>

    <p>:first-letter擬似要素に適用されるプロパティは次のとおりです：
        <a href="fonts.html">フォントプロパティ,</a>
        <a href="text.html#propdef-text-decoration" class="noxref"><span
                class="propinst-text-decoration">'text-decoration',</span></a>
        <a href="text.html#propdef-text-transform" class="noxref"><span
                class="propinst-text-transform">'text-transform',</span></a>
        <a href="text.html#propdef-letter-spacing" class="noxref"><span
                class="propinst-letter-spacing">'letter-spacing',</span></a>
        <a href="text.html#propdef-word-spacing" class="noxref"><span
                class="propinst-word-spacing">'word-spacing'</span></a>（適切な場合）,
        <a href="visudet.html#propdef-line-height" class="noxref"><span
                class="propinst-line-height">'line-height',</span></a>
        <a href="visuren.html#propdef-float" class="noxref"><span class="propinst-float">'float',</span></a>
        <a href="visudet.html#propdef-vertical-align" class="noxref"><span
                class="propinst-vertical-align">'vertical-align'</span></a>（'float'が'none'の場合のみ）,
        <a href="box.html#margin-properties">マージンプロパティ,</a>
        <a href="box.html#padding-properties">パディングプロパティ,</a>
        <a href="box.html#border-properties">ボーダープロパティ,</a>
        <a href="colors.html">カラー プロパティ,</a>
        <a href="colors.html#background-properties">背景プロパティ.</a>
        ユーザーエージェント（UA）は他のプロパティを適用することもできます。タイポグラフィ的に正しいドロップキャップやイニシャルキャップの描画を可能にするために、UAは通常の要素とは異なり、文字の形状に基づいて行の高さ、幅、および高さを選択することができます。CSS3では:first-letterに特化したプロパティが期待されています。
    </p>

    <div class="html example">
        <p>この例は、イニシャルキャップの可能なレンダリングを示しています。'line-height'が:first-letter擬似要素に継承される値は1.1ですが、この例のUAでは最初の文字の高さを異なる方法で計算しているため、最初の2行間に不要なスペースができないようにしています。また、最初の文字の仮想開始タグがSPAN内にあるため、最初の文字のフォントウェイトはSPANのように太字ではなく、通常です：
        <pre>
p { line-height: 1.1 }
p:first-letter { font-size: 3em; font-weight: normal }
span { font-weight: bold }
...
&lt;p>&lt;span>Het hemelsche&lt;/span> gerecht heeft zich ten lange lesten&lt;br>
Erbarremt over my en mijn benaeuwde vesten&lt;br>
En arme burgery, en op mijn volcx gebed&lt;br>
En dagelix geschrey de bange stad ontzet.
</pre>
        <div class="figure">
            <p><img src="https://www.w3.org/TR/CSS22/images/initial-cap.png" alt=":first-letter擬似要素を示す画像">
        </div>
    </div>

    <div class="html example">
        <p>以下のCSS 2.2は、ドロップキャップの最初の文字を約2行分に広げる例です:</p>

        <pre>
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;HTML&gt;
 &lt;HEAD&gt;
  &lt;TITLE&gt;ドロップキャップの最初の文字&lt;/TITLE&gt;
  &lt;STYLE type="text/css"&gt;
   P              { font-size: 12pt; line-height: 1.2 }
   P:first-letter { font-size: 200%; font-style: italic;
                    font-weight: bold; float: left }
   SPAN           { text-transform: uppercase }
  &lt;/STYLE&gt;
 &lt;/HEAD&gt;
 &lt;BODY&gt;
  &lt;P&gt;&lt;SPAN&gt;The first&lt;/SPAN&gt; few words of an article
    in The Economist.&lt;/P&gt;
 &lt;/BODY&gt;
&lt;/HTML&gt;
</pre>

        <p>この例は次のようにフォーマットされる場合があります:</p>

        <div class="figure">
            <P><img src="https://www.w3.org/TR/CSS22/images/first-letter.png"
                    alt=":first-letterと:first-line擬似要素の組み合わせ効果を示す画像"><SPAN class="dlink">&nbsp;&nbsp;&nbsp;<A
                        name="img-first-letter"
                        href="https://www.w3.org/TR/CSS22/images/longdesc/first-letter-desc.html"
                        title="ドロップキャップの例の詳細な説明">[D]</A></SPAN></p>
        </div>

        <p><a name="x55"><span class="index-inst" title="fictional tag
sequence">仮想タグシーケンス</span></a>は以下の通りです:</p>

        <pre>
&lt;P&gt;
&lt;SPAN&gt;
&lt;P:first-letter&gt;
T
&lt;/P:first-letter&gt;he first
&lt;/SPAN&gt; 
few words of an article in the Economist.
&lt;/P&gt;
</pre>

        <p>:first-letter擬似要素のタグはコンテンツ（つまり最初の文字）に隣接していますが、:first-line擬似要素の開始タグはブロック要素の開始タグのすぐ後に挿入されます。</p>
    </div>

    <P>伝統的なドロップキャップのフォーマットを実現するために、ユーザーエージェントはベースラインを揃えるためにフォントサイズを近似する場合があります。また、フォーマット時にグリフのアウトラインが考慮される場合もあります。</P>

    <P>句読点（すなわち、Unicodeで定義された<a href="refs.html#ref-UNICODE" rel="biblioentry" class="noxref"><span
                class="normref">[UNICODE]</span></a>の"open" (Ps)、"close" (Pe)、"initial" (Pi)、"final" (Pf)、および"other"
        (Po)句読点クラスに属する文字）は、最初の文字の前後にあれば含める必要があります。例:</p>

    <div class="figure">
        <P><img src="https://www.w3.org/TR/CSS22/images/first-letter2.png" alt="最初の文字の前にある引用符も含めるべき例"><SPAN
                class="dlink">&nbsp;&nbsp;&nbsp;<A name="img-first-letter2"
                    href="https://www.w3.org/TR/CSS22/images/longdesc/first-letter2-desc.html"
                    title="句読点とドロップキャップ例の詳細な説明">[D]</A></SPAN></p>
    </div>

    <p>':first-letter'は、最初の文字が実際に数字である場合にも適用されます。例："67 million dollars is a lot of money."の"6"。</p>

    <p>:first-letter擬似要素は<a href="visuren.html#block-boxes">ブロックコンテナ要素</a>に適用されます。</p>

    <p>:first-letter擬似要素は、テキストを含む要素、または同じフローでテキストを含む子孫を持つ要素すべてに使用できます。UAは、最初の文字の擬似要素の仮想開始タグが要素の最初のテキストの直前にあるかのように振る舞うべきです。その最初のテキストが子孫内にある場合でも。
    </p>

    <div class=example>
        <P style="display:none">例:</P>
        <p>以下は例です。このHTMLフラグメントの仮想タグシーケンスは次の通りです:
        <pre>
&lt;div>
&lt;p>The first text.
</pre>
        <p>仮想タグシーケンス:
        <pre>
&lt;div>
&lt;p>&lt;div:first-letter>&lt;p:first-letter>T&lt;/...>&lt;/...>he first text.
</pre>
    </div>

    <p>テーブルセルやインラインブロックの最初の文字は、祖先要素の最初の文字にはなりません。例えば、<code>&lt;DIV&gt;&lt;P
STYLE="display: inline-block">Hello&lt;BR&gt;Goodbye&lt;/P&gt;
etcetera&lt;/DIV&gt;</code>の場合、DIVの最初の文字は"H"ではありません。実際、DIVには最初の文字がありません。</p>

    <p>最初の文字は<a
            href="#first-formatted-line">最初のフォーマットされた行</a>に現れる必要があります。例えば、このフラグメントでは:<code>&lt;p&gt;&lt;br&gt;First...</code>最初の行には文字が含まれていないため、':first-letter'は何にも一致しません（HTML
        4のBRのデフォルトスタイルを仮定）。特に、"First"の"F"にも一致しません。</p>

    <p>要素が<a href="generate.html#lists">リスト項目</a>（'display:
        list-item'）である場合、':first-letter'はマーカーの後の主要ボックス内の最初の文字に適用されます。UAは'list-style-position:
        inside'を持つリスト項目に対する':first-letter'を無視する場合があります。要素に':before'または':after'コンテンツがある場合、':first-letter'はそのコンテンツを<em>含む</em>要素の最初の文字に適用されます。
    </p>

    <p class="example">
        例えば、ルール 'p:before {content: "Note: "}' の後、セレクター 'p:first-letter' は "Note" の"N"に一致します。
    </p>

    <p>
        一部の言語には特定の文字の組み合わせを処理する特別なルールがある場合があります。例えば、オランダ語では、単語の先頭に"ij"という文字の組み合わせが現れる場合、両方の文字が:first-letter擬似要素内に含まれるべきです。
    </p>

    <p>最初の文字を形成する文字が同じ要素内にない場合（例えば、"'T"が<code>&lt;p>'&lt;em>T...</code>にある場合）、UAは1つの要素、両方の要素、または単に擬似要素を作成しない場合があります。</p>

    <p>同様に、ブロックの最初の文字が行の先頭にない場合（双方向の並べ替えが原因など）、UAは擬似要素を作成する必要はありません。</p>

    <div class="example">
        <P style="display:none">例:</P>
        <p>
            <a
                name="overlapping-example">次の例</a>は、重なり合う擬似要素がどのように相互作用するかを示しています。各P要素の最初の文字は緑色でフォントサイズが'24pt'になります。最初のフォーマットされた行の残りは青色、段落の残りは赤色になります。
        </p>

        <pre>
p { color: red; font-size: 12pt }
p:first-letter { color: green; font-size: 200% }
p:first-line { color: blue }

&lt;P&gt;Some text that ends up on two lines&lt;/P&gt;
</pre>

        <p>"ends"という単語の前で改行が発生すると仮定すると、このフラグメントの
            <a name="x56"><span class="index-inst" title="fictional tag sequence">仮想タグシーケンス</span></a>は次のようになります:
        </p>

        <pre>
&lt;P&gt;
&lt;P:first-line&gt;
&lt;P:first-letter&gt; 
S 
&lt;/P:first-letter&gt;ome text that 
&lt;/P:first-line&gt; 
ends up on two lines 
&lt;/P&gt;
</pre>

        <p>:first-letter要素は:first-line要素の内部にあります。:first-lineに設定されたプロパティは:first-letterによって継承されますが、同じプロパティが:first-letterに設定されている場合は上書きされます。
        </p>
    </div>

    <h3>5.12.3 <a name="before-and-after"></a> <a name="x57"><span class="index-def"
                title="pseudo-elements:::before|:before">:before</span></a> と <a name="x59"><span class="index-def"
                title="pseudo-elements:::after|:after">:after</span></a>
        擬似要素</h3>

    <p>':before' および ':after' 擬似要素は、要素の内容の前または後に生成されたコンテンツを挿入するために使用できます。それらは、<a
            href="generate.html">生成されたテキスト</a>のセクションで説明されています。</p>

    <div class="example">
        <P style="display:none">例:</P>
        <P>

        <pre>
h1:before {content: counter(chapno, upper-roman) ". "}
</pre>
    </div>

    <p>:first-letter および :first-line 擬似要素が、:before および :after
        を使用して生成されたコンテンツを持つ要素に適用される場合、それらは生成されたコンテンツを含む要素の最初の文字または行に適用されます。</p>

    <div class="example">
        <P style="display:none">例:</P>
        <P>

        <pre>
p.special:before {content: "Special! "}
p.special:first-letter {color: #ffd800}
</pre>

        <p>これにより "Special!" の "S" がゴールドでレンダリングされます。
    </div>

    <hr class="navbar">

    <div class="navbar">
        <p><a href="syndata.html">前へ</a> &nbsp;
            <a href="cascade.html">次へ</a> &nbsp;
            <a href="index.html#minitoc">目次</a> &nbsp;
            <a href="propidx.html">プロパティ</a> &nbsp;
            <a href="indexlist.html">索引</a> &nbsp;
    </div>
    <script src="https://htmlspecs.com/dropdown.js"></script>

</body>

</html>